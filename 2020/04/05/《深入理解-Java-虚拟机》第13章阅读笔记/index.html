<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
    <meta name="keywords" content="CS_learn, Keep Moving...">
  
  
    <meta name="description" content="The Space to record knowledge and my life.">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    《深入理解 Java 虚拟机》第13章阅读笔记 |
    
    Kelly&#39;s Blogs</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
<main class="content">
  <section class="outer">
  <article id="post-《深入理解-Java-虚拟机》第13章阅读笔记" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      《深入理解 Java 虚拟机》第13章阅读笔记
    </h1>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2020/04/05/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC13%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-04-05T08:56:03.000Z" itemprop="datePublished">2020-04-05</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h2 id="第-13-章-线程安全与锁优化"><a href="#第-13-章-线程安全与锁优化" class="headerlink" title="第 13 章 线程安全与锁优化"></a>第 13 章 线程安全与锁优化</h2><h3 id="一、线程安全"><a href="#一、线程安全" class="headerlink" title="一、线程安全"></a>一、线程安全</h3><p>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么就称这个对象是线程安全的。 </p>
<a id="more"></a>
<h4 id="1-Java-语言中的线程安全"><a href="#1-Java-语言中的线程安全" class="headerlink" title="1. Java 语言中的线程安全"></a>1. Java 语言中的线程安全</h4><h4 id="1-不可变"><a href="#1-不可变" class="headerlink" title="1) . 不可变"></a>1) . 不可变</h4><p>不可变的对象一定是线程安全的。</p>
<p>Java语言中，如果多线程共享的数据是一个<strong>基本数据类型</strong>，那么只要在定义时使用 final 关键字修饰它就可以保证它是不可变的。</p>
<p><strong>Java API 中不可变的类型</strong>：String，枚举类型，Long 和 Double 等数值包装类型、BigInteger 和BigDecimal 等大数据类型。</p>
<h4 id="2-绝对线程安全"><a href="#2-绝对线程安全" class="headerlink" title="2) . 绝对线程安全"></a>2) . 绝对线程安全</h4><p>不管运行时环境下采用何种调度方式，或者这些线程如何交替执行，调用者都不需要任何额外的同步措施。</p>
<h4 id="3-相对线程安全"><a href="#3-相对线程安全" class="headerlink" title="3) . 相对线程安全"></a>3) . 相对线程安全</h4><p>通常意义下的线程安全，保证对这个对象单次的操作是线程安全的，在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，可能需要在调用端使用额外的同步手段来保证调用的正确性。</p>
<p>例如 Vector、HashTable、Collections 的  synchronizedCollection()方法包装的集合等。</p>
<h4 id="4-线程兼容"><a href="#4-线程兼容" class="headerlink" title="4) . 线程兼容"></a>4) . 线程兼容</h4><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。</p>
<h4 id="5-线程对立"><a href="#5-线程对立" class="headerlink" title="5) . 线程对立"></a>5) . 线程对立</h4><p>线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。Java 语言天生就支持多线程，线程对立这种排斥多线程的代码是很少出现的，通常有害，应当尽量避免。</p>
<h4 id="2-线程安全的实现方法"><a href="#2-线程安全的实现方法" class="headerlink" title="2. 线程安全的实现方法"></a>2. 线程安全的实现方法</h4><h4 id="2-1-互斥同步-阻塞同步"><a href="#2-1-互斥同步-阻塞同步" class="headerlink" title="2.1. 互斥同步(阻塞同步)"></a>2.1. 互斥同步(阻塞同步)</h4><p><strong>同步</strong>：指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些， 当使用信号量的时候）线程使用。</p>
<p><strong>互斥</strong>：是实现同步的一种手段，<strong>临界区</strong>、<strong>互斥量</strong>和<strong>信号量</strong>都是常见的互斥实现方式。</p>
<h4 id="synchronized-关键字：最基本的互斥同步手段"><a href="#synchronized-关键字：最基本的互斥同步手段" class="headerlink" title="synchronized 关键字：最基本的互斥同步手段"></a>synchronized 关键字：最基本的互斥同步手段</h4><p>synchronized 关键字经过 Javac 编译之后，会在同步块的前后分别形成 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 这两个字节码指令。</p>
<p>synchronized 修饰对象，直接指定了对象参数，即对该对象锁定和解锁。</p>
<p>synchronized 修饰方法，根据方法的类型，实例方法取代码所在的对象实例，类方法取类型对应的 Class对象来作为线程要持有的锁。</p>
<p>在执行 monitorenter 指令时，首先要去尝试获取对象的锁。把锁的计数器的值增加一，而在执行 monitorexit 指令时会将锁计数器的值减一。一旦计数器的值为零，锁随即就被释放了。</p>
<ul>
<li>synchronized 修饰的同步块对同一线程可重入</li>
<li>在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。无法强制中断、退出。</li>
</ul>
<h4 id="java-util-concurrent-locks-Lock接口"><a href="#java-util-concurrent-locks-Lock接口" class="headerlink" title="java.util.concurrent.locks.Lock接口"></a>java.util.concurrent.locks.Lock接口</h4><p>ReentrantLock 可重入锁，Lock 接口的一种具体实现类。</p>
<p>比 synchronized 增加了一些高级功能：</p>
<ul>
<li>等待可中断</li>
<li>支持公平锁，默认非公平</li>
<li>锁绑定多个条件，可以同时绑定多个 Condition 对象，实现精确唤醒。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>synchronized：Java 语法层面，无法判断锁获取的状态，锁可以自动释放，Java 虚拟机更容易对其进行优化。</p>
<p>ReentrantLock：Java API，可以判断是否获取到锁，必须要在 finally 中手动释放锁。它比 synchronized 增加了一些高级功能，比如：等待可中断、公平锁、绑定多个条件。</p>
<h4 id="2-2-非阻塞同步"><a href="#2-2-非阻塞同步" class="headerlink" title="2.2. 非阻塞同步"></a>2.2. 非阻塞同步</h4><p>基于冲突检测的乐观并发策略，不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。</p>
<p>靠硬件来保证操作和冲突检测具有原子性。</p>
<p><strong>CAS 指令</strong></p>
<p>CAS 指令需要有三个操作数，分别是内存位置（在 Java 中可以简单地理解为变量的内存地址，用 V 表示）、旧的预期值（A）和准备设置的新值（B）。CAS 指令执行时，当且仅当 V 符合 A 时，处理器才会用B 更新 V 的值，否则就不执行更新。但是，不管是否更新了 V 的值，都会返回 V 的旧值，该处理过程是一个原子操作，执行期间不会被其他线程中断。</p>
<p>Java 中 CAS 操作由 sun.misc.Unsafe 类里面的 compareAndSwapInt() 和 compareAndSwapLong() 等几个方法包装提供。</p>
<p><strong>CAS 的漏洞 — ABA 问题</strong></p>
<p>问题描述：一个线程将 变量 A 改成 B，后来又改成了 A，CAS 操作会误认为该变量没有改变。</p>
<p>解决：带有标记的原子引用类 <code>AtomicStampedReference，</code>可以通过控制变量值的<strong>版本</strong>来保证 CAS 的正确性。</p>
<h4 id="2-3-无同步的方案"><a href="#2-3-无同步的方案" class="headerlink" title="2.3 无同步的方案"></a>2.3 无同步的方案</h4><p>让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证其正确性。</p>
<p><strong>可重入代码</strong>：所有可重入的代码都是线程安全的，但并非所 有的线程安全的代码都是可重入的。可重入代码不依赖全局变量、存储在堆上的数据和公用的系统资源， 用到的状态量都由参数中传入，不调用非可重入的方法等。</p>
<p><strong>线程本地存储</strong>：比如 ThreadLocal </p>
<h3 id="二、锁优化"><a href="#二、锁优化" class="headerlink" title="二、锁优化"></a>二、锁优化</h3><h4 id="1-自旋锁与自适应锁"><a href="#1-自旋锁与自适应锁" class="headerlink" title="1. 自旋锁与自适应锁"></a>1. 自旋锁与自适应锁</h4><p><strong>自旋锁</strong>：让后面请求锁的线程「稍等一会」，但不放弃处理器的执行时间，看持有锁的线程是否很快就会释放锁。为了让线程等待，只须让线程执行一个忙循环（自旋），这项技术就是自旋锁。</p>
<p>JDK 6 中对自旋锁的优化，引入了<strong>自适应的自旋</strong>。自适应意味着自旋的时间不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。</p>
<h4 id="2-锁消除"><a href="#2-锁消除" class="headerlink" title="2. 锁消除"></a>2. 锁消除</h4><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。</p>
<p>通过逃逸分析发现，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，不进行同步加锁。虽然有锁，但是可以被安全地消除掉。在解释执行时仍然会加锁，但在经过服务端编译器的即时编译之后，代码会忽略所有的同步措施而直接执行。</p>
<h4 id="3-锁粗化"><a href="#3-锁粗化" class="headerlink" title="3. 锁粗化"></a>3. 锁粗化</h4><p>如果虚拟机探测到有这样一串零碎的操作，都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p>
<h4 id="4-轻量级锁"><a href="#4-轻量级锁" class="headerlink" title="4. 轻量级锁"></a>4. 轻量级锁</h4><p>轻量级锁是JDK 6时加入的新型锁机制。</p>
<p>虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对 象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁。</p>
<h4 id="5-偏向锁"><a href="#5-偏向锁" class="headerlink" title="5. 偏向锁"></a>5. 偏向锁</h4><p>偏向锁也是 JDK 6 中引入的一项锁优化措施，它的目的是<strong>消除数据在无竞争情况下的同步原语</strong>， 进一步提高程序的运行性能。</p>
<p>偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p><img src="/2020/04/05/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC13%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/synchronized.png" alt="synchronized 锁升级"></p>
<p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadId 字段，在第一次访问的时候 threadId 为空，JVM 让其持有偏向锁，并将 threadId 设置为其线程 id，再次进入的时候会先判断 threadId 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>
<p>使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tiantianliu2018.github.io/2020/04/05/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC13%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" data-id="ckf6s5821004fxptt8q25aoli"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-%E5%9F%BA%E7%A1%80/" rel="tag">Java 基础</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2020/04/07/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8BOOM-%E7%AC%94%E8%AE%B0/" class="article-nav-link">
        <strong class="article-nav-caption">Newer posts</strong>
        <div class="article-nav-title">
          
            《深入理解 Java 虚拟机》OOM 笔记
          
        </div>
      </a>
    
    
      <a href="/2020/03/31/Flink-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Event-Time/" class="article-nav-link">
        <strong class="article-nav-caption">Olde posts</strong>
        <div class="article-nav-title">Flink 学习笔记 Event Time</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 Kelly&#39;s Blogs</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean" target="_blank" rel="noopener">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="Kelly&#39;s Blogs"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>

<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/snap.svg-min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>






<script src="/js/ocean.js"></script>


</body>
</html>