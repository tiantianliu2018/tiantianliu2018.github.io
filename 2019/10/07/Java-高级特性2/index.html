

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="The Space to record knowledge and my life.">
  <meta name="author" content="Kelly Liu">
  <meta name="keywords" content="CS_learn, Keep Moving...">
  <title>Java 高级特性2 - Kelly&#39;s Blogs</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kelly</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-10-07 08:44" pubdate>
        2019年10月7日 早上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      35
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Java 高级特性2</h1>
            
            <div class="markdown-body" id="post-body">
              <h1 id="Java-高级特性2"><a href="#Java-高级特性2" class="headerlink" title="Java 高级特性2"></a>Java 高级特性2</h1><h2 id="关键字-static"><a href="#关键字-static" class="headerlink" title="关键字 static"></a>关键字 static</h2><p>无论是否产生了对象或无论产生了多少对象，某些特定的数据在内存空间里只有一份</p>
<p>如果想让一个类的所有实例共享数据，应该使用<strong>类变量</strong></p>
<p>类变量：不用实例化，直接<code>类名.属性名</code> 就可以使用，是类的一部分，被所有这个类的实例化对象所共享，也可以叫做静态变量，用<code>static</code> 来修饰</p>
<p>实例变量：只有实例化后才能使用，属于实例化对象的一部分</p>
<p><strong>类属性、类方法的设计思想</strong></p>
<p>类属性作为该类各个对象之间共享的变量。在设计类时，分析哪些类属性不因对象的不同而改变，将这些属性设置为类属性。相应的方法设置为类方法。</p>
<p>如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用</p>
<p><strong>使用范围</strong></p>
<p>可用static修饰属性、方法、代码块、内部类</p>
<p><strong>被修饰后的成员具备以下特点</strong></p>
<p>随着类的加载而加载</p>
<p>优先于对象存在</p>
<p>修饰的成员，被所有该类的对象所共享</p>
<p>访问权限允许时，可不创建对象，直接被类调用</p>
<p><strong>类方法</strong></p>
<p>在static 方法内部只能访问类的<code>static</code>属性，不能访问类的非<code>static</code>属性</p>
<p>做工具类用最多</p>
<p>因为不需要实例就可以访问 <code>static</code> 方法，因此 <code>static</code>  方法内部不能有 <code>this</code> 和 <code>super</code></p>
<p>重载的方法需同为 <code>static</code>  或非 <code>static</code> </p>
<hr>

<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p><strong>设计模式</strong> 就是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。即在实际编程中，逐渐总结出的一些解决问题的套路。</p>
<p><strong>类的单例模式</strong>：采取一定的方法保证在整个软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法。</p>
<p>例如：实例化对象的创建要消耗大量的时间和资源。</p>
<p><strong>单例模式的实现方式</strong></p>
<ul>
<li><p>饿汉式</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Single</span> </span>&#123;
    <span class="hljs-comment">/**
     * 实现私有的构造函数，调用这个类的就不能直接用new来创建对象
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Single</span><span class="hljs-params">()</span></span>&#123;&#125;
    <span class="hljs-comment">// 私有的Single类变量，只能在类内部访问</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Single single = <span class="hljs-keyword">new</span> Single();
    <span class="hljs-comment">// getSingle() 为 static，不用创建对象即可访问</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Single <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> single;
    &#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;
        Single s1 = Single.getInstance();  <span class="hljs-comment">// 访问静态方法</span>
		Single s2 = Single.getInstance();
		<span class="hljs-keyword">if</span>(s1==s2)&#123;
			System.out.println(<span class="hljs-string">"s1 is equals to s2!"</span>);
		&#125;
    &#125;
&#125;</code></pre>
</li>
<li><p>懒汉式：最开始对象是null，直到有第一个人调用才new一个对象，之后都调用这个对象</p>
<pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Single1</span> </span>&#123;
	<span class="hljs-comment">// 先私有化构造方法，保证在此类的外部，不能调用本类的构造器</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Single1</span><span class="hljs-params">()</span></span>&#123;&#125;
    <span class="hljs-comment">// 先声明类的引用</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Single1 single = <span class="hljs-keyword">null</span>;
	<span class="hljs-comment">// 设置公有的方法来访问类的实例</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Single1 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-comment">// 如果类的实例未创建，先创建，再返回给调用者</span>
        <span class="hljs-keyword">if</span> (single==<span class="hljs-keyword">null</span>)&#123;
            single = <span class="hljs-keyword">new</span> Single1();
        &#125;
        <span class="hljs-comment">// 若有了实例，直接返回给调用者</span>
        <span class="hljs-keyword">return</span> single;
    &#125;
&#125;</code></pre>
</li>
</ul>
<hr>

<h2 id="理解-main-方法的语法"><a href="#理解-main-方法的语法" class="headerlink" title="理解 main 方法的语法"></a>理解 main 方法的语法</h2><p>由于 Java 虚拟机需要调用类的 <code>main()</code> 方法，所以该方法的访问权限是 <code>public</code>，又因为 java 虚拟机在执行 <code>main()</code> 方法时不必创建对象，所以该方法是 <code>static</code> 的，该方法接收一个 String 类型的数组参数，该数组中保存执行 java 命令时传递给所运行的类的参数。</p>
<p>Java 运行的类名 第一个参数 第二个参数 第三个参数 … …</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;&#125;</code></pre>
<hr>

<h2 id="类的成员之四：初始化块"><a href="#类的成员之四：初始化块" class="headerlink" title="类的成员之四：初始化块"></a>类的成员之四：初始化块</h2><p>初始化块（代码块）作用：对Java对象进行初始化</p>
<p>程序的执行顺序：</p>
<p>声明成员变量默认初始化 -&gt; 显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）-&gt; 构造器再对成员进行赋值操作</p>
<pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;
    <span class="hljs-comment">// 非静态代码块</span>
    &#123;
        System.out.println(<span class="hljs-string">""</span>);
    &#125;
    <span class="hljs-comment">// 静态代码块，只能使用静态的成员属性和方法</span>
    <span class="hljs-keyword">static</span>&#123;
        System.out.println(<span class="hljs-string">""</span>);
    &#125;
&#125;</code></pre>
<p>一个类中初始化块若有修饰符，则只能被 <code>static</code> 修饰，称为静态代码块，当类被载入时，类属性的声明和静态代码块先后顺序被执行，且<strong>只能被执行一次</strong>。</p>
<p><code>static</code> 块通常用于初始化 static（类）属性</p>
<pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> total;
    <span class="hljs-keyword">static</span>&#123;
        total = <span class="hljs-number">100</span>; <span class="hljs-comment">// 为 total 赋初值</span>
    &#125;
    ...... <span class="hljs-comment">// 其他属性或方法声明</span>
&#125;</code></pre>
<p><strong>非静态代码块</strong>：没有 static 修饰的代码块</p>
<ul>
<li><p>可以有输出语句</p>
</li>
<li><p>可以对类的属性声明进行初始化操作</p>
</li>
<li><p>可以调用静态和非静态的变量或方法</p>
</li>
<li><p>若有多个非静态代码块，那么按照从上到下的顺序依次执行</p>
</li>
<li><p>每次创建对象的时候，都会执行一次，且先于构造器执行</p>
</li>
</ul>
<p><strong>静态代码块</strong>：static 修饰的代码块</p>
<ul>
<li><p>可以有输出语句</p>
</li>
<li><p>可以对类的属性声明进行初始化操作</p>
</li>
<li>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法</li>
<li>若有多个静态代码块，那么按照从上到下的顺序依次执行</li>
<li>静态代码块的执行要先于非静态代码块</li>
<li>静态代码块只执行一次</li>
</ul>
<p><strong>在匿名类中，用代码块代替构造方法</strong></p>
<hr>

<h2 id="关键字-final"><a href="#关键字-final" class="headerlink" title="关键字 final"></a>关键字 final</h2><p>在 Java 中声明类、属性和方法时，可以用关键字 <code>final</code> 来修饰，表示”最终“</p>
<p><strong><code>final</code> 标记的类不能被继承。</strong> 提高安全性，提高程序的可读性。</p>
<p>​    String 类、System 类、StringBuffer 类</p>
<p>​    <code>final</code> 修饰类</p>
<pre><code class="hljs Java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;&#125; <span class="hljs-comment">// 错误，final类不能被继承</span>
&#125;</code></pre>
<p><strong><code>final</code> 标记的方法不能被子类重写</strong></p>
<p>​    Object 类中的 getClass()</p>
<p><strong><code>final</code> 标记的变量（成员变量或局部变量）即称为常量。</strong>名称大写，且只能被赋值一次。</p>
<p>​    final 标记的成员变量必须在声明的同时或在每个构造方法中或代码块中显式赋值，然后才能使用。</p>
<p>​    <code>final</code>、<code>static</code>  一起修饰变量，称为全局变量。</p>
<p>​    常量定义名称约定使用大写，如果由多个单词组成名称，用 <code>_</code> 连接</p>
<hr>

<h2 id="抽象类（abstract-class）"><a href="#抽象类（abstract-class）" class="headerlink" title="抽象类（abstract class）"></a>抽象类（abstract class）</h2><p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p>
<p>用 <code>abstract</code> 关键字来修饰一个类时，这个类叫做抽象类；</p>
<p>用 <code>abstract</code> 来修饰一个方法时，该方法叫做抽象方法。</p>
<p>​    抽象方法：只有方法的声明，没有方法的实现。以分号结束：</p>
<pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">abstractMethod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;</code></pre>
<p>含有抽象方法的类必须声明为抽象类</p>
<p><strong>抽象类不能被实例化。</strong>抽象类是用来作为父类被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。</p>
<p>不能用 <code>abstract</code> 修饰属性、私有方法、构造器、静态方法和 <code>final</code> 方法。</p>
<p><strong>抽象类应用</strong></p>
<p>抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类。</p>
<hr>

<h2 id="模板方法设计模式（TemplateMethod）"><a href="#模板方法设计模式（TemplateMethod）" class="headerlink" title="模板方法设计模式（TemplateMethod）"></a>模板方法设计模式（TemplateMethod）</h2><p>抽象类体现的就是一种模板模式的设计，<strong>抽象类作为多个子类的通用模板，</strong>子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
<blockquote>
<p>抽象类就像一个大纲，里面的抽象方法就是每个章节的标题。子类，去根据这些标题将每个章节细化出来。</p>
</blockquote>
<p><strong>解决的问题</strong></p>
<p>当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</p>
<p>编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类去实现，就是一种模板模式。</p>
<pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Template</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTime</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">// 定义子类不能重写的方法</span>
        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();
        code();
        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();
        System.out.println(<span class="hljs-string">"code() 方法执行时间是："</span>+ (end - start));
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">code</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 抽象方法，由子类去实现</span>
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubTemplate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Template</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">code</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10000</span>;i++)&#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;</code></pre>
<hr>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java 不支持多重继承。有了接口，就可以得到多重继承的效果。</p>
<p>接口（interface）是 <strong>抽象方法</strong> 和 <strong>常量值</strong> 的定义的集合</p>
<p>从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现。</p>
<p>实现接口类：</p>
<pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InterfaceA</span></span>&#123;&#125;</code></pre>
<p>一个类可以实现多个接口，接口也可以继承其它接口。</p>
<p><strong>接口的特点</strong></p>
<ul>
<li>用 <code>interface</code> 来定义</li>
<li>接口中所有成员变量都 <strong>默认由 <code>public static final</code> 修饰 （全局常量）</strong></li>
<li>接口中所有方法都 <strong>默认是由 <code>public abstract</code> 修饰的 (抽象方法)</strong></li>
<li>接口没有构造器</li>
<li>接口采用多层继承机制</li>
</ul>
<pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runner</span></span>&#123;
    <span class="hljs-keyword">int</span> ID = <span class="hljs-number">1</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>
<p>实现接口的类必须实现提供接口中所有方法的具体实现内容，方可实例化，否则，仍为抽象类。</p>
<p><strong>接口的主要用途是被实现类实现</strong>（面向接口编程）</p>
<p>与继承关系类似，接口与实现类之间存在多态性。</p>
<p>定义 Java 类的语法格式，先写 <code>extends</code>，后写 <code>implements</code></p>
<pre><code class="hljs Java">&lt;modifier&gt; class &lt;name&gt; [extends &lt;superclass&gt;] [implements &lt;interfce&gt;[,&lt;interface]*]&#123;&#125;</code></pre>
<p>一个类可以实现多个无关的接口。</p>
<p>与继承关系类似，接口与实现类之间存在多态。</p>
<p>如果实现接口的类中没有实现接口中的全部方法，必须将此类定义为抽象类。</p>
<p>抽象类是对于一类事物的高度抽象，其中既有属性也有方法；接口是对方法的抽象，也就是对一系列动作的抽象。</p>
<hr>

<h2 id="工厂方法（FactoryMethod）"><a href="#工厂方法（FactoryMethod）" class="headerlink" title="工厂方法（FactoryMethod）"></a>工厂方法（FactoryMethod）</h2><p>工厂方法模式是设计模式中应用最为广泛的模式，在面向对象的编程中，对象的创建工作非常简单，对象的创建时机却很重要。FactoryMethod解决的就是这个问题，它通过面向对象的手法，将所要创建的具体对象的创建工作延迟到了子类，从而提供了一种扩展的策略，较好的解决了这种紧耦合的关系。</p>
<p>通过工厂把 new 对象隔离，通过产品的接口可以接收不同实际产品的实现类，实例的类名的改变不影响其他合作开发人员的编程。</p>
<hr>

<h2 id="类的成员之五：内部类"><a href="#类的成员之五：内部类" class="headerlink" title="类的成员之五：内部类"></a>类的成员之五：内部类</h2><p>在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。</p>
<p>Inner class 一般用于在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。</p>
<p>​    Inner class 的名字不能与包含它的类名相同</p>
<p>Inner class 可以使用外部类的私有数据，因为它是外部类的成员，同一个类的成员之间可相互访问。而外部类要访问内部类中的成员需要 <code>内部类.成员</code> 或者 <code>内部类对象.成员</code></p>
<p>分类：</p>
<ul>
<li>成员内部类（static 成员内部类和非static成员内部类）</li>
<li>局部内部类（不谈修饰符）、匿名内部类</li>
</ul>
<p><strong>内部类的特性</strong></p>
<ul>
<li><p>Inner class 作为类的成员</p>
<p>​    可以声明为 <code>final</code></p>
<p>​    和外部类不同，Inner class 可声明为 <code>private</code> 或 <code>protected</code></p>
<p>​    Inner class 可以声明为 <code>static</code> 的，但此时就不能再使用外部类的 <code>非static</code> 成员变量</p>
</li>
<li><p>Inner class 作为类：</p>
<p>​    可以声明为 <code>abstract</code> 类，因此可以被其他内部类继承</p>
</li>
</ul>
<p>【注意】：非 static 的内部类中的成员不能声明为 <code>static</code> 的，只有在外部类或 <code>static</code> 的内部类中才可以声明 <code>static</code> 成员</p>
<p><strong>作用</strong></p>
<p>主要解决 Java 不能<strong>多重继承</strong>的问题</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/categories/Java/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">高级特性</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/10/07/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-comparative-study-on-network-alignment-techniques%E3%80%8B/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">论文阅读《A comparative study on network alignment techniques》</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/10/06/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AMapping-Users-across-Social-Media-Platforms-by-Integrating-Text-and-Structure-Information%E3%80%8B/">
                        <span class="hidden-mobile">论文阅读《Mapping Users across Social Media Platforms by Integrating Text and Structure Information》</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Java 高级特性2&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>















</body>
</html>
