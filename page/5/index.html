<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%91%8A%E7%99%BD%E6%B0%94%E7%90%8332.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%91%8A%E7%99%BD%E6%B0%94%E7%90%8316.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tiantianliu2018.github.io","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="The Space to record knowledge and my life.">
<meta property="og:type" content="website">
<meta property="og:title" content="Kelly&#39;s Blogs">
<meta property="og:url" content="http://tiantianliu2018.github.io/page/5/index.html">
<meta property="og:site_name" content="Kelly&#39;s Blogs">
<meta property="og:description" content="The Space to record knowledge and my life.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Kelly Liu">
<meta property="article:tag" content="CS_learn">
<meta property="article:tag" content=" Keep Moving...">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://tiantianliu2018.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>Kelly's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/clicklove.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kelly's Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">To Be Better</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">36</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">37</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">80</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://tiantianliu2018.github.io/2019/10/13/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AGraph-Neural-Networks-A-Review-of-Methods-and-Applications%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Kelly Liu">
      <meta itemprop="description" content="The Space to record knowledge and my life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kelly's Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/13/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AGraph-Neural-Networks-A-Review-of-Methods-and-Applications%E3%80%8B/" class="post-title-link" itemprop="url">论文阅读《Graph-Neural-Networks-A-Review-of-Methods-and-Applications》</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-13 14:09:25" itemprop="dateCreated datePublished" datetime="2019-10-13T14:09:25+08:00">2019-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-13 09:52:49" itemprop="dateModified" datetime="2020-09-13T09:52:49+08:00">2020-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Deep-Learning/" itemprop="url" rel="index"><span itemprop="name">Deep Learning</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Deep-Learning/Graph-Neural-Network/" itemprop="url" rel="index"><span itemprop="name">Graph Neural Network</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/10/13/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AGraph-Neural-Networks-A-Review-of-Methods-and-Applications%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/13/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AGraph-Neural-Networks-A-Review-of-Methods-and-Applications%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>82</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="论文阅读《Graph-Neural-Networks-A-Review-of-Methods-and-Applications》"><a href="#论文阅读《Graph-Neural-Networks-A-Review-of-Methods-and-Applications》" class="headerlink" title="论文阅读《Graph-Neural-Networks-A-Review-of-Methods-and-Applications》"></a>论文阅读《Graph-Neural-Networks-A-Review-of-Methods-and-Applications》</h1><h2 id="Graph-Nerual-Network"><a href="#Graph-Nerual-Network" class="headerlink" title="Graph Nerual Network"></a>Graph Nerual Network</h2>
      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://tiantianliu2018.github.io/2019/10/12/Java-%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Kelly Liu">
      <meta itemprop="description" content="The Space to record knowledge and my life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kelly's Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/12/Java-%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">Java 集合</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-12 08:38:34" itemprop="dateCreated datePublished" datetime="2019-10-12T08:38:34+08:00">2019-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-13 09:48:50" itemprop="dateModified" datetime="2020-09-13T09:48:50+08:00">2020-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E9%9B%86%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">集合</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/10/12/Java-%E9%9B%86%E5%90%88/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/12/Java-%E9%9B%86%E5%90%88/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>Java 集合类存放于 <code>java.util</code> 包中，是一个用来存放对象的容器</p>
<ul>
<li>Java 集合只能存放对象。</li>
<li>集合存放的是多个对象的引用，对象本身还是存放在堆内存中</li>
<li>集合可以存放不同类型，不限数量的数据类型</li>
</ul>
<p>Java 集合可分为 <code>Set</code>、<code>List</code>、<code>Map</code> 三种大体系：</p>
<ul>
<li><code>Set</code>：无序、不可重复集合</li>
<li><code>List</code>：有序，可重复集合</li>
<li><code>Map</code>：具有映射关系的集合</li>
</ul>
<p>在 JDK5 之后，增加了泛型，Java集合可以记住容器中对象的数据类型</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p><code>HashSet</code> 是 <code>Set</code> 接口的典型实现，大多数时候使用 <code>Set</code> 集合时都使用这个实现类。我们大多数时候说的 <code>Set</code> 集合值得都是 <code>HashSet</code></p>
<p><code>HashSet</code> 按 <code>Hash</code> 算法来存储集合中的元素，因此具有很好的存取和查找性能。</p>
<p><code>HashSet</code> 具有以下特点：</p>
<ul>
<li>不能保证元素的排列顺序</li>
<li>不可重复</li>
<li><code>HashSet</code> 不是线程安全的</li>
<li>集合元素可以是 <code>null</code></li>
</ul>
<p>当向 <code>HashSet</code> 集合中存入一个元素时，<code>HashSet</code> 会调用该对象的 <code>hashCode()</code> 方法来得到该对象的 <code>hashCode</code> 值，然后根据 <code>hashCode</code> 值确定该对象在 <code>HashSet</code> 中的存储位置。</p>
<p>如果两个元素的 <code>equals()</code> 方法返回 <code>true</code>，但它们的 <code>hashCode()</code> 返回值不相等，<code>hashSet</code> 将会把它们存储在不同的位置，但依然可以添加成功。</p>
<p><strong>Hashset 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">set.add(); 		<span class="comment">// 添加元素</span></span><br><span class="line">set.remove(); 	<span class="comment">// 移除元素</span></span><br><span class="line">set.contains(); <span class="comment">// 判断是否包含某个元素</span></span><br><span class="line">set.clear();	<span class="comment">// 清空集合</span></span><br><span class="line">set.size(); 	<span class="comment">// 集合中元素的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 集合的遍历 */</span></span><br><span class="line"><span class="comment">// 使用迭代器遍历集合</span></span><br><span class="line">Iterator iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for each 迭代集合</span></span><br><span class="line"><span class="keyword">for</span> (Object object: set) &#123;  <span class="comment">// 取出set中的每一个元素，赋值给object，直到循环set所有值</span></span><br><span class="line">    System.out.println(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>hashCode() 方法</strong></p>
<p>HashSet集合判断两个元素相等的标准：两个对象通过 <code>equals()</code> 方法比较相等，并且两个对象的 <code>hashCode()</code> 方法返回值也相等。</p>
<p>如果两个对象通过 <code>equals()</code> 方法返回 <code>true</code>，这两个对象的 <code>hashCode</code> 值也应该相同。</p>
<p>如果想让集合只能存同样类型的对象，使用<strong>泛型</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();  <span class="comment">// 该集合只能存 String 类型的数据</span></span><br></pre></td></tr></table></figure>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p><code>TreeSet</code> 是 <code>SortedSet</code> 接口的实现类，<code>TreeSet</code> 可以确保集合元素处于排序状态。<code>TreeSet</code> 支持两种排序方法：<strong>自然排序</strong>和<strong>定制排序</strong>。默认情况下，<code>TreeSet</code> 采用自然排序。</p>
<p><strong>自然排序</strong></p>
<p>排序：<code>TreeSet</code> 会调用集合元素的 <code>compareTo(Object obj)</code> 方法来比较元素之间的大小关系，然后将集合元素按升序排列</p>
<ul>
<li>如果 this &gt; obj, 返回正数 1</li>
<li>如果 this &lt; obj, 返回负数 -1</li>
<li>如果 this = obj, 返回 0，则认为这两个对象相等</li>
<li>必须放入同样类的对象（默认会进行排序）否则可能会发生类型转换异常，可以使用泛型来进行限制。</li>
</ul>
<p><strong>定制排序</strong></p>
<p>如果要实现定制排序，则需要在创建 <code>TreeSet</code> 集合对象时，提供一个 <code>Comparator</code> 接口的实现类对象。由该 <code>Comparator</code> 对象负责集合元素的排序逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;  <span class="comment">// 按照年龄排序</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;  <span class="comment">// 按年龄从小到大排序</span></span><br><span class="line">        <span class="keyword">if</span> (o1.age &gt; o2.age)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (o1.age &lt; o2.age)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="List-与-ArrayList"><a href="#List-与-ArrayList" class="headerlink" title="List 与 ArrayList"></a>List 与 ArrayList</h3><p><code>List</code> 代表一个元素有序，且可重复的集合，集合中的每个元素都有其对应的顺序</p>
<p><code>List</code> 允许使用重复元素，可以通过索引来访问指定位置的元素集合</p>
<p><code>List</code> 默认按元素的添加顺序设置元素的索引</p>
<p><code>List</code> 集合里添加了一些根据索引来操作集合的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">list.get(<span class="number">2</span>);  <span class="comment">// 通过索引来访问指定位置的集合元素</span></span><br><span class="line"></span><br><span class="line">list.add(<span class="number">1</span>,<span class="string">"f"</span>);  <span class="comment">// 在指定索引下标的位置插入数据</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; l = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">l.add(<span class="string">"123"</span>);</span><br><span class="line">l.add(<span class="string">"456"</span>);</span><br><span class="line">list.addAll(<span class="number">2</span>, l); <span class="comment">// 在指定索引下标的位置插入集合</span></span><br><span class="line"></span><br><span class="line">list.indexOf(<span class="string">"d"</span>);  <span class="comment">// 获取指定元素在集合中第一次出现的索引下标</span></span><br><span class="line">list.lastIndexOf(<span class="string">"d"</span>);  <span class="comment">// 获取指定元素在集合中最后一次出现的索引下标</span></span><br><span class="line"></span><br><span class="line">list.remove(<span class="number">2</span>);  <span class="comment">// 根据指定的索引下标移除数据</span></span><br><span class="line"></span><br><span class="line">list.set(<span class="number">1</span>, <span class="string">"ff"</span>); <span class="comment">// 根据指定索引下标修改元素</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; sublist = list.subList(<span class="number">2</span>,<span class="number">4</span>);  <span class="comment">// 根据索引下标的起始位置截取元素，前闭后开</span></span><br></pre></td></tr></table></figure>
<h3 id="ArrayList-和-Vector"><a href="#ArrayList-和-Vector" class="headerlink" title="ArrayList 和 Vector"></a>ArrayList 和 Vector</h3><p><code>ArrayList</code> 和 <code>Vector</code> 是 <code>List</code> 接口的两个典型实现。</p>
<p>区别：</p>
<ul>
<li><code>Vector</code> 是一个古老的集合，通常建议使用 <code>ArrayList</code></li>
<li><code>ArrayList</code> 是线程不安全的， 而 <code>Vector</code> 是线程安全的</li>
<li>即使为保证 <code>List</code> 集合线程安全，也不推荐使用 <code>Vector</code></li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><code>Map</code> 用于保存具有映射关系的数据，因此 <code>Map</code> 集合里保存着两组值，一组值用于保存 <code>Map</code> 里的 <code>Key</code>，另外一组用于保存 <code>Map</code> 里的 <code>Value</code></p>
<p><code>Map</code> 中的 <code>Key</code> 和 <code>Value</code> 都可以是任何引用类型的数据</p>
<p><code>Map</code> 中的 <code>key</code> 不允许重复，即同一个 <code>Map</code> 对象的任何两个 <code>Key</code> 通过 <code>equals()</code> 方法比较返回 <code>false</code></p>
<p><code>Key</code> 和 <code>Value</code> 之间存在单向一对一关系，即通过指定的 <code>Key</code> 总能找到唯一的确定的 <code>Value</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">"b"</span>,<span class="number">1</span>);  <span class="comment">// 添加数据</span></span><br><span class="line">   </span><br><span class="line">map.get(<span class="string">"b"</span>);  <span class="comment">// 根据 key 取值</span></span><br><span class="line">map.remove(<span class="string">"c"</span>);  <span class="comment">// 根据 key 移除键值对</span></span><br><span class="line">map.size();  <span class="comment">// map 集合的元素个数</span></span><br><span class="line"></span><br><span class="line">System.out.println(map.containsKey(<span class="string">"e"</span>));  <span class="comment">// 判断当前的 map 集合是否包含指定的 key</span></span><br><span class="line">System.out.println(map.containsValue(<span class="number">10</span>)); <span class="comment">// 判断当前的 map 集合是否包含指定的 value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 map 集合</span></span><br><span class="line">Set&lt;String&gt; keySet = map.keySet(); <span class="comment">// 获取 map 所有的 key</span></span><br><span class="line">map.values(); <span class="comment">// 获取 map 所有的 value</span></span><br><span class="line"><span class="keyword">for</span> (String key:keySet)&#123;</span><br><span class="line">System.out.println(<span class="string">"Key: "</span> + key + <span class="string">"\t Value: "</span>+ map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map.entrySet();</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; en: entrySet)&#123;</span><br><span class="line">System.out.println(<span class="string">"Key: "</span> + en.getKey() + <span class="string">"\t Value: "</span> + en.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap-和-Hashtable"><a href="#HashMap-和-Hashtable" class="headerlink" title="HashMap 和 Hashtable"></a>HashMap 和 Hashtable</h3><p><code>HashMap</code> 和 <code>HashValue</code> 是 Map 接口的两个典型实现类。</p>
<p>区别：</p>
<ul>
<li><code>Hashtable</code> 是一个古老的 Map 实现类，不建议使用</li>
<li><code>Hashtable</code> 是一个线程安全的 Map 实现，但 <code>HashMap</code> 是线程不安全的</li>
<li><code>Hashtable</code> 不允许使用 <code>null</code> 作为 <code>key</code> 和 <code>value</code>， 而 <code>HashMap</code> 可以</li>
</ul>
<p>与 <code>HashSet</code> 集合不能保证元素的顺序一样，<code>Hashtable</code>、<code>HashMap</code> 也不能保证其中 <code>key-value</code> 对的顺序</p>
<p><code>Hashtable</code>、<code>HashMap</code> 判断两个 <code>Key</code> 相等的标准是：两个 <code>key</code> 通过 <code>equals()</code> 方法返回 <code>true</code>，<code>hashCode</code>值也相等</p>
<p><code>Hashtable</code>、<code>HashMap</code>  相等的标准是：两个<code>value</code> 通过 <code>equalsHashMap</code> 判断两个 <code>Values</code> 方法返回 <code>true</code></p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p><code>TreeMap</code> 存储 <code>Key-Value</code> 对时，需要根据 <code>Key</code> 对 <code>key-value</code> 对进行排序。<code>TreeMap</code> 可以保证所有的 <code>Key-Value</code> 对处于有序状态.</p>
<p><code>TreeMap</code> 的 <code>key</code> 的排序：</p>
<ul>
<li>自然排序：<code>TreeMap</code> 的所有的 <code>Key</code> 必须实现 <code>Comparable</code> 接口，而且所有的 <code>Key</code> 应该是同一个类的对象，否则会抛出 <code>ClassCastException</code></li>
<li>定制排序：创建 <code>TreeMap</code> 时，传入一个 <code>Comparator</code> 对象，该对象负责对 <code>TreeMap</code> 中所有 <code>key</code> 进行排序。此时，不需要 <code>Map</code> 的 <code>Key</code> 实现 <code>Comparable</code> 接口</li>
</ul>
<h3 id="操作集合的工具类-Collections"><a href="#操作集合的工具类-Collections" class="headerlink" title="操作集合的工具类 Collections"></a>操作集合的工具类 Collections</h3><p>Collections 是一个操作 Set、List 和 Map 等集合的工具类</p>
<p>Collections 中提供了大量方法对集合进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。</p>
<p>排序操作：</p>
<ul>
<li><code>reverse(List)</code>: 反转 List 元素顺序</li>
<li><code>shuffle(List)</code>  对 List 集合元素进行随机排序</li>
<li><code>sort(List)</code> 根据元素的自然顺序对指定 List 集合元素按升序排序</li>
<li><code>sort(List, Comparator)</code> 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li><code>swap(List, int i, int j)</code> 将指定 list 集合中的 i 处元素 和 j 处元素进行交换</li>
</ul>
<p><strong>查找、替换</strong></p>
<ul>
<li><code>Object max(Collection)</code>：根据元素的自然顺序，返回给定集合中的最大元素</li>
<li><code>Object max(Collection, Comparator)</code>：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li>
<li><code>Object min(Collection)</code></li>
<li><code>Object min(Collection, Comparator)</code></li>
<li><code>int frequency(Collection, Object)</code>：返回指定集合中指定元素的出现次数</li>
<li><code>boolean replaceAll(List list, Object oldVal, Object newVal)</code> ：使用新值替换 List 对象的所有指定旧值</li>
</ul>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://tiantianliu2018.github.io/2019/10/11/Java-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Kelly Liu">
      <meta itemprop="description" content="The Space to record knowledge and my life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kelly's Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/11/Java-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">Java 异常处理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-11 08:44:38" itemprop="dateCreated datePublished" datetime="2019-10-11T08:44:38+08:00">2019-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-13 09:47:52" itemprop="dateModified" datetime="2020-09-13T09:47:52+08:00">2020-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/10/11/Java-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/11/Java-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java 异常处理"></a>Java 异常处理</h1><p>任何一种程序设计语言设计的程序在运行时都有可能出现错误，例如：除数为0，数组下标越界，要读写的文件不存在等</p>
<p>捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生</p>
<p>对于这些错误，一般有两种解决方法：</p>
<ul>
<li>遇到错误就终止程序的运行</li>
<li>由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理</li>
</ul>
<p><strong>异常</strong>：在Java语言中，将程序执行中发生的不正常情况称为“异常”</p>
<p>Java中的异常用于处理非预期的情况，如文件没找到，、网络错误、非法参数</p>
<p>Java程序运行过程中所发生的异常事件可分为两类：</p>
<ul>
<li>Error：JVM系统内部错误、资源耗尽等严重情况</li>
<li>Exception：其他因编程错误或偶然的外在因素导致的一般性问题，例如：<ul>
<li>空指针访问</li>
<li>试图读取不存在的文件</li>
<li>网络连接中断</li>
</ul>
</li>
</ul>
<p><strong>异常处理机制</strong></p>
<p>在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x/y运算时，要检测分母为0，数据为空，输入的不是数据而是字符等。过多的分支会导致程序的代码加长，可读性差。因此采用异常机制。</p>
<p>Java 异常处理：Java采用异常处理机制，将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁，并易于维护</p>
<p>Java 提供的是异常处理的抓抛模型。</p>
<p>Java 程序的执行过程中如出现异常，会自动生成一个异常类对象，该异常对象将被提交给 Java 运行时系统，这个过程为抛出（throw）异常。</p>
<p>如果一个方法内抛出异常，该异常会被抛出到调用方法中。如果异常没有在调用方法中处理，它继续被抛出给这个方法的调用者。这个程序将一直继续下去，直到异常被处理。这一过程称为捕获（catch）异常。</p>
<p>如果一个异常回到 <code>main()</code> 方法，并且 <code>main()</code> 也不处理，则程序运行终止。</p>
<p>程序员通常只能处理 Exception，而对 Error 无能为力</p>
<p><strong>捕获异常</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ... <span class="comment">// 可能产生异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionName1 e)&#123;</span><br><span class="line">    ... <span class="comment">// 当产生ExceptionName1 型异常时的处置措施</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionName2 e)&#123;</span><br><span class="line">    ... <span class="comment">// 当产生ExceptionName2 型异常时的处置措施</span></span><br><span class="line">&#125;[<span class="keyword">finally</span>]&#123;</span><br><span class="line">    ... <span class="comment">// 无条件执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>声明抛出异常</strong></p>
<p>声明抛出异常是Java中处理异常的第二种方式</p>
<p>​    如果一个方法（中的语句执行）可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显式地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理</p>
<p>​    在方法声明中用  <code>throws</code> 子句可以声明抛出异常的列表， <code>throws</code> 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String file)</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 读文件的操作可能产生 FileNotFoundException 类型的异常</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写方法声明抛出异常的原则：重写方法不能抛出比被重写方法范围更大的异常类型，即<strong>子类不能抛出比父类方法更大范围的异常</strong></p>
<p><strong>人工抛出异常</strong></p>
<p><strong>创建用户自定义异常类</strong></p>
<p>用户自定义异常类 <code>MyException</code> ，用于描述数据取值范围错误信息。用户自己的异常类必须继承现有的异常类。</p>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://tiantianliu2018.github.io/2019/10/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AConnecting-Users-across-Social-Media-Sites-A-Behavioral-Modeling-Approach%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Kelly Liu">
      <meta itemprop="description" content="The Space to record knowledge and my life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kelly's Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AConnecting-Users-across-Social-Media-Sites-A-Behavioral-Modeling-Approach%E3%80%8B/" class="post-title-link" itemprop="url">论文阅读《Connecting Users across Social Media Sites: A Behavioral-Modeling Approach》</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-10 13:46:43" itemprop="dateCreated datePublished" datetime="2019-10-10T13:46:43+08:00">2019-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-13 09:51:54" itemprop="dateModified" datetime="2020-09-13T09:51:54+08:00">2020-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">论文阅读</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Social-Networks/" itemprop="url" rel="index"><span itemprop="name">Social Networks</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/10/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AConnecting-Users-across-Social-Media-Sites-A-Behavioral-Modeling-Approach%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AConnecting-Users-across-Social-Media-Sites-A-Behavioral-Modeling-Approach%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Connecting-Users-across-Social-Media-Sites-A-Behavioral-Modeling-Approach"><a href="#Connecting-Users-across-Social-Media-Sites-A-Behavioral-Modeling-Approach" class="headerlink" title="Connecting Users across Social Media Sites: A Behavioral-Modeling Approach"></a>Connecting Users across Social Media Sites: A Behavioral-Modeling Approach</h1><blockquote>
<p>Zafarani R , Liu H . Connecting users across social media sites: a behavioral-modeling approach.[C]// Acm Sigkdd International Conference on Knowledge Discovery &amp; Data Mining. ACM, 2013.</p>
</blockquote>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>这篇文章真得是绝了，信息量少，通过各种角度各种层面构建特征的方式可谓无所不用其极。但也值得学习。</p>
<p>而且必须拿到很多个社交网站的用户名数据，先验用户名数据集才比较好。</p>
<p>2013年发表在KDD上的文章，由此可见计算机发展得迅速。</p>
<h2 id="Research-Objective"><a href="#Research-Objective" class="headerlink" title="Research Objective"></a>Research Objective</h2><p>解决跨社交媒体的用户标识问题：</p>
<ol>
<li>识别用户的独一无二的行为模式</li>
<li>利用这些行为模式构建特征</li>
<li>使用机器学习方法进行用户的识别</li>
</ol>
<h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><p>使用最少的信息确定两个用户是否是同一个身份。</p>
<p>已知一个用户在一些社交网站上的 <strong>用户名</strong> ，现有一个候选用户名 c ，判断c是否是该用户在该社交网站上的用户名。</p>
<h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h3 id="MOBIUS：行为模式与特征构建"><a href="#MOBIUS：行为模式与特征构建" class="headerlink" title="MOBIUS：行为模式与特征构建"></a>MOBIUS：行为模式与特征构建</h3><p>MOBIUS: MOdeling Behavior for Identifying Users across Sites </p>
<p>在一个社交网络上，尽量使自己的用户名和别人的不同。人类个体倾向于选择 “not long, not random, and have abundant redundancy”的用户名，这可以帮助我们挖掘其中的特征。</p>
<p>从用户选择不同社交网络用户名的行为模式中可以提取一下三类特征：</p>
<ul>
<li>（candidate）Username Features：从候选用户名中提取的特征，例如：用户名的长度</li>
<li>Prior-Username Features：例如：先验用户名的个数</li>
<li>Username  &lt;-&gt; Prior-Username Features ：先验用户名和候选用户名之间的关系，例如：相似性</li>
</ul>
<h4 id="1-Patterns-due-to-Human-Limitations"><a href="#1-Patterns-due-to-Human-Limitations" class="headerlink" title="1. Patterns due to Human Limitations"></a>1. Patterns due to Human Limitations</h4><ul>
<li><p>Limitations in Time and Memory </p>
<ul>
<li><p>选择之前用过的用户名 — &gt; 将候选用户名 c 在以前的用户名中重复的次数作为一个特征</p>
</li>
<li><p>用户名的长度：$\min <em>{u \in U} l</em>{u} \leq l<em>{c} \leq \max </em>{u \in U} l_{u}$  候选用户名的长度应该在之前用过的用户名的长度之间。 — &gt;  将候选用户名的长度和以前用户名的长度分布作为特征。</p>
<p>用户名长度的分布特征可以用一个五元组来表示：</p>
</li>
</ul>
<script type="math/tex; mode=display">
\left(\mathbb{E}\left[l_{u}\right], \sigma\left[l_{u}\right], \operatorname{med}\left[l_{u}\right], \min _{u \in U} l_{u}, \max _{u \in U} l_{u}\right)</script><ul>
<li>在之前的用户名中有多少个唯一的新的用户名 $uniqueness=\frac{|u n i q(U)|}{|U|}$</li>
</ul>
</li>
<li><p>Knowledge Limitation</p>
<ul>
<li>用户名中单词的数量</li>
<li>用户名单词数量的分布特征</li>
<li>用户名使用的字母的数量</li>
</ul>
</li>
</ul>
<h4 id="2-外在因素"><a href="#2-外在因素" class="headerlink" title="2. 外在因素"></a>2. 外在因素</h4><ul>
<li>Typing Patterns </li>
<li>Language Patterns ：用户名的语言</li>
</ul>
<h4 id="3-内部因素"><a href="#3-内部因素" class="headerlink" title="3. 内部因素"></a>3. 内部因素</h4><ul>
<li>Personal Attributes and Personality Traits <ul>
<li>Personal Information：使用字母的分布情况</li>
<li>Username Randomness：用户名字母分布的熵</li>
</ul>
</li>
<li>Habits<ul>
<li>Username Modification </li>
<li>Generating Similar Usernames </li>
<li>Username Observation Likelihood </li>
</ul>
</li>
</ul>
<p><img src="/2019/10/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AConnecting-Users-across-Social-Media-Sites-A-Behavioral-Modeling-Approach%E3%80%8B/features.png" alt="features"></p>
<h3 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h3><p>Naive Bayes </p>
<p>十折交叉验证</p>
<h4 id="Feature-Importance-Analysis"><a href="#Feature-Importance-Analysis" class="headerlink" title="Feature Importance Analysis"></a>Feature Importance Analysis</h4><p>odds-ratios（逻辑回归系数）</p>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://tiantianliu2018.github.io/2019/10/07/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-comparative-study-on-network-alignment-techniques%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Kelly Liu">
      <meta itemprop="description" content="The Space to record knowledge and my life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kelly's Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/07/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-comparative-study-on-network-alignment-techniques%E3%80%8B/" class="post-title-link" itemprop="url">论文阅读《A comparative study on network alignment techniques》</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-07 14:47:39" itemprop="dateCreated datePublished" datetime="2019-10-07T14:47:39+08:00">2019-10-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-13 09:51:43" itemprop="dateModified" datetime="2020-09-13T09:51:43+08:00">2020-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">论文阅读</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Social-Networks/" itemprop="url" rel="index"><span itemprop="name">Social Networks</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/10/07/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-comparative-study-on-network-alignment-techniques%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/07/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-comparative-study-on-network-alignment-techniques%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="A-comparative-study-on-network-alignment-techniques"><a href="#A-comparative-study-on-network-alignment-techniques" class="headerlink" title="A comparative study on network alignment techniques"></a>A comparative study on network alignment techniques</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>从矩阵对齐和网络表示学习的角度总结了state-of-the-art的7种方法，并建立了一个统一的基准平台。同时他们还研究了不同网络因素对于这些方法的影响。</p>
<p>这篇文章对于7种方法的介绍非常详细（数学真得好难），可以参考。</p>
<p>但是数据集对于该问题是主要的影响因素，但是公开数据集特别少。</p>
<h2 id="Research-Objective"><a href="#Research-Objective" class="headerlink" title="Research Objective"></a>Research Objective</h2><p>比较现有网络对齐的方法</p>
<p>评估公共框架下的 Network Alignment 技术</p>
<p>本研究的主要目的是提供一个灵活而强大的工具，以支持比较和促进网络对齐技术的基准分析。</p>
<h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><p>文章中将目前的 Network Align 方法分为 <strong>spectral methods</strong>（基于邻接矩阵的操作） 和 <strong>network representation methods</strong> (节点用嵌入向量表示，能够捕捉到网络的结构信息)</p>
<p>虽然Network Alignment方法的研究已经很长时间了，但由于缺少公共数据集和共同的评价指标，还没有比较过这些方法的性能。</p>
<h3 id="Network-alignment-methods"><a href="#Network-alignment-methods" class="headerlink" title="Network alignment methods"></a>Network alignment methods</h3><p>网络对齐技术利用结构一致性和属性一致性假设来构建它们的模型。</p>
<p>结构一致性：同质性原则，即邻近的节点倾向于在不同的网络中维持它们之间的关系</p>
<p>属性一致性：属于同一身份的在不同网络上的节点可能保持相同的属性(特征)</p>
<ul>
<li><h4 id="Spectral-methods-—-matrix-factorization-矩阵分解"><a href="#Spectral-methods-—-matrix-factorization-矩阵分解" class="headerlink" title="Spectral methods — matrix factorization 矩阵分解"></a>Spectral methods — matrix factorization 矩阵分解</h4><p>使用矩阵分解，直接计算对齐矩阵 S </p>
<p><img src="/2019/10/07/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-comparative-study-on-network-alignment-techniques%E3%80%8B/spectral_method.png" alt="spectral_method"></p>
<p>将输入的图用连接矩阵的形式表示，Spectral methods 以损失函数的形式定义模型，模型考虑了源和目标网络的邻接矩阵；节点特征为常量，对齐矩阵S为变量。在对准过程中，根据结构和/或属性一致性假设，通过优化损失函数来学习得到对准矩阵。</p>
<p>Spectral methods 不同之处在于构建模型时使用什么一致性原则以及该原则如何使用的</p>
<ul>
<li><p><strong>IsoRank</strong>：如果来自不同网络的两个节点的邻居是相似的，那么这两个节点是相似的。因此该方法中，节点的相似性取决于两个节点邻居的相似性。</p>
<p>similarity：</p>
<script type="math/tex; mode=display">
\mathbf{S}\left(u_{s}, v_{t}\right)=\sum_{w_{s} \in N\left(u_{s}\right)} \sum_{w_{t} \in N\left(v_{t}\right)} \frac{1}{\left|N\left(u_{s}\right)\right|\left|N\left(v_{t}\right)\right|} \mathbf{S}\left(w_{s}, w_{t}\right)  \\
u_{s}源网络的节点，v_t目标网络的节点，N(u)节点u的邻居集合  \\
上面的公式可以写成：S=CS \\
where \\
\mathbf{C}[i, j][u, v]=\left\{\begin{array}{ll}{\frac{1}{|N(u)||N(v)|},} & {\text { if }(i, u) \in E_{s},(i, v) \in E_{t}} \\ {0,} & {\text { otherwise }}\end{array}\right.  \\
通过迭代的方法更新S\\
\mathbf{S}^{k+1} \leftarrow \frac{\mathbf{C S}^{k}}{\left|\mathbf{C S}^{k}\right|}  \\
其中S^{k}是第k次迭代的对齐矩阵</script><p>该方法对于网络的结构较敏感</p>
</li>
<li><p><strong>BigAlign</strong></p>
<p>利用网络节点的原始特征和手工提取的特征，如节点度、权重、集群系数等，将源网络和目标网络转换成二分图，从而解决网络对齐问题。</p>
<p>求置换矩阵 P，使损失函数最小化:</p>
<script type="math/tex; mode=display">
\mathbb{L}(\mathbf{P})=\left\|\mathbf{P D}_{s} \mathbf{P}^{T}-\mathbf{D}_{t}\right\|_{F}^{2}</script><p>P 用于对 $D<em>{s}$ 的行进行重新排序，$P^{t}$ 用于对 $D</em>{t}$ 的列进行重新排序。难解。</p>
<p>将图转化成二分图然后最小化损失函数：</p>
<script type="math/tex; mode=display">
\begin{aligned} \mathbb{L}(\mathbf{P}, \mathbf{Q}) &=\left\|\mathbf{P D}_{s} \mathbf{Q}-\mathbf{D}_{t}\right\|_{F}^{2}+\lambda \sum_{i, j} \mathbf{P}(i, j)+\phi \sum_{i, j} \mathbf{Q}(i, j) \\ &=\operatorname{Tr}\left(\mathbf{P D}_{s} \mathbf{Q}\left(\mathbf{P D}_{s} \mathbf{Q}\right)^{T}-2 \mathbf{P D}_{s} \mathbf{Q} \mathbf{D}_{t}^{T}\right)+\lambda \mathbf{1}^{T} \mathbf{P} \mathbf{1}+\phi \mathbf{1}^{T} \mathbf{Q} \mathbf{1} \end{aligned} \\
其中 Tr(·) 是矩阵的迹, \lambda \sum_{i, j} \mathbf{P}(i, j) 是矩阵的稀疏性约束 \\</script><p>上面的损失函数可以通过 <strong>alternating projected gradient descent (APGD)  </strong>来优化：</p>
<script type="math/tex; mode=display">
\begin{array}{l}{\mathbf{P}_{k+1}=\mathbf{P}_{k}-\eta_{P} \cdot\left(2\left(\mathbf{P}_{k} \mathbf{D}_{s} \mathbf{Q}_{k}-\mathbf{D}_{t}\right) \mathbf{Q}_{k}^{T} \mathbf{D}_{s}^{T}+\lambda \mathbf{1} \mathbf{I}^{T}\right)} \\ {\left.\mathbf{Q}_{k+1}=\mathbf{Q}_{k}-\eta_{Q} \cdot\left(2 \mathbf{D}_{s}^{T} \mathbf{P}_{k+1}^{T} \mathbf{D}_{s} \mathbf{Q}_{k}-\mathbf{D}_{t}\right)+\phi \mathbf{1} \mathbf{1}^{T}\right)}\end{array} \\
P_k 是第k次迭代的矩阵P，\eta_{P},\eta_{Q}为APGD算法的步长</script><p>仅用属性信息而忽略了拓扑信息。</p>
</li>
<li><p><strong>FINAL</strong></p>
<p>通过定义结构相似性、节点特征相似性和边特征的相似性条件</p>
<script type="math/tex; mode=display">
\begin{aligned} \mathbb{L}(\mathbf{S}) &=\sum_{u_{s}, v_{s}, u_{t}, v_{t}}\left[\frac{\mathbf{S}\left(u_{s}, u_{t}\right)}{\sqrt{f\left(u_{s}, u_{t}\right)}}-\frac{\mathbf{S}\left(v_{s}, v_{t}\right)}{\sqrt{f\left(v_{s}, v_{t}\right)}}\right] \\ & \times \mathbf{D}_{s}\left(u_{s}, v_{s}\right) \mathbf{D}_{t}\left(u_{t}, v_{t}\right) \end{aligned} \\
\begin{array}{l}{\times \mathbb{1}\left(A\left(u_{s}\right)=A\left(u_{t}\right)\right) \mathbb{1}\left(A\left(v_{s}\right)=A\left(v_{t}\right)\right)} \\ {\times \mathbb{1}\left(A_{e}\left(u_{s}, v_{s}\right)=A_{e}\left(u_{t}, v_{t}\right)\right)}\end{array} \\
其中A_e是边属性矩阵，\mathbb{1}(\cdot)是一个指示函数，如果括号中的条件正确，则返回1，\sqrt{f\left(u, u\right)} 是一个归一化因子</script><p><img src="/2019/10/07/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-comparative-study-on-network-alignment-techniques%E3%80%8B/FINAL.png" alt="FINAL"></p>
<blockquote>
<p>数学好难，没看懂。。。</p>
</blockquote>
</li>
<li><p><strong>REGAL</strong></p>
<p>两个节点之间的相似性：</p>
<script type="math/tex; mode=display">
\mathbf{S}^{\prime}(u, v)=\exp \left(-\lambda_{s} \cdot\left\|\mathbf{d}_{u}-\mathbf{d}_{v}\right\|^{2}-\lambda_{a} \cdot \operatorname{dist}(\mathbf{A}(u), \mathbf{A}(v))\right)</script></li>
<li></li>
</ul>
</li>
<li><h4 id="Representation-learning-methods"><a href="#Representation-learning-methods" class="headerlink" title="Representation learning methods"></a>Representation learning methods</h4><p>embedding generation 嵌入的生成</p>
<p>alignment matrix generation 对齐矩阵的生成</p>
<p>对于基于嵌入的网络对齐方法，不同之处在于embedding function 和 mapping function</p>
<ul>
<li><p><strong>PALE</strong></p>
<p><img src="/2019/10/07/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-comparative-study-on-network-alignment-techniques%E3%80%8B/PALE.png" alt="PALE"></p>
<blockquote>
<p><a href="https://tiantianliu2018.github.io/2019/09/28/论文阅读《Predict-Anchor-Links-across-Social-Networks-via-an-Embedding-Approach》/">https://tiantianliu2018.github.io/2019/09/28/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8APredict-Anchor-Links-across-Social-Networks-via-an-Embedding-Approach%E3%80%8B/</a></p>
<p>我之前的阅读笔记。</p>
</blockquote>
<p>首先对网络进行扩展：如果在source网络中 $u_s$ 和 $v_s$存在边，并且知道这两个在target网络中对应的节点 $u_t$ 和 $v_t$, 那么  $u_t$ 和 $v_t$ 之间也应该有边，因此通过这样的方式扩展网络</p>
<p><strong>Emdedding function</strong></p>
<script type="math/tex; mode=display">
\theta(v_i) = E[i]</script><p>其中 $E$ 是 embedding matrix，它是通过最小化如下损失得到的：</p>
<script type="math/tex; mode=display">
\mathbb{L}(\mathbf{E})=\log \sigma\left(\mathbf{u}^{T} \cdot \mathbf{v}\right)+\sum_{k=1}^{K} \mathbb{E}_{w \alpha P_{n}(v)}\left[\log \left(1-\sigma\left(\mathbf{u}^{T} \cdot \mathbf{w}\right)\right)\right]</script><p>其中 $(u,v) \in E$  是观测到的边，$w$ 是通过在E中负采样的节点</p>
<p><strong>Mapping function</strong></p>
<script type="math/tex; mode=display">
\phi\left(\mathbf{u}_{s}\right)=\mathbf{M} \times \mathbf{u}_{s}</script><p>$M$ 是一个$d×d$ 的矩阵，通过最小化下面的损失函数得到：</p>
<script type="math/tex; mode=display">
\mathbb{L}(\mathbf{M})=\sum_{\mathbf{H}\left(v_{s}, v_{t}\right)=1}\left\|\phi\left(\mathbf{v}_{\mathbf{s}}\right)-\mathbf{v}_{t}\right\|</script><p>$H$ 是先验对齐矩阵</p>
</li>
<li><p><strong>DeepLink</strong></p>
<p>embedding graph 与PALE是一样的，但在mapping function中考虑了mapping的方向</p>
<p><img src="/2019/10/07/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-comparative-study-on-network-alignment-techniques%E3%80%8B/DEEPLINK.png" alt="DEEPLINK"></p>
<p><strong>Emdedding function</strong></p>
<script type="math/tex; mode=display">
\theta(v_i) = E[i]</script><p>参数 $E$ 的 loss function:</p>
<script type="math/tex; mode=display">
\mathbb{L}_{\theta}(\mathbf{E})=\log \sigma(\mathbf{u} \cdot \mathbf{v})+\sum_{k=1}^{K} \mathbb{E}_{w \propto P_{n}(v)}[\log (1-\sigma(\mathbf{u} \cdot \mathbf{w}))]</script><p>DeepLink方法认为如果 $v$ 是 $u$随机游走过程中的节点，则认为这两个节点相似。</p>
<p><strong>Mapping function</strong></p>
<p>从源网络 $G_s$ 到目标网络 $G_t$ 的 mapping function</p>
<script type="math/tex; mode=display">
\phi_{s, t}\left(\mathbf{u}_{s}\right)=\mathbf{M}_{s, t} \times \mathbf{u}_{s}+\mathbf{b}_{s, t}</script><p>类似的 从目标网络 $G_t$ 到源网络 $G_s$ 的 mapping function</p>
<script type="math/tex; mode=display">
\phi_{t, s}\left(\mathbf{u}_{t}\right)=\mathbf{M}_{t, s} \times \mathbf{v}_{t}+\mathbf{b}_{t, s}</script><p>参数 $\phi<em>{s, t}$ 通过最优化如下loss function得到（$\phi</em>{t, s}$ 类似）：</p>
<script type="math/tex; mode=display">
\mathbb{L}\left(\mathbf{W}_{s, t}, \mathbf{b}_{s, t}\right) =\sum_{\left(v_{s}, v_{t}\right) \in H} \min \left(1-\cos \left(\phi\left(\mathbf{v}_{s}\right), \mathbf{v}_{t}\right)\right)</script><p>对于两个网络中的同一个用户，他们的嵌入向量应该是相似的，因此，通过最小化损失函数来改进 $\phi<em>{s, t}$ 和 $\phi</em>{t, s}$:</p>
<script type="math/tex; mode=display">
\mathbb{L}\left(\mathbf{W}_{s, t}, \mathbf{b}_{s, t}, \mathbf{W}_{t, s}, \mathbf{b}_{t, s}\right)=\operatorname{dist}\left(\phi_{t, s}\left(\phi_{s, t}(\mathbf{u})\right), \mathbf{u}\right)</script><p>对于监督学习，最大化 reward function</p>
<script type="math/tex; mode=display">
r_{s, t}^{u}=\frac{1}{k} \sum_{w \in T_{k}(u)} \log (\cos (\mathbf{w}, \mathbf{v})+1)  \\
其中 T_k(u) 是G_t中与\phi_{s,t}(u) embedding最接近的top-k个节点  \\
\phi_{t,s}的reward \, function 为：\\
r_{t, s}^{v}=\frac{1}{k} \sum_{w \in T_{k}(v)} \log (\cos (\mathbf{w}, \mathbf{u})+1)</script><blockquote>
<p><a href="https://tiantianliu2018.github.io/2019/09/15/论文阅读《DeepLink-A-Deep-Learning-Approach-for-User-Identity-Linkage》/">https://tiantianliu2018.github.io/2019/09/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADeepLink-A-Deep-Learning-Approach-for-User-Identity-Linkage%E3%80%8B/</a><br> 之前的论文阅读笔记<br> 又一大堆数学公式推导，好像没有看下去。</p>
</blockquote>
</li>
<li><p><strong>IONE</strong></p>
<p>IONE 与 PALE 的 mapping function 是相同的，但是其 embedding function 更加复杂，它在计算节点的嵌入时考虑了节点的邻居特征。</p>
<p><strong>Embedding function</strong></p>
<p>一个 embedding 矩阵，其中的每一行是由三个向量拼接到一起的：节点向量、输入上下文向量、输出上下文向量，最终其 embedding function 为：</p>
<script type="math/tex; mode=display">
\theta_i = E[i], E \in \mathbb{R}^{|V| \times 3 d}</script><p>该方法的思想是：一个节点的节点向量可以影响其邻居的输入上下文向量，而其邻居的节点向量可以影响其输出上下文向量。</p>
<p>为了学习 $E$, 该方法需要满足两个目标：</p>
<ol>
<li><p>每个图中相邻的节点应该具有类似的节点嵌入</p>
<p>为了实现该目标，可以通过考虑一个节点向量相对于其邻居的输入上下文向量的贡献概率来实现：</p>
<script type="math/tex; mode=display">
p_{1}(u | v)=\frac{\exp \left(\mathbf{u}^{\prime T} \cdot \mathbf{v}\right)}{\sum_{w \in G} \exp \left(\mathbf{w}^{\prime T} \cdot \mathbf{v}\right)}</script><p>其经验定义为：</p>
<script type="math/tex; mode=display">
\hat{p}_{1}(u, v)=\frac{w_{u, v}}{|\{v |(u, v) \in E\}|}\\
其中w_{u,v}是边(u,v)的权重</script><p>类似的，一个节点向量对其邻居的输出上下文向量的贡献的概率及其经验定义：</p>
<script type="math/tex; mode=display">
\begin{aligned} p_{2}(v | u) &=\frac{\exp \left(\mathbf{v}^{\prime \prime T} \cdot \mathbf{u}\right)}{\sum_{w \in G} \exp \left(\mathbf{w}^{\prime \prime} T \cdot \mathbf{u}\right)} \\ \hat{p}_{2}(u, v) &=\frac{w_{u, v}}{|\{v |(v, u) \in E\}|} \end{aligned}</script><p>$p_1$ 应该和 $p_2$ 是相似的，于是有如下目标函数：</p>
<script type="math/tex; mode=display">
\begin{aligned} \mathbb{L}_{1}(\mathbf{E})=&-\sum_{G \in\left\{G_{s}, G_{t}\right\}} \sum_{(u, v) \in G} w_{u, v} \log p_{1}(v | u) \\ &-\sum_{G \in\left\{G_{s}, G_{t}\right\}} \sum_{(u, v) \in G} w_{u, v} \log p_{2}(u | v) \end{aligned}</script></li>
<li><p>具有近似嵌入的节点是很好的对齐节点的候选节点</p>
<p>在两个网络中，两个节点如果是同一个用户，那么这两个节点是可以相互代替的，其代替的程度应该是由这两个节点是同一个用户的可信度确定的，基于这一点，对目标函数L1进行修改，将相应节点的信息考虑如下：</p>
<script type="math/tex; mode=display">
\begin{aligned} \mathbb{L}_{2}(\mathbf{E})=&-\sum_{w_{t} \in G_{t}} \sum_{\left(u_{s}, v_{s}\right) \in V_{s}} w_{u_{s}, v_{s}} p_{a}\left(u_{s} | w_{t}\right) \log p_{1}\left(v_{s} | w_{t}\right) \\ &-\sum_{w_{t} \in G_{t}} \sum_{\left(u_{s}, v_{s}\right) \in V_{s}} w_{u_{s}, v_{s}} p_{a}\left(v_{s} | w_{t}\right) \log p_{1}\left(u_{s} | w_{t}\right) \\ &-\sum_{w_{s} \in G_{s}} \sum_{\left(u_{t}, v_{t}\right) \in V_{t}} w_{u_{t}, v_{t}} p_{a}\left(u_{t} | w_{s}\right) \log p_{1}\left(v_{t} | w_{s}\right) \\ &-\sum_{w_{s} \in G_{s}} \sum_{\left(u_{t}, v_{t}\right) \in V_{t}} w_{u_{t}, v_{t}} p_{a}\left(v_{t} | w_{s}\right) \log p_{1}\left(u_{t} | w_{s}\right) \end{aligned}</script><p>最终通过最小化联合目标函数，得到嵌入的参数</p>
<script type="math/tex; mode=display">
\mathbb{L}(\mathbf{E}) = \mathbb{L}_{1}(\mathbf{E}) + \mathbb{L}_{2}(\mathbf{E})</script></li>
</ol>
<p><strong>Mapping function</strong></p>
<p>IONE的映射函数是PALE的映射函数的一个特例，映射矩阵M是单位矩阵</p>
<blockquote>
<pre><code>   [https://tiantianliu2018.github.io/2019/09/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AAligning-Users-Across-Social-Networks-Using-Network-Embedding%E3%80%8B/](https://tiantianliu2018.github.io/2019/09/30/论文阅读《Aligning-Users-Across-Social-Networks-Using-Network-Embedding》/)
</code></pre><p>之前的论文阅读笔记</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p><img src="/2019/10/07/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-comparative-study-on-network-alignment-techniques%E3%80%8B/benchmark.png" alt="Benchmark"></p>
<h3 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h3><p><strong>Real-world datasets</strong>：这些数据集的质量好像都不太高</p>
<ul>
<li>S1. Douban online vs Douban offline </li>
<li>S2. Flickr vs Lastfm </li>
<li>S3. Flickr vs MySpace</li>
<li>S4. Twitter vs Facebook </li>
<li>S5. Twitter vs Foursquare </li>
</ul>
<p><strong>Synthetic datasets</strong></p>
<ul>
<li>Partial synthetic：用真实网络生成目标网络</li>
<li>Full synthetic：</li>
</ul>
<hr>

<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><h3 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h3><p><strong>Accuracy</strong></p>
<script type="math/tex; mode=display">
acc = \frac {\# {correctly \ \ identified \ \ node \ \ pairs}}{\# {groundtruth\ \ node\ \ pairs}}</script><p><strong>Precision@k</strong></p>
<script type="math/tex; mode=display">
Precision@k = \frac {\# {Times \ \ that \ \ target \ \ node \ \ in \ \ top \ k \ \ similarity \ \ candiates}}{\#{groundtruth \ \  node \ \ pairs}}</script><p><strong>Mean Average Precision (MAP) </strong></p>
<script type="math/tex; mode=display">
MAP = mean(\frac{1}{ra}) \\ra 是排序后的候选序列中匹配节点的rank</script><h3 id="Evaluation-procedure"><a href="#Evaluation-procedure" class="headerlink" title="Evaluation procedure"></a>Evaluation procedure</h3><ul>
<li>Structural noise level </li>
<li>Attribute noise level </li>
<li>Graph size </li>
<li>Graph size imbalance </li>
<li>Graph density </li>
<li>Graph connectivity </li>
<li>Number of connected components </li>
</ul>
<h3 id="Experimental-evaluation"><a href="#Experimental-evaluation" class="headerlink" title="Experimental evaluation"></a>Experimental evaluation</h3><p>评估以上因素对于实验的影响</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>克服真实网络中的结构和属性不稳定性是网络对齐面临的主要挑战之一</p>
<h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2>
      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://tiantianliu2018.github.io/2019/10/07/Java-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A72/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Kelly Liu">
      <meta itemprop="description" content="The Space to record knowledge and my life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kelly's Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/07/Java-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A72/" class="post-title-link" itemprop="url">Java 高级特性2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-07 08:44:28" itemprop="dateCreated datePublished" datetime="2019-10-07T08:44:28+08:00">2019-10-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-13 09:49:27" itemprop="dateModified" datetime="2020-09-13T09:49:27+08:00">2020-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">高级特性</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/10/07/Java-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A72/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/07/Java-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A72/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.3k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-高级特性2"><a href="#Java-高级特性2" class="headerlink" title="Java 高级特性2"></a>Java 高级特性2</h1><h2 id="关键字-static"><a href="#关键字-static" class="headerlink" title="关键字 static"></a>关键字 static</h2><p>无论是否产生了对象或无论产生了多少对象，某些特定的数据在内存空间里只有一份</p>
<p>如果想让一个类的所有实例共享数据，应该使用<strong>类变量</strong></p>
<p>类变量：不用实例化，直接<code>类名.属性名</code> 就可以使用，是类的一部分，被所有这个类的实例化对象所共享，也可以叫做静态变量，用<code>static</code> 来修饰</p>
<p>实例变量：只有实例化后才能使用，属于实例化对象的一部分</p>
<p><strong>类属性、类方法的设计思想</strong></p>
<p>类属性作为该类各个对象之间共享的变量。在设计类时，分析哪些类属性不因对象的不同而改变，将这些属性设置为类属性。相应的方法设置为类方法。</p>
<p>如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用</p>
<p><strong>使用范围</strong></p>
<p>可用static修饰属性、方法、代码块、内部类</p>
<p><strong>被修饰后的成员具备以下特点</strong></p>
<p>随着类的加载而加载</p>
<p>优先于对象存在</p>
<p>修饰的成员，被所有该类的对象所共享</p>
<p>访问权限允许时，可不创建对象，直接被类调用</p>
<p><strong>类方法</strong></p>
<p>在static 方法内部只能访问类的<code>static</code>属性，不能访问类的非<code>static</code>属性</p>
<p>做工具类用最多</p>
<p>因为不需要实例就可以访问 <code>static</code> 方法，因此 <code>static</code>  方法内部不能有 <code>this</code> 和 <code>super</code></p>
<p>重载的方法需同为 <code>static</code>  或非 <code>static</code> </p>
<hr>

<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p><strong>设计模式</strong> 就是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。即在实际编程中，逐渐总结出的一些解决问题的套路。</p>
<p><strong>类的单例模式</strong>：采取一定的方法保证在整个软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法。</p>
<p>例如：实例化对象的创建要消耗大量的时间和资源。</p>
<p><strong>单例模式的实现方式</strong></p>
<ul>
<li><p>饿汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现私有的构造函数，调用这个类的就不能直接用new来创建对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 私有的Single类变量，只能在类内部访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single single = <span class="keyword">new</span> Single();</span><br><span class="line">    <span class="comment">// getSingle() 为 static，不用创建对象即可访问</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Single s1 = Single.getInstance();  <span class="comment">// 访问静态方法</span></span><br><span class="line">		Single s2 = Single.getInstance();</span><br><span class="line">		<span class="keyword">if</span>(s1==s2)&#123;</span><br><span class="line">			System.out.println(<span class="string">"s1 is equals to s2!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>懒汉式：最开始对象是null，直到有第一个人调用才new一个对象，之后都调用这个对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single1</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先私有化构造方法，保证在此类的外部，不能调用本类的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 先声明类的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single1 single = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// 设置公有的方法来访问类的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果类的实例未创建，先创建，再返回给调用者</span></span><br><span class="line">        <span class="keyword">if</span> (single==<span class="keyword">null</span>)&#123;</span><br><span class="line">            single = <span class="keyword">new</span> Single1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若有了实例，直接返回给调用者</span></span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>

<h2 id="理解-main-方法的语法"><a href="#理解-main-方法的语法" class="headerlink" title="理解 main 方法的语法"></a>理解 main 方法的语法</h2><p>由于 Java 虚拟机需要调用类的 <code>main()</code> 方法，所以该方法的访问权限是 <code>public</code>，又因为 java 虚拟机在执行 <code>main()</code> 方法时不必创建对象，所以该方法是 <code>static</code> 的，该方法接收一个 String 类型的数组参数，该数组中保存执行 java 命令时传递给所运行的类的参数。</p>
<p>Java 运行的类名 第一个参数 第二个参数 第三个参数 … …</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<hr>

<h2 id="类的成员之四：初始化块"><a href="#类的成员之四：初始化块" class="headerlink" title="类的成员之四：初始化块"></a>类的成员之四：初始化块</h2><p>初始化块（代码块）作用：对Java对象进行初始化</p>
<p>程序的执行顺序：</p>
<p>声明成员变量默认初始化 -&gt; 显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）-&gt; 构造器再对成员进行赋值操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">// 非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态代码块，只能使用静态的成员属性和方法</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类中初始化块若有修饰符，则只能被 <code>static</code> 修饰，称为静态代码块，当类被载入时，类属性的声明和静态代码块先后顺序被执行，且<strong>只能被执行一次</strong>。</p>
<p><code>static</code> 块通常用于初始化 static（类）属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> total;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        total = <span class="number">100</span>; <span class="comment">// 为 total 赋初值</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...... <span class="comment">// 其他属性或方法声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非静态代码块</strong>：没有 static 修饰的代码块</p>
<ul>
<li><p>可以有输出语句</p>
</li>
<li><p>可以对类的属性声明进行初始化操作</p>
</li>
<li><p>可以调用静态和非静态的变量或方法</p>
</li>
<li><p>若有多个非静态代码块，那么按照从上到下的顺序依次执行</p>
</li>
<li><p>每次创建对象的时候，都会执行一次，且先于构造器执行</p>
</li>
</ul>
<p><strong>静态代码块</strong>：static 修饰的代码块</p>
<ul>
<li><p>可以有输出语句</p>
</li>
<li><p>可以对类的属性声明进行初始化操作</p>
</li>
<li>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法</li>
<li>若有多个静态代码块，那么按照从上到下的顺序依次执行</li>
<li>静态代码块的执行要先于非静态代码块</li>
<li>静态代码块只执行一次</li>
</ul>
<p><strong>在匿名类中，用代码块代替构造方法</strong></p>
<hr>

<h2 id="关键字-final"><a href="#关键字-final" class="headerlink" title="关键字 final"></a>关键字 final</h2><p>在 Java 中声明类、属性和方法时，可以用关键字 <code>final</code> 来修饰，表示”最终“</p>
<p><strong><code>final</code> 标记的类不能被继承。</strong> 提高安全性，提高程序的可读性。</p>
<p>​    String 类、System 类、StringBuffer 类</p>
<p>​    <code>final</code> 修饰类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125; <span class="comment">// 错误，final类不能被继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>final</code> 标记的方法不能被子类重写</strong></p>
<p>​    Object 类中的 getClass()</p>
<p><strong><code>final</code> 标记的变量（成员变量或局部变量）即称为常量。</strong>名称大写，且只能被赋值一次。</p>
<p>​    final 标记的成员变量必须在声明的同时或在每个构造方法中或代码块中显式赋值，然后才能使用。</p>
<p>​    <code>final</code>、<code>static</code>  一起修饰变量，称为全局变量。</p>
<p>​    常量定义名称约定使用大写，如果由多个单词组成名称，用 <code>_</code> 连接</p>
<hr>

<h2 id="抽象类（abstract-class）"><a href="#抽象类（abstract-class）" class="headerlink" title="抽象类（abstract class）"></a>抽象类（abstract class）</h2><p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p>
<p>用 <code>abstract</code> 关键字来修饰一个类时，这个类叫做抽象类；</p>
<p>用 <code>abstract</code> 来修饰一个方法时，该方法叫做抽象方法。</p>
<p>​    抽象方法：只有方法的声明，没有方法的实现。以分号结束：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">abstractMethod</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure>
<p>含有抽象方法的类必须声明为抽象类</p>
<p><strong>抽象类不能被实例化。</strong>抽象类是用来作为父类被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。</p>
<p>不能用 <code>abstract</code> 修饰属性、私有方法、构造器、静态方法和 <code>final</code> 方法。</p>
<p><strong>抽象类应用</strong></p>
<p>抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类。</p>
<hr>

<h2 id="模板方法设计模式（TemplateMethod）"><a href="#模板方法设计模式（TemplateMethod）" class="headerlink" title="模板方法设计模式（TemplateMethod）"></a>模板方法设计模式（TemplateMethod）</h2><p>抽象类体现的就是一种模板模式的设计，<strong>抽象类作为多个子类的通用模板，</strong>子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
<blockquote>
<p>抽象类就像一个大纲，里面的抽象方法就是每个章节的标题。子类，去根据这些标题将每个章节细化出来。</p>
</blockquote>
<p><strong>解决的问题</strong></p>
<p>当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</p>
<p>编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类去实现，就是一种模板模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">getTime</span><span class="params">()</span></span>&#123;  <span class="comment">// 定义子类不能重写的方法</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        code();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"code() 方法执行时间是："</span>+ (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;  <span class="comment">// 抽象方法，由子类去实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubTemplate</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java 不支持多重继承。有了接口，就可以得到多重继承的效果。</p>
<p>接口（interface）是 <strong>抽象方法</strong> 和 <strong>常量值</strong> 的定义的集合</p>
<p>从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现。</p>
<p>实现接口类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>一个类可以实现多个接口，接口也可以继承其它接口。</p>
<p><strong>接口的特点</strong></p>
<ul>
<li>用 <code>interface</code> 来定义</li>
<li>接口中所有成员变量都 <strong>默认由 <code>public static final</code> 修饰 （全局常量）</strong></li>
<li>接口中所有方法都 <strong>默认是由 <code>public abstract</code> 修饰的 (抽象方法)</strong></li>
<li>接口没有构造器</li>
<li>接口采用多层继承机制</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runner</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ID = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现接口的类必须实现提供接口中所有方法的具体实现内容，方可实例化，否则，仍为抽象类。</p>
<p><strong>接口的主要用途是被实现类实现</strong>（面向接口编程）</p>
<p>与继承关系类似，接口与实现类之间存在多态性。</p>
<p>定义 Java 类的语法格式，先写 <code>extends</code>，后写 <code>implements</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;modifier&gt; class &lt;name&gt; [extends &lt;superclass&gt;] [implements &lt;interfce&gt;[,&lt;interface]*]&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>一个类可以实现多个无关的接口。</p>
<p>与继承关系类似，接口与实现类之间存在多态。</p>
<p>如果实现接口的类中没有实现接口中的全部方法，必须将此类定义为抽象类。</p>
<p>抽象类是对于一类事物的高度抽象，其中既有属性也有方法；接口是对方法的抽象，也就是对一系列动作的抽象。</p>
<hr>

<h2 id="工厂方法（FactoryMethod）"><a href="#工厂方法（FactoryMethod）" class="headerlink" title="工厂方法（FactoryMethod）"></a>工厂方法（FactoryMethod）</h2><p>工厂方法模式是设计模式中应用最为广泛的模式，在面向对象的编程中，对象的创建工作非常简单，对象的创建时机却很重要。FactoryMethod解决的就是这个问题，它通过面向对象的手法，将所要创建的具体对象的创建工作延迟到了子类，从而提供了一种扩展的策略，较好的解决了这种紧耦合的关系。</p>
<p>通过工厂把 new 对象隔离，通过产品的接口可以接收不同实际产品的实现类，实例的类名的改变不影响其他合作开发人员的编程。</p>
<hr>

<h2 id="类的成员之五：内部类"><a href="#类的成员之五：内部类" class="headerlink" title="类的成员之五：内部类"></a>类的成员之五：内部类</h2><p>在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。</p>
<p>Inner class 一般用于在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。</p>
<p>​    Inner class 的名字不能与包含它的类名相同</p>
<p>Inner class 可以使用外部类的私有数据，因为它是外部类的成员，同一个类的成员之间可相互访问。而外部类要访问内部类中的成员需要 <code>内部类.成员</code> 或者 <code>内部类对象.成员</code></p>
<p>分类：</p>
<ul>
<li>成员内部类（static 成员内部类和非static成员内部类）</li>
<li>局部内部类（不谈修饰符）、匿名内部类</li>
</ul>
<p><strong>内部类的特性</strong></p>
<ul>
<li><p>Inner class 作为类的成员</p>
<p>​    可以声明为 <code>final</code></p>
<p>​    和外部类不同，Inner class 可声明为 <code>private</code> 或 <code>protected</code></p>
<p>​    Inner class 可以声明为 <code>static</code> 的，但此时就不能再使用外部类的 <code>非static</code> 成员变量</p>
</li>
<li><p>Inner class 作为类：</p>
<p>​    可以声明为 <code>abstract</code> 类，因此可以被其他内部类继承</p>
</li>
</ul>
<p>【注意】：非 static 的内部类中的成员不能声明为 <code>static</code> 的，只有在外部类或 <code>static</code> 的内部类中才可以声明 <code>static</code> 成员</p>
<p><strong>作用</strong></p>
<p>主要解决 Java 不能<strong>多重继承</strong>的问题</p>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://tiantianliu2018.github.io/2019/10/06/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AMapping-Users-across-Social-Media-Platforms-by-Integrating-Text-and-Structure-Information%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Kelly Liu">
      <meta itemprop="description" content="The Space to record knowledge and my life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kelly's Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/06/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AMapping-Users-across-Social-Media-Platforms-by-Integrating-Text-and-Structure-Information%E3%80%8B/" class="post-title-link" itemprop="url">论文阅读《Mapping Users across Social Media Platforms by Integrating Text and Structure Information》</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-06 14:07:15" itemprop="dateCreated datePublished" datetime="2019-10-06T14:07:15+08:00">2019-10-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-13 09:54:50" itemprop="dateModified" datetime="2020-09-13T09:54:50+08:00">2020-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">论文阅读</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Social-Networks/" itemprop="url" rel="index"><span itemprop="name">Social Networks</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/10/06/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AMapping-Users-across-Social-Media-Platforms-by-Integrating-Text-and-Structure-Information%E3%80%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/06/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AMapping-Users-across-Social-Media-Platforms-by-Integrating-Text-and-Structure-Information%E3%80%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Mapping-Users-across-Social-Media-Platforms-by-Integrating-Text-and-Structure-Information-2017-IEEE-ISI"><a href="#Mapping-Users-across-Social-Media-Platforms-by-Integrating-Text-and-Structure-Information-2017-IEEE-ISI" class="headerlink" title="Mapping Users across Social Media Platforms by Integrating Text and Structure Information - 2017 IEEE ISI"></a>Mapping Users across Social Media Platforms by Integrating Text and Structure Information - 2017 IEEE ISI</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>这篇文章的思路比较简单清晰：首先将不同社交网络获得的用户信息分为文本信息和网络结构信息。</p>
<p>文本信息又分为用户描述（word2vec embedding)、用户名（表示成单词列表）和地理位置信息（分层次划分），网络结构信息就是获得不同平台上两个用户的共同朋友，作为一个集合。对于用户描述，计算两个用户之间的余弦相似性，对于用户名和朋友关系，计算 Jaccard Index，对于地理位置，直接匹配最低层次的划分是否相同，相同则相似性为1，最后通过线性加权的方式得到整体的相似性。给整体相似性设置一个阈值，如果大于该阈值，表明这两个用户是一个人，否则，不是一个人。</p>
<p>这篇文章有很多可以改进的东西。</p>
<h2 id="Research-Objective"><a href="#Research-Objective" class="headerlink" title="Research Objective"></a>Research Objective</h2><p>提出一种 mapping method 能够整个 <strong>文本</strong> 和 <strong>结构</strong> 的信息</p>
<p>模型首先基于word2vec或字符串匹配来表示用户名、描述、位置信息，以关系网络表示的朋友关系信息作为结构信息。然后利用这些信息，利用 Jaccard index 或余弦相似度进行相似度计算。采用线性模型获取用户对的整体相似度，进行用户映射。</p>
<h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><p>文本信息和社交网络特征的融合应用。</p>
<p>关键是文本和结构信息的有效表示和相似性的计算。</p>
<p>文本信息和社交网络结构信息反映了用户的行为模式。但目前存在的方法都是基于单一信息的user mapping。</p>
<h3 id="Text-information-based-mapping-method"><a href="#Text-information-based-mapping-method" class="headerlink" title="Text information based mapping method"></a>Text information based mapping method</h3><p>利用用户的文本信息：用户名、位置、年龄、标签以及用户在社交网络中产生的content等</p>
<h3 id="Structure-information-based-mapping-method"><a href="#Structure-information-based-mapping-method" class="headerlink" title="Structure information based mapping method"></a>Structure information based mapping method</h3><p>anchor link prediction </p>
<ul>
<li>监督方法：需要知道一部分已经存在的 anchor links 作为训练集来训练模型。<ul>
<li>一些方法直接使用人工提取的特征，如度、聚类系数、三角形数和共同邻居等，这些方法没有利用网络的内部结构规律。</li>
<li>表示学习的方法</li>
<li>probability network</li>
</ul>
</li>
<li>无监督的方法：NP-hard 组合优化问题</li>
</ul>
<h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p><img src="/2019/10/06/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AMapping-Users-across-Social-Media-Platforms-by-Integrating-Text-and-Structure-Information%E3%80%8B/overview.png" alt="An overview of the research framework "></p>
<h3 id="Theoretical-Background"><a href="#Theoretical-Background" class="headerlink" title="Theoretical Background"></a>Theoretical Background</h3><ul>
<li>Subjective description：主要是用户的职业、兴趣等</li>
<li>Objective Information：真实姓名、地理位置信息等真实的信息</li>
<li>Social Relationship：通过模型的构建，将用户的社会关系和角色特征转化为结构特征。Graph algorithms 可以应用</li>
</ul>
<h3 id="Information-representation"><a href="#Information-representation" class="headerlink" title="Information representation"></a>Information representation</h3><ol>
<li><p>User description：用户描述是一小段对自己的描述，其中包括用户的爱好、职业等信息</p>
<p>应用 word2vec 模型将描述文本转为向量表示</p>
<p>通过去除stopwords和一些其他的自然语言预处理操作，获得一系列单词$(word<em>{1}, word</em>{2}, …, word<em>{k})$ 通过预训练的 n-dimension word2vec模型，可以得到每个单词的向量表示 $(wordvector</em>{1}, wordvector<em>{2}, …, wordvector</em>{k})$</p>
<p>因此在社交平台A上的用户N可以描述为：</p>
<script type="math/tex; mode=display">
D_{N}^{A}=\left\{w_{1}, w_{2}, \ldots, w_{n}\right\}=\sum_{i=1}^{k} \frac{\text {wordvector}_{i}}{k}</script></li>
<li><p>Username：将用户名转换为 word list</p>
<p>社交平台A上用户N的用户名可以表示为 </p>
<script type="math/tex; mode=display">
D_{N}^{A} = \left(word_{1}, word_{2},..., word_{j}\right)</script></li>
<li><p>Friend information</p>
<p>假定平台 A 上的用户 N 有 n 个朋友 $F^{A} = \left[f<em>{1}^{A}, f</em>{2}^{A}, \ldots, f<em>{n}^{A}\right]$, 平台B上用户 M 有 m 个朋友 $F^{B}=\left[f</em>{1}^{B}, f<em>{2}^{B}, \ldots, f</em>{m}^{B}\right]$ ，那么他们有 k 个重叠的朋友的话，表示为 $F^{o}=\left[f<em>{1}, f</em>{2}, \ldots, f_{k}\right]$</p>
</li>
<li><p>Location</p>
<p>将地理位置信息划分为不同的层次：$L<em>{N}^{A}=\left[C i t y</em>{N}, \text { State}<em>{N}, Nation</em>{N}\right]$</p>
</li>
</ol>
<h3 id="Similarity-Computation"><a href="#Similarity-Computation" class="headerlink" title="Similarity Computation"></a>Similarity Computation</h3><ol>
<li><p>User description - Cosine similarity</p>
<script type="math/tex; mode=display">
\begin{aligned} \operatorname{sim}\left(D_{N}^{A}, D_{M}^{B}\right) &=\frac{D_{N}^{A} \cdot D_{M}^{B}}{\left\|D_{N}^{A}\right\| \| D_{M}^{B}} \\ &=\frac{\sum_{i=1}^{n} D_{N i}^{A} D_{M i}^{B}}{\sqrt{\sum_{i=1}^{n} D_{N i}^{A}} \sqrt{\sum_{i=1}^{n} D_{M i}^{B_{2}^{2}}}} \end{aligned}</script></li>
<li><p>Username and Friend - Jaccard index</p>
<p>用户名：</p>
<script type="math/tex; mode=display">
J\left(U_{N}^{A}, U_{M}^{B}\right)=\frac{\left|U_{N}^{A} \cap U_{M}^{B}\right|}{\left|U_{N}^{A} \cup U_{M}^{B}\right|}</script><p>Friend：</p>
<script type="math/tex; mode=display">
J\left(F^{A}, F^{B}\right)=\frac{\left|F^{A} \cap F^{B}\right|}{\left|F^{A} \cup F^{B}\right|}=\frac{\left|F^{O}\right|}{\left|F^{A}\right|+\left|F^{B}\right|-\left|F^{O}\right|}</script></li>
<li><p>Location - Matching</p>
<p>如果最低的非空区域划分等级中是一致的，则 $Sim(L<em>{N}^{A}, L</em>{M}^{B}) = 1$, 若不匹配，则 $Sim(L<em>{N}^{A}, L</em>{M}^{B}) = 0$</p>
</li>
</ol>
<h3 id="Information-Integration"><a href="#Information-Integration" class="headerlink" title="Information Integration"></a>Information Integration</h3><script type="math/tex; mode=display">
S=\eta_{d} S_{d}+\eta_{u} S_{u}+\eta_{l} S_{l}+\eta_{f} S_{f}</script><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><blockquote>
<p>Sun S , Li Q , Yan P , et al. Mapping users across social media platforms by integrating text and structure information[C]// 2017 IEEE International Conference on Intelligence and Security Informatics (ISI). IEEE, 2017.</p>
</blockquote>
<p>数据集来自于文章《<a href="http://dx.doi.org/10.1109%2FICME.2013.6607510" target="_blank" rel="noopener">Friend transfer: Cold-start friend recommendation with cross-platform transfer learning of social knowledge</a>》目前还没找到数据。</p>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://tiantianliu2018.github.io/2019/10/03/Java-%E9%AB%98%E7%BA%A7%E7%B1%BB%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Kelly Liu">
      <meta itemprop="description" content="The Space to record knowledge and my life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kelly's Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/03/Java-%E9%AB%98%E7%BA%A7%E7%B1%BB%E7%89%B9%E6%80%A7/" class="post-title-link" itemprop="url">Java 高级类特性</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-03 09:14:31" itemprop="dateCreated datePublished" datetime="2019-10-03T09:14:31+08:00">2019-10-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-13 09:49:36" itemprop="dateModified" datetime="2020-09-13T09:49:36+08:00">2020-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E9%AB%98%E7%BA%A7%E7%B1%BB%E7%89%B9%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">高级类特性</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/10/03/Java-%E9%AB%98%E7%BA%A7%E7%B1%BB%E7%89%B9%E6%80%A7/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/03/Java-%E9%AB%98%E7%BA%A7%E7%B1%BB%E7%89%B9%E6%80%A7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.9k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java-高级类特性"><a href="#Java-高级类特性" class="headerlink" title="Java 高级类特性"></a>Java 高级类特性</h2><h2 id="面向对象特征之二：继承"><a href="#面向对象特征之二：继承" class="headerlink" title="面向对象特征之二：继承"></a>面向对象特征之二：继承</h2><p><strong>为什么要有继承？</strong></p>
<p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。</p>
<p>此处的多个类称为子类，单独的这个类称为父类（基类或超类）</p>
<p><strong>继承的语法规则</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Subclass extends Superclass&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>作用</strong></p>
<p>继承的出现提高了代码的复用性</p>
<p>继承的出现让类与类之间产生了关系，提供了多态的前提</p>
<p>不要仅为了获取其他类中某个功能而去继承</p>
<p><strong>说明</strong></p>
<p>子类继承了父类，就继承了父类的方法和属性。</p>
<p>在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。</p>
<p>在 Java 中，继承的关键字用的是 <code>extends</code>, 即子类不是父类的子集，而是对父类的扩展</p>
<p>关于继承的规则：</p>
<ul>
<li>子类不能直接访问父类中私有的（private）成员变量和方法</li>
<li>Java 只支持单继承，不允许多重继承<ul>
<li>一个子类只能有一个父类</li>
<li>一个父类可以派生出多个子类</li>
</ul>
</li>
</ul>
<hr>

<h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p>在子类中可以根据需要对从父类中继承来的方法进行改造，也称方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。子类重写父类的方法，只是重新编写方法体的代码。</p>
<p>要求：</p>
<ul>
<li><p>重写方法必须和被重写方法具有相同的方法名称、参数列表和返回值类型</p>
</li>
<li><p>重写方法不能使用比被重写方法更严格的访问权限</p>
</li>
<li><p>重写方法和被重写的方法必须同时为 <code>static</code> 的，或者同时为 <code>非static</code> 的</p>
</li>
<li><p>子类方法抛出的异常不能大于父类被重写方法的异常</p>
</li>
</ul>
<hr>

<h2 id="四种访问权限修饰符"><a href="#四种访问权限修饰符" class="headerlink" title="四种访问权限修饰符"></a>四种访问权限修饰符</h2><p>如果子类和父类在<strong>同一个包</strong>下，那么对于父类的成员修饰符只要不是私有的 <code>private</code>，子类那就可以使用</p>
<p>如果子类和父类<strong>不在同一个包</strong>中，那么子类只能使用父类中 <code>protected</code> 和 <code>public</code> 的成员变量</p>
<hr>

<h2 id="关键字-super"><a href="#关键字-super" class="headerlink" title="关键字 super"></a>关键字 super</h2><p>在 Java 类中使用 <code>super</code> 来调用父类中指定的操作：</p>
<ul>
<li><p><code>super</code> 可用于访问父类中定义的属性</p>
</li>
<li><p><code>super</code> 可用于调用父类中定义的成员方法</p>
</li>
<li><p><code>super</code> 可用于在子类构造方法中调用父类的构造器</p>
</li>
</ul>
<p><strong>注意</strong></p>
<p>尤其是当子父类出现同名成员时，可以用 <code>super</code> 进行区分</p>
<p><code>super</code> 的追溯不仅限于直接父类，使用 <code>super</code>，子类可以调用子类之上的所有父类层级</p>
<p><code>super</code> 和 <code>this</code> 的用法相像，<code>this</code> 代表本类对象的引用， <code>super</code> 代表父类的内存空间的标识</p>
<p><strong>调用父类的构造器</strong></p>
<p>子类中所有的构造器<strong>默认</strong>都会访问父类中<strong>空参数</strong>的构造器</p>
<p>当父类中没有空参数的构造器时，子类的构造器必须通过 <code>this（参数列表）</code>或者 <code>super（参数列表）</code>语句指定调用本类或者父类中相应的构造器，且必须放在构造器的第一行</p>
<p>如果子类构造器中既有显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错</p>
<p><strong>this 和 super 的区别</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">区别点</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">访问属性</td>
<td>访问本类中的属性，如果本类没有此属性则从父类中继续查找</td>
<td>访问父类中的属性</td>
</tr>
<tr>
<td style="text-align:center">调用方法</td>
<td>访问本类中的方法</td>
<td>直接访问父类中的方法</td>
</tr>
<tr>
<td style="text-align:center">调用构造器</td>
<td>调用本类构造器，必须放在构造器的首行</td>
<td>调用父类构造器，必须放在子类构造器的首行</td>
</tr>
<tr>
<td style="text-align:center">特殊</td>
<td>表示当前对象</td>
<td>无此概念</td>
</tr>
</tbody>
</table>
</div>
<hr>

<h2 id="子类对象实例化过程"><a href="#子类对象实例化过程" class="headerlink" title="子类对象实例化过程"></a>子类对象实例化过程</h2><p><strong>简单类对象的实例化过程</strong></p>
<ol>
<li>在方法区加载 <code>Person.class</code></li>
<li>在栈中申请空间，声明变量 <code>p</code></li>
<li>在堆内存中开辟空间，分配地址，假设地址是 <code>BE2500</code></li>
<li>在对象空间中（堆内存），对对象中的属性进行默认初始化，若对成员变量有赋值，则对成员变量显式初始化</li>
<li>构造函数方法进栈，进行初始化（栈内存）</li>
<li>初始化完毕后，将堆内存中的地址值赋给引用变量 <code>p = BE2500</code>，构造方法出栈</li>
</ol>
<p><strong>子类对象的实例化过程</strong></p>
<ol>
<li>在方法区先加载 <code>Person.class</code>, 再加载 <code>Student.class</code></li>
<li>在栈中申请空间，声明变量 <code>stu</code></li>
<li>在堆内存中开辟空间，分配地址</li>
<li>并在对象空间中，对对象中的属性（包括父类的属性）进行默认初始化</li>
<li>子类构造方法进栈</li>
<li>显式初始化父类的属性（堆内存）</li>
<li>父类构造方法进栈，执行完毕出栈</li>
<li>显式初始化子类的属性（堆内存）</li>
<li>初始化完毕后，将堆内存中的地址值赋给引用变量 <code>stu</code>. 子类构造方法出栈</li>
</ol>
<hr>

<h2 id="面向对象特征之三：多态"><a href="#面向对象特征之三：多态" class="headerlink" title="面向对象特征之三：多态"></a>面向对象特征之三：多态</h2><p>多态性，是面向对象最重要的概念，在Java中有两种体现：</p>
<ol>
<li>方法的重载（overload）和重写（overwrite）</li>
<li><strong>对象的多态性</strong>——可以直接应用在抽象类和接口上</li>
</ol>
<p>Java 引用变量有两个类型：<strong>编译时类型</strong>和<strong>运行时类型</strong>。</p>
<p>编译时类型由声明该变量时使用的类型决定，</p>
<p>运行时类型由实际赋给该变量的对象决定。</p>
<p>若编译时类型和运行时类型不一致，就出现多态（Polymorphism）——对象的多态</p>
<p><strong>对象的多态</strong> —— 在Java中，子类的对象可以代替父类的对象使用</p>
<ul>
<li>一个变量只能有一种确定的数据类型</li>
<li>一个引用类型变量可能指向（引用）多种不同类型的对象</li>
</ul>
<p>子类可以看做是特殊的父类，所以父类类型的引用可以指向子类的对象：<strong>向上转型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person e = <span class="keyword">new</span> Student();  <span class="comment">// 子类的对象可以赋值给父类类型的变量引用</span></span><br></pre></td></tr></table></figure>
<p>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student m = <span class="keyword">new</span> Student();</span><br><span class="line">m.school = <span class="string">"pku"</span>; <span class="comment">// 合法， Student类中有school成员变量</span></span><br><span class="line">Person e = <span class="keyword">new</span> Student();</span><br><span class="line">e.school = <span class="string">"pku"</span>; <span class="comment">// 非法，Person类没有school成员变量</span></span><br></pre></td></tr></table></figure>
<p>属性是在编译时确定的，编译时 <code>e</code> 为 <code>Person</code> 类型，没有 <code>school</code> 成员变量，因而编译出错。</p>
<p><strong>虚拟方法调用</strong></p>
<p>正常的方法调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">p.getInfo();</span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">s.getInfo();</span><br></pre></td></tr></table></figure>
<p>虚拟方法调用（多态情况下）</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person e = <span class="keyword">new</span> <span class="constructor">Student()</span>;</span><br><span class="line">e.get<span class="constructor">Info()</span>;  <span class="comment">// 调用 Student 类的 getInfo() 方法</span></span><br></pre></td></tr></table></figure>
<p>编译时类型和运行时类型：</p>
<p>编译时 <code>e</code>为 <code>Person</code> 类，而方法的调用是在运行时确定的，所以调用的是 <code>Student</code>类的 <code>getInfo()</code> 方法 —— 动态绑定</p>
<p><strong>多态小结：</strong></p>
<ul>
<li><p>前提</p>
<p>需要存在继承或者实现关系</p>
<p>要有覆盖操作</p>
</li>
<li><p>成员方法：</p>
<ul>
<li>编译时，要查看引用变量所属的类中是否有所调用的方法</li>
<li>运行时，要调用实际对象所属类中的重写方法</li>
</ul>
</li>
<li><p>成员变量</p>
<p>不具备多态性，只看引用变量所属的类</p>
</li>
</ul>
<h4 id="instance-of-操作符"><a href="#instance-of-操作符" class="headerlink" title="instance of 操作符"></a>instance of 操作符</h4><p><code>x instance of A</code>: 检验 <code>x</code> 是否是类 A 的对象，返回值为 <code>boolean</code> 型</p>
<p>要求 x 所属的类与类 A 必须是子类和父类的关系，否则编译出错</p>
<p>如果 x 属于类 A 的子类 B ，<code>x instance of A</code> 值也为 <code>true</code></p>
<hr>

<h2 id="Object类，包装类"><a href="#Object类，包装类" class="headerlink" title="Object类，包装类"></a>Object类，包装类</h2><h4 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h4><p>Object 类是所有Java类的根父类 —— 基类</p>
<p>object类中的主要方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Object</span><span class="params">()</span>   <span class="comment">//构造方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>	<span class="comment">//普通方法，对象比较(引用对象)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>		<span class="comment">// 获取Hash码</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>    <span class="comment">// 对象打印时调用</span></span></span><br></pre></td></tr></table></figure>
<h4 id="对象类型转换"><a href="#对象类型转换" class="headerlink" title="对象类型转换"></a>对象类型转换</h4><p>基本数据类型转换的 Casting</p>
<ul>
<li><p>自动类型转换：小的数据类型可以自动转换成大的数据类型</p>
<p><code>long g = 20;</code>       <code>double d = 12.0f</code></p>
</li>
<li><p>强制类型转换：可以把大的数据类型转换成小的数据类型</p>
<p><code>float f = (float)12.0;</code>       <code>int a = (int) 1200L</code></p>
</li>
</ul>
<p>对Java对象的强制类型转换称为<strong>造型</strong></p>
<ul>
<li>从子类到父类的类型转换可以自动进行</li>
<li>从父类到子类的类型转换必须通过造型（强制类型转换）实现</li>
<li>无继承关系的引用类型间的转换是非法的</li>
</ul>
<h4 id="操作符与-equals-方法"><a href="#操作符与-equals-方法" class="headerlink" title="== 操作符与 equals 方法"></a><code>==</code> 操作符与 <code>equals</code> 方法</h4><ul>
<li><p><code>==</code></p>
<ul>
<li><p>基本类型比较值：只要两个变量的值相等，即为 true</p>
<p><code>int a = 5;</code>  <code>if(a==6){...};</code></p>
</li>
<li><p>引用类型比较引用（是否指向同一个对象）：只有指向同一个对象时，<code>==</code> 才返回true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">if</span>(p1 == p2)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>用 <code>==</code> 进行比较时，符号两边的数据类型必须兼容（可自动转换的基本数据类型除外），否则编译出错</p>
</li>
</ul>
</li>
<li><p><code>equals</code> 所有类都继承了 Object，也就获得了 <code>equals()</code> 方法。还可以重写。</p>
<ul>
<li>只能比较引用类型，其作用与 <code>==</code> 相同，比较是否指向同一个对象。<ul>
<li>格式：<code>obj1.equals(obj2)</code></li>
</ul>
</li>
<li>特例：当用 <code>equals()</code> 方法进行比较时，对类 File、String、Date 及包装类（Wrapper）来说，是比较类型及内容而不考虑引用的是否是同一个对象<ul>
<li>原因：在职这些类中重写了 Object 类的  <code>equals()</code>  方法</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<p>对于对象来说，特殊的类，如 String、File、Date使用 <code>==</code> 比较的是对象（对象的地址）， <code>equals</code> 比较的是内容</p>
<p>除了特殊类之外的其他其他普通对象， <code>==</code> 和 <code>equals</code> 比较的都是对象（对象的内存地址）</p>
</li>
</ul>
<h4 id="String-对象的创建"><a href="#String-对象的创建" class="headerlink" title="String 对象的创建"></a>String 对象的创建</h4><ul>
<li><p>字面量创建 String 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;	<span class="comment">// 堆内存的常量池中添加“abc”对象，返回引用地址给s1对象</span></span><br><span class="line">String s2 = <span class="string">"abc"</span>;	<span class="comment">// 通过 equals() 方法判断常量池中是否存在值为“abc”的对象，返回相同的引用</span></span><br><span class="line">System.out.println(s1==s2); <span class="comment">// true, s1==s2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>new 创建 String 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"def"</span>);  <span class="comment">// 在常量池中添加“def”对象，在堆中创建值为“def"的对象s3,返回指向堆中s3的引用</span></span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">"def"</span>);  <span class="comment">// 常量池中已有“def”对象，不做处理，在堆中创建值为“def”的对象s4，返回指向堆中s4的引用</span></span><br><span class="line"><span class="comment">// 因此 s3 和 s4 指向的不是一个对象</span></span><br></pre></td></tr></table></figure>
<p>字面量创建对象的时候，只在常量池创建一个对象。</p>
<p>使用 <code>new</code> 创建对象，常量池有对象，堆中也要有对象，字面量方法要比<code>new</code>方法省内存</p>
</li>
<li><p>字面量相加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s5 = <span class="string">"x"</span>+<span class="string">"y"</span>;  <span class="comment">// 经过JVM的优化，直接在常量池中添加“xy”对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>new</code>的方式字符串叠加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s6 = <span class="keyword">new</span> String(<span class="string">"1"</span>)+<span class="keyword">new</span> String(<span class="string">"1"</span>)+<span class="keyword">new</span> String(<span class="string">"2"</span>);  <span class="comment">// 通过StringBuilder实现，在常量池中添加“1”和“2”两个对象，在堆中创建值为“112”的对象，把引用地址给s6</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="包装类（Wrapper）"><a href="#包装类（Wrapper）" class="headerlink" title="包装类（Wrapper）"></a>包装类（Wrapper）</h4><p>针对八种基本类型定义相应的引用类型——包装类（封装类）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">基本数据类型</th>
<th style="text-align:center">包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">Boolean</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">Byte</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">Short</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">Integer</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">Long</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">Character</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">Float</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">Double</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>基本数据类型包装成包装类的实例——装箱</p>
<p>通过包装类的构造器实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">500</span>;</span><br><span class="line">Interger t = <span class="keyword">new</span> Integer(i);</span><br></pre></td></tr></table></figure>
<p>还可以通过字符串参数构造包装类对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Float f = <span class="keyword">new</span> <span class="keyword">float</span>(<span class="string">"4.56"</span>);</span><br><span class="line">Long l = <span class="keyword">new</span> Long(<span class="string">"asdf"</span>);  <span class="comment">// NumberFormatException</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获得包装类对象中包装的基本数据类型变量——拆箱</p>
<p>调用包装类的<code>.xxxValue()</code> 方法：</p>
<p><code>boolean b = bObj.booleanValue();</code></p>
</li>
</ul>
<p>JDK1.5后支持自动装箱和拆箱：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer l1 = <span class="number">112</span>;  <span class="comment">// 自动装箱</span></span><br><span class="line"><span class="keyword">int</span> l2 = l1; 	<span class="comment">// 自动拆箱</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>字符串转换成基本数据类型</p>
<ul>
<li><p>通过包装类的构造器实现：</p>
<p><code>int i = new Integer(&quot;12&quot;);</code></p>
</li>
<li><p>通过包装类的<code>parseXxx(String s)</code> 静态方法：</p>
<p><code>Float f = Float.parseFloat(&quot;12.1&quot;);</code></p>
</li>
</ul>
</li>
<li><p>基本数据类型转换成字符串</p>
<ul>
<li><p>调用字符串重载的<code>valueOf()</code> 方法</p>
<p><code>String fstr = String.valueOf(2.34f);</code></p>
</li>
<li><p>更直接的方式</p>
<p><code>String intStr = 5 + &quot;&quot;</code></p>
</li>
</ul>
</li>
</ul>
<p><strong>包装类的作用</strong></p>
<p>基本数据类型的包装类实现了基本数据类型与字符串直接转化</p>
<p>包装类使得一个基本数据类型的数据变成了类。有了类的特点，可以调用类中的方法。</p>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://tiantianliu2018.github.io/2019/10/03/JavaBean/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Kelly Liu">
      <meta itemprop="description" content="The Space to record knowledge and my life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kelly's Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/03/JavaBean/" class="post-title-link" itemprop="url">JavaBean</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-03 09:03:12" itemprop="dateCreated datePublished" datetime="2019-10-03T09:03:12+08:00">2019-10-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-13 09:49:51" itemprop="dateModified" datetime="2020-09-13T09:49:51+08:00">2020-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/10/03/JavaBean/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/03/JavaBean/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>103</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h1><p>JavaBean 是一种 Java 语言写成的可重用组件。</p>
<p>所谓JavaBean，是指符合如下标准的Java类：</p>
<ul>
<li><p>类是公共的</p>
</li>
<li><p>有一个无参的公共构造器</p>
</li>
<li><p>有属性，属性一般是私有的，且有对应的get、set方法</p>
</li>
</ul>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://tiantianliu2018.github.io/2019/10/02/Java-this%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="Kelly Liu">
      <meta itemprop="description" content="The Space to record knowledge and my life.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kelly's Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/02/Java-this%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-title-link" itemprop="url">Java this关键字</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-02 11:09:23" itemprop="dateCreated datePublished" datetime="2019-10-02T11:09:23+08:00">2019-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-13 09:47:32" itemprop="dateModified" datetime="2020-09-13T09:47:32+08:00">2020-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/this%E5%85%B3%E9%94%AE%E5%AD%97/" itemprop="url" rel="index"><span itemprop="name">this关键字</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/10/02/Java-this%E5%85%B3%E9%94%AE%E5%AD%97/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/02/Java-this%E5%85%B3%E9%94%AE%E5%AD%97/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>878</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-关键字——this"><a href="#Java-关键字——this" class="headerlink" title="Java 关键字——this"></a>Java 关键字——this</h1><p>this 在方法内部使用，即这个方法所属对象的引用</p>
<p>它在构造器内部使用，表示该构造器正在初始化的对象</p>
<p>this 表示当前对象，可以调用类的属性、方法和构造器</p>
<p><strong>什么时候使用？</strong></p>
<p>当在方法内先需要用到调用该方法的对象时，就用 this</p>
<p>使用this，调用属性、方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;  <span class="comment">// 创建Person类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        <span class="keyword">this</span>.speak();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"年龄："</span> + <span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用this调用本类的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;  <span class="comment">// 创建Person类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;  <span class="comment">// 无参构造方法</span></span><br><span class="line">        System.out.println(<span class="string">"新对象实例化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123; </span><br><span class="line">        <span class="keyword">this</span>();		<span class="comment">// 调用本类中的无参构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123; </span><br><span class="line">        <span class="keyword">this</span>(name);	<span class="comment">// 调用本类只有一个参数的构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"姓名："</span> + name + <span class="string">"年龄："</span> + age; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>使用 this 必须放在构造器的首行</p>
<p>使用 this 调用本类中其他的构造器，保证至少有一个构造器是不用this的。</p>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Kelly Liu"
      src="/uploads/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Kelly Liu</p>
  <div class="site-description" itemprop="description">The Space to record knowledge and my life.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/tiantianliu2018" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tiantianliu2018" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:tiantianliu2018@outlook.com" title="E-Mail → mailto:tiantianliu2018@outlook.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tiantian liu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">143k</span>
</div>

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共65k字</span>
  <span class="post-meta-divider">|</span>
  本站总访问量<span id="busuanzi_value_site_pv"></span>次
  <span class="post-meta-divider">|</span>
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
  <span class="post-meta-divider">|</span>
  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共65k字</span>
</div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'FhWVmso5TyqrTqtDNNtpuBeC-gzGzoHsz',
      appKey     : 'd5yz5CVcPPfEmfA5p2ovH6g9',
      placeholder: "欢迎交流讨论...",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
