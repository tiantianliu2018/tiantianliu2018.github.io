<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pytorch 机器学习</title>
    <link href="/2020/10/06/pytorch-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/10/06/pytorch-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="用-pytorch-机器学习"><a href="#用-pytorch-机器学习" class="headerlink" title="用 pytorch 机器学习"></a>用 pytorch 机器学习</h1><h2 id="Pytorch-基础语法"><a href="#Pytorch-基础语法" class="headerlink" title="Pytorch 基础语法"></a>Pytorch 基础语法</h2><h3 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h3><p><code>torch.Tensor</code> - 一个多维数组，支持诸如<code>backward()</code>等的自动求导操作，同时也保存了张量的梯度。</p><a id="more"></a><h3 id="pytorch-autograd-自动求导"><a href="#pytorch-autograd-自动求导" class="headerlink" title="pytorch autograd 自动求导"></a>pytorch autograd 自动求导</h3><p><code>autograd.Function</code> - 实现了自动求导前向和反向传播的定义，每个<code>Tensor</code>至少创建一个<code>Function</code>节点，该节点连接到创建<code>Tensor</code>的函数并对其历史进行编码。</p><h3 id="torch-nn-构建神经网络"><a href="#torch-nn-构建神经网络" class="headerlink" title="torch.nn 构建神经网络"></a>torch.nn 构建神经网络</h3><p>一个<code>nn.Module</code>包含各个层和一个<code>forward(input)</code>方法，该方法返回<code>output</code></p><h2 id="Pytorch-深度学习框架"><a href="#Pytorch-深度学习框架" class="headerlink" title="Pytorch 深度学习框架"></a>Pytorch 深度学习框架</h2><h3 id="1-定义网络"><a href="#1-定义网络" class="headerlink" title="1. 定义网络"></a>1. 定义网络</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Net</span><span class="hljs-params">(nn.Module)</span>:</span>    <span class="hljs-string">"""    初始化函数，接收自定义输入特征维数，隐层特征维数，输出层特征维数    """</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n_features, n_hidden, n_output)</span>:</span>        super(Net, self).__init__()        self.hidden = torch.nn.Linear(n_features, n_hidden)        self.predict = torch.nn.Linear(n_hidden, n_output)        <span class="hljs-string">"""    前向传播    """</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, x)</span>:</span>        x = torch.sigmoid(self.hidden(x))        x = self.predict(x)        out = F.log_softmax(x, dim=<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> out</code></pre><h3 id="2-实例化网络"><a href="#2-实例化网络" class="headerlink" title="2. 实例化网络"></a>2. 实例化网络</h3><pre><code class="hljs python">net = Net(n_features=<span class="hljs-number">4</span>, n_hidden=<span class="hljs-number">5</span>, n_output=<span class="hljs-number">4</span>)print(net)</code></pre><h3 id="3-训练"><a href="#3-训练" class="headerlink" title="3. 训练"></a>3. 训练</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.optim <span class="hljs-keyword">import</span> SGD<span class="hljs-comment">## 定义优化器</span>optimizer = SGD(net.parameters(), lr=<span class="hljs-number">0.5</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>):     <span class="hljs-comment"># 清零梯度缓存</span>    optimizer.zero_grad()       <span class="hljs-comment">## 计算模型结果</span>    prediction = net(x)    <span class="hljs-comment"># 计算 loss</span>    loss = F.nll_loss(prediction, y)     <span class="hljs-comment">#loss 反向传播</span>    loss.backward()    <span class="hljs-comment"># 更新参数</span>    optimizer.step()</code></pre>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列</title>
    <link href="/2020/09/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2020/09/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>实习过程中用到了 kafka 作为消息队列，但是对于 kafka 的了解并不是特别多，特别学习部分内容作为记录。</p><h2 id="消息队列的优缺点"><a href="#消息队列的优缺点" class="headerlink" title="消息队列的优缺点"></a>消息队列的优缺点</h2><p>优点：解耦，异步，削峰</p><p>缺点：系统可用性降低，系统复杂度提高（消息重复消费、消息丢失、消息传递的顺序性），一致性问题</p><a id="more"></a><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>Apache Kafka是由 Apache 开发的一种<strong>发布订阅消息系统</strong>，它是一个<strong>分布式的、分区的和可复制的</strong>提交日志服务。</p><p><strong>应用</strong>：</p><ul><li>消息队列</li><li>数据处理：构建实时流处理程序来转换或处理数据流</li></ul><h3 id="2-Kafka-消息模型"><a href="#2-Kafka-消息模型" class="headerlink" title="2. Kafka 消息模型"></a>2. Kafka 消息模型</h3><p>发布订阅消息模型</p><p><img src="/2020/09/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/artitec.png" srcset="/img/loading.gif" alt="kafka 架构模型"></p><p><strong>Producer：消息发送者</strong>。负责将消息发送到 Kafka 集群的某一个 topic 中。</p><p><strong>Consumer：消息消费者</strong>。订阅 topic，获取消息。</p><p><strong>Broker：Kafka 集群中的每一台服务器</strong>。Kafka 是一个分布式集群，其中每一台服务器都叫做 Broker。</p><p><strong>Topic</strong>：属于特定类别的消息流称为主题。可以理解为消息的标签🏷，订阅了该 topic 的消费者会接收到所有该类消息。</p><p><strong>Partition</strong>：分区，属于 Topic 的一部分，一个 Topic 可以有多个 Partition，同一 Topic 下的 Partition 可以分布在不同的 Broker 上。</p><h3 id="3-Kafka-工作流程及文件存储机制"><a href="#3-Kafka-工作流程及文件存储机制" class="headerlink" title="3. Kafka 工作流程及文件存储机制"></a>3. Kafka 工作流程及文件存储机制</h3><h4 id="kafka-工作流程"><a href="#kafka-工作流程" class="headerlink" title="kafka 工作流程"></a>kafka 工作流程</h4><p><img src="/2020/09/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/produce.png" srcset="/img/loading.gif" alt="工作流程"></p><p>Kafka 中消息是以 topic 进行分类的，生产者生产消息，消费者消费消息，都是面向 topic 的。<br>topic 是逻辑上的概念，而 partition 是物理上的概念，每个 partition 对应于一个 log 文件，该 log 文件中存储的就是 producer 生产的数据。Producer 生产的数据会被不断追加到该 log 文件末端，且每条数据都有自己的 <strong>offset</strong>。消费者组中的每个消费者，都会实时记录自己消费到了哪个 offset，以便出错恢复时，从上次的位置继续消费。</p><h4 id="Kafka-文件存储机制"><a href="#Kafka-文件存储机制" class="headerlink" title="Kafka 文件存储机制"></a>Kafka 文件存储机制</h4><p><img src="/2020/09/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/file.png" srcset="/img/loading.gif" alt="file"></p><p>生产者生产的消息会不断追加到 log 文件末尾，为防止 log 文件过大导致数据定位效率低下，Kafka 采取了分片和索引机制，将每个 partition 分为多个 segment。每个 segment 对应两个文件——“.index” 文件和 “.log” 文件。这些文件位于一个文件夹下，该文件夹的命名规则为：topic名称 + 分区序号。例如，这个 topic 有三个分区，则其对应的文件夹为 topic-0, topic-1, topic-2。</p><p> index 和 log 文件以当前 segment 的第一条消息的 offset 命名。下图为 index 文件和 log 文件的结构示意图。</p><p><img src="/2020/09/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/index文件和log文件的结构示意图.jpg" srcset="/img/loading.gif" alt="index文件和log文件的结构示意图"></p><p><strong>“.index” 文件存储大量的索引信息，“.log”文件存储大量的数据</strong>，索引文件中的元数据指向对应数据文件中 message 的物理偏移地址。</p><h3 id="4-Kafka-消息可靠传递"><a href="#4-Kafka-消息可靠传递" class="headerlink" title="4. Kafka 消息可靠传递"></a>4. Kafka 消息可靠传递</h3><h4 id="4-1-Kafka-顺序消费"><a href="#4-1-Kafka-顺序消费" class="headerlink" title="4.1 Kafka 顺序消费"></a>4.1 Kafka 顺序消费</h4><p>Kafaka 能够保证<strong>一个 Partition 中的消息有序</strong>（消息被追加到 Partition 的时候，会有一个特定的偏移量 offset，Kafaka 通过偏移量保证消息在分区内的顺序性）。一个 Topic 对应多个 Partition，<strong>Kafaka 不能保证多个 Partition 有序。</strong></p><p><strong>解决方法</strong>：</p><ol><li>一个 Topic 对应一个 Partition</li><li>发送消息的时候，指定 key/partition，让同一个 key 的消息发送到同一个 partition</li></ol><h4 id="4-2-Kafka-如何保证消息不丢失"><a href="#4-2-Kafka-如何保证消息不丢失" class="headerlink" title="4.2 Kafka 如何保证消息不丢失"></a>4.2 Kafka 如何保证消息不丢失</h4><h5 id="消费端丢失数据"><a href="#消费端丢失数据" class="headerlink" title="消费端丢失数据"></a>消费端丢失数据</h5><p>在 consumer 消费阶段，对 offset 的处理，关系到是否丢失数据。<strong>如果在消息处理完成前就提交了offset，那么就有可能造成数据的丢失。</strong></p><p>Kafka 会自动提交 offset，那么只要<strong>关闭自动提交</strong> offset，<code>enable.auto.commit=false</code>，在处理完之后自己手动提交 offset，就可以保证数据不会丢。</p><h5 id="Kafka-丢失数据"><a href="#Kafka-丢失数据" class="headerlink" title="Kafka 丢失数据"></a>Kafka 丢失数据</h5><p>Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。若此时其他的 follower 还有数据没有进行同步，此时 leader 挂了，选举某个 follower 成 leader 之后，就会丢失一些数据。</p><p>所以此时一般是要求起码设置如下 4 个参数：</p><ul><li>给 topic 设置 <code>replication.factor</code> 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li><li>在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower。</li><li>在 producer 端设置 <code>acks=all</code> ：这个是要求每条数据，必须是<strong>写入所有 replica 之后，才能认为是写成功了</strong>。</li><li>在 producer 端设置 <code>retries=MAX</code> （很大很大很大的一个值，无限次重试的意思）：这个是<strong>要求一旦写入失败，就无限重试</strong>，卡在这里了。</li></ul><p>这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。</p><h5 id="生产者丢失数据"><a href="#生产者丢失数据" class="headerlink" title="生产者丢失数据"></a>生产者丢失数据</h5><p>若设置好了 kafka，<code>acks=all</code> ，一定不会丢。此时要求 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p><h4 id="4-3-Kafka-如何保证不重复消费？"><a href="#4-3-Kafka-如何保证不重复消费？" class="headerlink" title="4.3 Kafka 如何保证不重复消费？"></a>4.3 Kafka 如何保证不重复消费？</h4><p>Kafka 每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，<strong>每隔一段时间</strong>（定时定期），会把自己消费过的消息的 offset 提交一下，表示已经消费过了，下次要重启，继续从上次消费到的 offset 来继续消费。</p><p>但是当直接 kill 进程，再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset。等重启之后，少数消息就会再次消费一次。</p><p><strong>保证消息队列消费的幂等性</strong>：</p><p>结合业务，消息可以使用唯一 id 标识。</p><ol><li>落表（主键或者唯一索引的方式，避免重复数据）</li><li>业务逻辑处理（选择唯一主键存储到 Redis 中，先查询是否存在，若存在则不处理；若不存在，先插入 Redis, 再进行业务逻辑处理）</li></ol><h3 id="5-kafka-的高可靠性实现"><a href="#5-kafka-的高可靠性实现" class="headerlink" title="5. kafka 的高可靠性实现"></a>5. kafka 的高可靠性实现</h3><p>Kafka 0.8 以后，提供了 HA 机制，就是 replica（复制品） 副本机制。每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。另外，Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。</p><p><strong>Kafka 的分区多副本架构是 Kafka 可靠性保证的核心，把消息写入多个副本可以使 Kafka 在发生崩溃时仍能保证消息的持久性</strong></p><p><strong>写数据</strong>的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。</p><p><strong>消费</strong>的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</p><h2 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-比较"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-比较" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 比较"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 比较</h2><div class="table-container"><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>经过参数优化配置，可以做到 0 丢失</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table></div><blockquote><p>参考：</p><p><a href="https://github.com/doocs/advanced-java" target="_blank" rel="noopener">https://github.com/doocs/advanced-java</a></p><p><a href="https://github.com/Dr11ft/BigDataGuide" target="_blank" rel="noopener">https://github.com/Dr11ft/BigDataGuide</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DQL Review</title>
    <link href="/2020/07/05/DQL-Review/"/>
    <url>/2020/07/05/DQL-Review/</url>
    
    <content type="html"><![CDATA[<h1 id="DQL-Review"><a href="#DQL-Review" class="headerlink" title="DQL Review"></a>DQL Review</h1><hr><p>数据库是大二的时候学的，后来很少用过了，一般也是一些简单的 select，最近看到一些 SQL 的应用，写篇笔记回顾一下。</p><p>数据库查询语言</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>&#123;* | &lt;字段列名&gt;&#125;    <span class="hljs-comment">-- 要查询字段的名称</span>[<span class="hljs-keyword">FROM</span> &lt;表 <span class="hljs-number">1</span>&gt;, &lt;表 <span class="hljs-number">2</span>&gt;…    <span class="hljs-comment">-- 要查询的数据来源</span>[<span class="hljs-keyword">WHERE</span> &lt;表达式&gt; <span class="hljs-comment">-- 查询要满足的条件</span>[<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> &lt;<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> definition&gt;  <span class="hljs-comment">-- 按照指定的字段分组</span>[<span class="hljs-keyword">HAVING</span> &lt;expression&gt; [&#123;&lt;<span class="hljs-keyword">operator</span>&gt; &lt;expression&gt;&#125;…]][<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> &lt;<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> definition&gt;]<span class="hljs-comment">-- 根据某个字段排序，有 ASC 和 DESC</span>[<span class="hljs-keyword">LIMIT</span>[&lt;<span class="hljs-keyword">offset</span>&gt;,] &lt;<span class="hljs-keyword">row</span> <span class="hljs-keyword">count</span>&gt;] <span class="hljs-comment">-- 查询出来的数据条数</span>]</code></pre><a id="more"></a><h3 id="查询表中的字段"><a href="#查询表中的字段" class="headerlink" title="查询表中的字段"></a>查询表中的字段</h3><ul><li><code>*</code> 通配符查询，查询所有字段，按照数据表中字段的顺序进行排列，不能改变字段的排列顺序。</li><li>指定要查询的字段名称</li></ul><p><strong>注意</strong>：由于索引的存在，为了走索引加快查询速度，尽量指明要查询的字段，而不是使用通配符</p><h3 id="使用-DISTINCT-过滤重复数据"><a href="#使用-DISTINCT-过滤重复数据" class="headerlink" title="使用 DISTINCT 过滤重复数据"></a>使用 DISTINCT 过滤重复数据</h3><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span>&lt;字段名&gt; <span class="hljs-keyword">FROM</span> &lt;表名&gt;;</code></pre><p><strong>注意</strong>：</p><ul><li><code>DISTINCT</code> 关键字只能在 <code>SELECT</code> 语句中使用</li><li>如果 <code>DISTINCT</code> 关键字后有多个字段，则会对多个字段进行组合去重</li></ul><p>使用 <code>DISTINCT</code> 关键字返回不重复字段的条数</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span>&lt;字段&gt;) <span class="hljs-keyword">FROM</span> &lt;表名&gt;;</code></pre><h3 id="使用-LIMIT-限制查询结果的条数"><a href="#使用-LIMIT-限制查询结果的条数" class="headerlink" title="使用 LIMIT 限制查询结果的条数"></a>使用 LIMIT 限制查询结果的条数</h3><p><code>LIMIT</code> 关键字有 3 种使用方式，即指定初始位置、不指定初始位置以及与 OFFSET 组合使用。</p><ul><li><p>指定初始位置</p><pre><code class="hljs sql">LIMIT 初始位置，记录数；</code></pre></li><li><p>不指定初始位置</p><pre><code class="hljs sql">LIMIT 记录数；</code></pre><p>记录从第一条记录开始显示。显示记录的条数由 <code>LIMIT</code> 关键字指定。</p></li><li><p><code>LIMIT</code> 和 <code>OFFSET</code> 组合使用</p><pre><code class="hljs sql">LIMIT 记录数 OFFSET 初始位置；</code></pre></li></ul><h3 id="使用-ODER-BY-排序"><a href="#使用-ODER-BY-排序" class="headerlink" title="使用 ODER BY 排序"></a>使用 ODER BY 排序</h3><pre><code class="hljs sql">-- ASC 升序，默认-- DESC 降序ORDER BY &lt;字段名&gt;[ASC|DESC];</code></pre><p>注意：</p><ul><li><code>ORDER BY</code> 关键字后可以跟子查询</li><li>当排序的字段中存在空值时，<code>ORDER BY</code> 会将该空值作为最小值来对待</li><li><code>ORDER BY</code> 指定多个字段进行排序时，MySQL 会按照字段的顺序从左到右依次进行排序</li></ul><h3 id="使用-WHERE-条件查询"><a href="#使用-WHERE-条件查询" class="headerlink" title="使用 WHERE 条件查询"></a>使用 WHERE 条件查询</h3><pre><code class="hljs sql">WHERE 查询条件;</code></pre><p>查询条件：</p><ul><li>带比较运算符和逻辑运算符的查询条件</li><li>带 <code>BETWEEN AND</code> 关键字的查询条件</li><li>带 <code>IS NULL</code> 关键字的查询条件</li><li>带 <code>IN</code> 关键字的查询条件</li><li>带 <code>LIKE</code> 关键字的查询条件</li></ul><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><pre><code class="hljs sql">[NOT] LIKE '字符串'；</code></pre><p>支持 <code>%</code> ：代表任何长度的字符串，字符串的长度可以为 0</p><p>“<code>_</code>”：只能代表单个字符，字符的长度不能为 0</p><p>注意：</p><ul><li>如果查询内容中包含通配符，可以使用<code>“\”</code>转义符</li><li><code>“%”</code>通配符可以到匹配任意字符，但是不能匹配 NULL</li></ul><h3 id="BETWEEN-AND-范围查询"><a href="#BETWEEN-AND-范围查询" class="headerlink" title="BETWEEN AND 范围查询"></a>BETWEEN AND 范围查询</h3><pre><code class="hljs sql">[NOT] BETWEEN 取值 1 AND 取值 2;</code></pre><p><code>BETWEEN AND</code> 能匹配指定范围内的所有值，包括<strong>起始值</strong>和<strong>终止值</strong></p><h3 id="空值查询"><a href="#空值查询" class="headerlink" title="空值查询"></a>空值查询</h3><p><code>IS NULL</code> 关键字，用来判断字段的值是否为空值（NULL）。空值不同于 0，也不同于空字符串。</p><pre><code class="hljs sql">IS [NOT] NULL</code></pre><p>如果字段的值是空值，则满足查询条件，该记录将被查询出来。</p><h3 id="GROUP-BY-分组查询"><a href="#GROUP-BY-分组查询" class="headerlink" title="GROUP BY 分组查询"></a>GROUP BY 分组查询</h3><pre><code class="hljs sql">GROUP BY &lt;字段名&gt;;</code></pre><p>查询结果会只显示每个分组的第一条记录</p><p><code>GROUP BY</code> 关键字可以和 <code>GROUP_CONCAT()</code> 函数一起使用。<code>GROUP_CONCAT()</code> 函数会把每个分组的字段值都显示出来。</p><p>在数据统计时，<code>GROUP BY</code> 关键字经常和聚合函数一起使用。<code>COUNT()</code> 用来统计记录的条数；<code>SUM()</code> 用来计算字段值的总和；<code>AVG()</code> 用来计算字段值的平均值；<code>MAX()</code> 用来查询字段的最大值；<code>MIN()</code> 用来查询字段的最小值。</p><p><code>WITH POLLUP</code> 关键字用来在所有记录的最后加上一条记录，这条记录是上面所有记录的总和，即统计记录数量。</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> &lt;字段 <span class="hljs-number">1</span>&gt;,<span class="hljs-keyword">GROUP_CONCAT</span>(&lt;字段 <span class="hljs-number">2</span>&gt;) <span class="hljs-keyword">FROM</span> &lt;表名&gt; <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> &lt;字段 <span class="hljs-number">1</span>&gt; <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span>;</code></pre><h3 id="HAVING-过滤分组"><a href="#HAVING-过滤分组" class="headerlink" title="HAVING 过滤分组"></a>HAVING 过滤分组</h3><pre><code class="hljs sql">HAVING &lt;查询条件&gt;;</code></pre><p>对分组后的数据进行过滤</p><blockquote><p><code>WHERE</code> 和 <code>HAVING</code> 关键字的区别：</p><p><code>WHERE</code> 用于过滤数据行，而 <code>HAVING</code> 用于过滤分组</p><ul><li><code>WHERE</code> 查询条件中不可以使用聚合函数，而 <code>HAVING</code> 查询条件中可以使用聚合函数。</li><li><code>WHERE</code> 在数据分组前进行过滤，而 <code>HAVING</code> 在数据分组后进行过滤 。</li><li><code>WHERE</code> 针对数据库文件进行过滤，而 <code>HAVING</code> 针对查询结果进行过滤。也就是说，<code>WHERE</code> 根据数据表中的字段直接进行过滤，而 <code>HAVING</code> 是根据前面已经查询出的字段进行过滤。</li><li><code>WHERE</code> 查询条件中不可以使用字段别名，而 <code>HAVING</code> 查询条件中可以使用字段别名。</li></ul></blockquote><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="COSS-JOIN-交叉连接-—-笛卡尔积"><a href="#COSS-JOIN-交叉连接-—-笛卡尔积" class="headerlink" title="COSS JOIN 交叉连接  — 笛卡尔积"></a>COSS JOIN 交叉连接  — 笛卡尔积</h4><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> &lt;字段名&gt; <span class="hljs-keyword">FROM</span> &lt;表<span class="hljs-number">1</span>&gt; <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> &lt;表<span class="hljs-number">2</span>&gt; [<span class="hljs-keyword">WHERE</span>子句];或<span class="hljs-keyword">SELECT</span> &lt;字段名&gt; <span class="hljs-keyword">FROM</span> &lt;表<span class="hljs-number">1</span>&gt;, &lt;表<span class="hljs-number">2</span>&gt; [<span class="hljs-keyword">WHERE</span>子句];</code></pre><h4 id="INNER-JOIN-内连接"><a href="#INNER-JOIN-内连接" class="headerlink" title="INNER JOIN 内连接"></a>INNER JOIN 内连接</h4><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> &lt;字段名&gt; <span class="hljs-keyword">FROM</span> &lt;表<span class="hljs-number">1</span>&gt; [<span class="hljs-keyword">INNER</span>] <span class="hljs-keyword">JOIN</span> &lt;表<span class="hljs-number">2</span>&gt; [<span class="hljs-keyword">ON</span>子句];</code></pre><p>查询结果都是符合连接条件的记录</p><h4 id="LEFT-RIGHT-JOIN-外连接"><a href="#LEFT-RIGHT-JOIN-外连接" class="headerlink" title="LEFT/RIGHT JOIN 外连接"></a>LEFT/RIGHT JOIN 外连接</h4><p><strong>左外连接</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> &lt;字段名&gt; <span class="hljs-keyword">FROM</span> &lt;表<span class="hljs-number">1</span>&gt; <span class="hljs-keyword">LEFT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> &lt;表<span class="hljs-number">2</span>&gt; &lt;<span class="hljs-keyword">ON</span>子句&gt;;</code></pre><p>以左表为基准，保留左表的全部数据，右表匹配不上的为 NULL</p><p><strong>右外连接</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> &lt;字段名&gt; <span class="hljs-keyword">FROM</span> &lt;表<span class="hljs-number">1</span>&gt; <span class="hljs-keyword">RIGHT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> &lt;表<span class="hljs-number">2</span>&gt; &lt;<span class="hljs-keyword">ON</span>子句&gt;;</code></pre><p>以右表为基准，保留右表的全部数据，左表匹配不上的为 NULL</p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>子查询指将一个查询语句嵌套在另一个查询语句中。子查询可以在 <code>SELECT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中使用，而且可以进行多层嵌套，子查询经常出现在 <code>WHERE</code> 子句中。</p><pre><code class="hljs sql">-- 操作符可以是比较运算符和 IN、NOT IN、EXISTS、NOT EXISTS 等关键字WHERE &lt;表达式&gt; &lt;操作符&gt; (子查询)；</code></pre><p><strong>注意</strong>：</p><ul><li><p>子查询语句可以嵌套在 SQL 语句中任何表达式出现的位置</p><pre><code class="hljs sql"><span class="hljs-comment">-- 嵌套在 SELECT 语句的 SELECT 子句中</span><span class="hljs-keyword">SELECT</span> (子查询) <span class="hljs-keyword">FROM</span> 表名;<span class="hljs-comment">-- 嵌套在 SELECT 语句的 FROM 子句中</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> (子查询) <span class="hljs-keyword">AS</span> 表的别名;</code></pre></li><li><p>只出现在子查询中而没有出现在父查询中的表不能包含在输出列中</p><p>多层嵌套子查询的最终数据集只包含父查询（即最外层的查询）的 <code>SELECT</code> 子句中出现的字段，而子查询的输出结果通常会作为其外层子查询数据源或用于数据判断匹配。</p></li></ul><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p><code>UNION</code> 操作符用于合并两个或多个 <code>SELECT</code> 语句的结果集。</p><p><code>UNION</code> 和 <code>UNION ALL</code> 的主要区别是 <code>UNION ALL</code> 是把结果集直接合并在一起，而 <code>UNION</code> 是将 <code>UNION ALL</code> 后的结果进行一次 <code>DISTINCT</code> 去除掉重复数据</p><h3 id="处理无效数据"><a href="#处理无效数据" class="headerlink" title="处理无效数据"></a>处理无效数据</h3><ul><li>对于数值列或 TIME 列，超出合法取值范围的那些值将被截断到取值范围最近的那个端点，并把结果值存储起来。</li><li>对于除 TIME 列以外的其他类型列，非法值会被转换成与该类型一致的“零”值。</li><li>对于字符串列（不包括 ENUM 或 SET），过长的字符串将被截断到该列的最大长度。</li></ul><hr><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">LOWER</td><td style="text-align:center">将字符串所有字符变为小写</td></tr><tr><td style="text-align:center">UPPER</td><td style="text-align:center">将字符串所有字符变为大写</td></tr><tr><td style="text-align:center">CONCAT</td><td style="text-align:center">进行字符串拼接</td></tr><tr><td style="text-align:center">LEFT</td><td style="text-align:center">返回字符串最左边的字符</td></tr><tr><td style="text-align:center">RIGHT</td><td style="text-align:center">返回字符串最右边的字符</td></tr><tr><td style="text-align:center">INSERT</td><td style="text-align:center">字符串替换</td></tr><tr><td style="text-align:center">LTRIM</td><td style="text-align:center">去掉字符串左边的空格</td></tr><tr><td style="text-align:center">RTRIM</td><td style="text-align:center">去掉字符串右边的空格</td></tr><tr><td style="text-align:center">REPEAT</td><td style="text-align:center">返回重复的结果</td></tr><tr><td style="text-align:center">TRIM</td><td style="text-align:center">去掉字符串行尾和行头的空</td></tr><tr><td style="text-align:center">SUBSTRING</td><td style="text-align:center">返回指定的字符串</td></tr><tr><td style="text-align:center">LPAD</td><td style="text-align:center">用字符串对最左边进行填充</td></tr><tr><td style="text-align:center">RPAD</td><td style="text-align:center">用字符串对最右边进行填充</td></tr><tr><td style="text-align:center">STRCMP</td><td style="text-align:center">比较字符串 s1 和 s2</td></tr><tr><td style="text-align:center">REPLACE</td><td style="text-align:center">进行字符串替换</td></tr></tbody></table></div><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><h3 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h3><h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">IF(value,t f)</td><td style="text-align:center">如果 value 是真，返回 t；否则返回 f</td></tr><tr><td style="text-align:center">IFNULL(value1, value2)</td><td style="text-align:center">如果 value1 不为 NULL，返回 value1，否则返回 value2</td></tr><tr><td style="text-align:center">CASE WHEN[value1] THEN[result1] …ELSE[default] END</td><td style="text-align:center">如果 value1 是真，返回 result1，否则返回 default</td></tr><tr><td style="text-align:center">CASE[expr] WHEN[value1] THEN [result1]… ELSE[default] END</td><td style="text-align:center">如果 expr 等于 value1， 返回 result1， 否则返回 default</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven 创建 Spark 项目采坑记录</title>
    <link href="/2020/06/19/Maven-%E5%88%9B%E5%BB%BA-Spark-%E9%A1%B9%E7%9B%AE%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/06/19/Maven-%E5%88%9B%E5%BB%BA-Spark-%E9%A1%B9%E7%9B%AE%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Maven-创建-Spark-项目采坑记录"><a href="#Maven-创建-Spark-项目采坑记录" class="headerlink" title="Maven 创建 Spark 项目采坑记录"></a>Maven 创建 Spark 项目采坑记录</h2><p>用 maven 创建 spark 项目，创建完成后一片红，现在记录一下可以成功创建项目的步骤。</p><a id="more"></a><h3 id="创建新的项目"><a href="#创建新的项目" class="headerlink" title="创建新的项目"></a>创建新的项目</h3><p><img src="/2020/06/19/Maven-%E5%88%9B%E5%BB%BA-Spark-%E9%A1%B9%E7%9B%AE%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95/1.jpg" srcset="/img/loading.gif" alt="Create new project"></p><h3 id="修改-pom-xml-文件"><a href="#修改-pom-xml-文件" class="headerlink" title="修改 pom.xml 文件"></a>修改 pom.xml 文件</h3><ol><li>删除不需要的 plugin </li></ol><p><img src="/2020/06/19/Maven-%E5%88%9B%E5%BB%BA-Spark-%E9%A1%B9%E7%9B%AE%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95/2.jpg" srcset="/img/loading.gif" alt="scala plugin"></p><p><img src="/2020/06/19/Maven-%E5%88%9B%E5%BB%BA-Spark-%E9%A1%B9%E7%9B%AE%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95/3.jpg" srcset="/img/loading.gif" alt="eclipse plugin"></p><ol><li>配置 scala SDK  — 选择自己安装的 scala 版本</li></ol><p><img src="/2020/06/19/Maven-%E5%88%9B%E5%BB%BA-Spark-%E9%A1%B9%E7%9B%AE%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95/4.jpg" srcset="/img/loading.gif" alt="scala SDK"></p><ol><li>添加 spark 依赖：</li></ol><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--根据自己的环境选取相应的版本--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.spark<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spark-core_2.11<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><ol><li>检查 Libraries 确保 scala 版本一致（重要重要重要‼️）</li></ol><h3 id="现在就可以愉快的写代码了"><a href="#现在就可以愉快的写代码了" class="headerlink" title="现在就可以愉快的写代码了"></a>现在就可以愉快的写代码了</h3><p>写个大数据的 “HelloWorld” — WordCount 试试吧🤗</p>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spark 学习笔记</title>
    <link href="/2020/06/12/Spark-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/12/Spark-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Spark-学习笔记"><a href="#Spark-学习笔记" class="headerlink" title="Spark 学习笔记"></a>Spark 学习笔记</h1><hr><h2 id="一、Spark-简介"><a href="#一、Spark-简介" class="headerlink" title="一、Spark 简介"></a>一、Spark 简介</h2><p>基于<strong>内存计算</strong>的大数据<strong>并行计算框架</strong></p><p>特点：</p><ul><li>速度快</li><li>易用</li><li>通用</li><li>运行模式多样</li></ul><a id="more"></a><h2 id="二、Spark-生态系统"><a href="#二、Spark-生态系统" class="headerlink" title="二、Spark 生态系统"></a>二、Spark 生态系统</h2><h2 id="三、Spark-运行架构"><a href="#三、Spark-运行架构" class="headerlink" title="三、Spark 运行架构"></a>三、Spark 运行架构</h2><p>RDD：Resillient Distributed Dataset（弹性分布式数据集）共享内存模型</p><p>DAG：有向无环图  反映 RDD 之间的依赖关系</p><p>Executor：运行在工作节点的一个进程，负责运行 Task</p><p>Application：用户编写的 Spark 应用程序</p><p>Task：运行在 Executor 上的工作单元</p><p>Job：一个 Job 包含多个 RDD 及作用于相应 RDD 上的各种操作</p><p>Stage：是 Job 的基本调度单位，一个 Job 会分为多组 Task，每组 Task 被称为 Stage，或者也被称为 TaskSet，代表了一组关联的、相互之间没有 Shuffle 依赖关系的任务组成的任务集</p><p><img src="/2020/06/12/Spark-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/spark.png" srcset="/img/loading.gif" alt="Spark 运行架构"></p><h3 id="Spark-运行基本流程"><a href="#Spark-运行基本流程" class="headerlink" title="Spark 运行基本流程"></a>Spark 运行基本流程</h3><p><img src="/2020/06/12/Spark-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/run.png" srcset="/img/loading.gif" alt="Spark 基本运行流程"></p><p>RDD 在 Spark 中的运行过程：</p><ol><li><p>创建 RDD 对象</p></li><li><p>SparkContext 负责计算 RDD 时间的依赖关系，构建DAG</p></li><li><p>DAGScheduler 负责把 DAG 图分解成多个 Stage， 每个 Stage 中包含了多个 Task，每个 Task 会 TaskScheduler</p><p>分发给各个 WorkerNode 上的 Executor 去执行</p></li></ol><h2 id="四、RDD-编程"><a href="#四、RDD-编程" class="headerlink" title="四、RDD 编程"></a>四、RDD 编程</h2><h3 id="1-RDD-创建"><a href="#1-RDD-创建" class="headerlink" title="1. RDD 创建"></a>1. RDD 创建</h3><ul><li><p>从文件系统中加载数据创建</p><p><code>sc.textFile(&quot;file:///&quot;)</code> 本地文件系统</p><p><code>sc.textFile(&quot;hdfs://地址&quot;)</code> 分布式文件系统 HDFS</p></li><li><p>通过并行集合（数组）创建 RDD</p><p><code>sc.parallelize()</code></p></li></ul><h3 id="2-RDD-操作-惰性求值"><a href="#2-RDD-操作-惰性求值" class="headerlink" title="2. RDD 操作 惰性求值"></a>2. RDD 操作 惰性求值</h3><h4 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a>转换操作</h4><p>filter：筛选、map：映射、flatMap、groupByKey()、reduceByKey()</p><h4 id="行动操作-真正触发计算"><a href="#行动操作-真正触发计算" class="headerlink" title="行动操作  真正触发计算"></a>行动操作  真正触发计算</h4><p><code>count()</code> 返回数据集中的元素个数 </p><p><code>collect()</code> 以<strong>数组</strong>的形式返回数据集中的所有元素 </p><p><code>first()</code> 返回数据集中的第一个元素 </p><p><code>take(n)</code> 以数组的形式返回数据集中的前n个元素 </p><p><code>reduce(func)</code> 通过函数 func（输入两个参数并返回一个值） 聚合数据集中的元素</p><p><code>foreach(func)</code> 将数据集中的每个元素传递到函数func中运行</p><h3 id="3-RDD-持久化"><a href="#3-RDD-持久化" class="headerlink" title="3. RDD 持久化"></a>3. RDD 持久化</h3><h3 id="4-RDD-分区"><a href="#4-RDD-分区" class="headerlink" title="4. RDD 分区"></a>4. RDD 分区</h3><h3 id="5-键值对-RDD"><a href="#5-键值对-RDD" class="headerlink" title="5. 键值对 RDD"></a>5. 键值对 RDD</h3><p><code>reduceByKey(func)</code> 使用 func 函数合并具有相同键的值，用于对每个 key 对应的多个 value 进行 merge 操作，最重要的是它能够在本地先进行 merge 操作，并且 merge 操作可以通过函数自定义</p><p><code>groupByKey()</code> 对具有相同 key 的 value 进行分组，但只生成一个 sequence，groupByKey 本身不能自定义函数，需要先用 groupByKey 生成 RDD，然后才能对此 RDD 通过 map 进行自定义函数操作</p><p><code>keys</code>只会把 Pair RDD 中的 key 返回形成一个新的 RDD</p><p><code>values</code>  只会把 Pair RDD中 的 value 返回形成一个新的 RDD。</p><p><code>sortByKey()</code> 返回一个根据键排序的 RDD，默认是升序排序</p><p><code>mapValues(func)</code> 对键值对 RDD 中的每个 value 都应用一个函数，但是，key 不会发生变化</p><p><code>join</code> 内连接，只有在两个数据集中都存在的 key 才会被输出，最终得到一个 (K,(V1,V2)) 类型的数据集。</p><p><code>combineByKey(createCombiner,mergeValue,mergeCombiners,partitioner ,mapSideCombine)</code></p><h3 id="6-共享变量"><a href="#6-共享变量" class="headerlink" title="6. 共享变量"></a>6. 共享变量</h3><p>广播变量：把变量在所有节点的内存之间进行共享。缓存一个只读变量</p><p>​    通过调用 <code>SparkContext.broadcast(v)</code> 来从一个普通变量 v 中创建一个广播变量</p><p>​    通过调用 <code>value</code> 方法就可以获得这个广播变量的值，</p><p>累加器：支持在所有不同节点之间进行累加计算</p><p>​    通过调用 <code>SparkContext.longAccumulator()</code> 或者 <code>SparkContext.doubleAccumulator()</code> 来创建</p><p>​    只有任务控制节点（Driver Program）可以使用 <code>value</code> 方法来读取累加器的值</p><h3 id="7-数据读写"><a href="#7-数据读写" class="headerlink" title="7. 数据读写"></a>7. 数据读写</h3><h4 id="本地文件数据的读写"><a href="#本地文件数据的读写" class="headerlink" title="本地文件数据的读写"></a>本地文件数据的读写</h4><p><code>sc.textFile()</code>  惰性机制，行动操作才进行加载</p><p><code>saveAsTextFile()</code>  生成一个目录  part-00000  RDD 分区，再次加载只需要写这个目录</p><h4 id="分布式文件系统读写"><a href="#分布式文件系统读写" class="headerlink" title="分布式文件系统读写"></a>分布式文件系统读写</h4><p><code>sc.textFile(&quot;hdfs://&quot;)</code></p><h4 id="JSON-文件读写"><a href="#JSON-文件读写" class="headerlink" title="JSON 文件读写"></a>JSON 文件读写</h4><p><code>sc.textFile()</code></p><p>对 json 进行解析 scala.util.parsing.json.Json 可以实现对 JSON 数据的解析</p><h3 id="8-HBase"><a href="#8-HBase" class="headerlink" title="8. HBase"></a>8. HBase</h3><p>HBase 中需要根据行键、列族、列限定符和时间戳来确定一个单元格</p><p>HBase 需要时间戳是因为 HBAse 的底层是 HDFS，HDFS 要求一次写入不能进行修改，所以要修改单元格的数据只能生成新的版本，让最新的数指向最新的版本</p><p>四维坐标定位【行键、列族、列、版本时间戳】</p><p>一个单元格一个插入数据</p><h2 id="五、Spark-SQL"><a href="#五、Spark-SQL" class="headerlink" title="五、Spark SQL"></a>五、Spark SQL</h2><p>RDD 是分布式的 Java 对象的集合</p><p>DataFrame 是一种以 RDD 为基础的分布式数据集</p><p><code>spark.read.json()</code> 读取 json 文件</p><p><code>spark.read.parquet(&quot;people.parquet&quot;)</code> </p><p><code>spark.read.csv(&quot;people.csv&quot;)</code></p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HBase 基础总结</title>
    <link href="/2020/04/24/HBase-%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <url>/2020/04/24/HBase-%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="HBase-基础总结"><a href="#HBase-基础总结" class="headerlink" title="HBase 基础总结"></a>HBase 基础总结</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>分布式、可扩展、支持海量数据存储的 NoSQL 数据库</p><a id="more"></a> <h3 id="2-HBase-架构"><a href="#2-HBase-架构" class="headerlink" title="2. HBase 架构"></a>2. HBase 架构</h3><ul><li><strong>Master</strong>  ：维护表结构信息，比如建表、删表、移动 Region、合并等<ul><li>监控 RegionServer</li><li>处理 RegionServer 故障转移</li><li>处理元数据的变更</li><li>分配 regions 到每个 RegionServer</li></ul></li><li><strong>RegionServer</strong> ：负责存储数据的服务器，存放 Region 的容器<ul><li>负责存储 HBase 的实际数据</li><li>处理分配给它的 Region</li><li>刷新缓存到 HDFS</li><li>维护 Hlog</li><li>执行压缩</li><li>负责处理 Region 分片</li></ul></li><li><strong>Region</strong> : 一段数据的集合，HBase 的一个表有多个 Region<ul><li>不能跨服务器</li><li>数据量大的时候，HBase 会拆分 Region</li></ul></li></ul><p>依赖 Zookeper 的服务</p><p><img src="/2020/04/24/HBase-%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/HBase.png" srcset="/img/loading.gif" alt="HBase 架构"></p><h3 id="3-HBase-存储的概念"><a href="#3-HBase-存储的概念" class="headerlink" title="3. HBase 存储的概念"></a>3. HBase 存储的概念</h3><ul><li><strong>Cell</strong> : 单元格</li><li><strong>列</strong> ：最基本的存储单位</li><li><strong>列族</strong> ：列必须依赖列族存在，指定一个列【 列族 : 列 】</li><li><strong>行</strong> ：每行数据由一个 row key 和多个列组成，数据是按照 RowKey 的<strong>字典顺序</strong>存储的</li></ul><p>唯一确定一条结果的表示 ——【 行键：列族：列：版本号 】</p><ul><li><strong>时间戳</strong> ：用来标识数据的不同版本</li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读《Graph Neural Networks for User Identity Linkage》</title>
    <link href="/2020/04/14/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AGraph-Neural-Networks-for-User-Identity-Linkage%E3%80%8B/"/>
    <url>/2020/04/14/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AGraph-Neural-Networks-for-User-Identity-Linkage%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="论文阅读《Graph-Neural-Networks-for-User-Identity-Linkage》"><a href="#论文阅读《Graph-Neural-Networks-for-User-Identity-Linkage》" class="headerlink" title="论文阅读《Graph Neural Networks for User Identity Linkage》"></a>论文阅读《Graph Neural Networks for User Identity Linkage》</h2><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>仅用社交网络结构信息，通过 GNN 学习局部和全局的网络结构进行节点的表示</p><a id="more"></a><p>待完成。。。</p><h3 id="Research-Objective"><a href="#Research-Objective" class="headerlink" title="Research Objective"></a>Research Objective</h3><p>通过网络学习进行用户表示，消除手工提取特征的噪声和偏差。</p><p>如何仅使用社交网络的图信息有效地学习跨社交网络的用户表示；</p><p>如何通过图神经网络在数学上形式化用户身份链接问题，从而提高预测性能。</p><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>GNNs：主要思想是使用神经网络聚合来自局部图邻域的特征信息。同时，节点信息可以在变换和聚合之后通过图传播，以获得全局视图。</p><h3 id="Method-s-—-GraphUIL"><a href="#Method-s-—-GraphUIL" class="headerlink" title="Method(s) — GraphUIL"></a>Method(s) — GraphUIL</h3><p>学习潜在的用户表示，同时保证局部和全局的网络结构信息。</p><p>构建一个非线性的跨平台的 mapping kernel，以预测用户身份链接。</p><h4 id="Network-Embedding-Through-Node-Propagation"><a href="#Network-Embedding-Through-Node-Propagation" class="headerlink" title="Network Embedding Through Node Propagation"></a>Network Embedding Through Node Propagation</h4><h4 id="Global-Topology-Aware-Aggregator-GTA-Agg"><a href="#Global-Topology-Aware-Aggregator-GTA-Agg" class="headerlink" title="Global-Topology-Aware Aggregator (GTA-Agg)"></a>Global-Topology-Aware Aggregator (GTA-Agg)</h4><h4 id="Local-Topology-Aware-Aggregator-LTA-Agg"><a href="#Local-Topology-Aware-Aggregator-LTA-Agg" class="headerlink" title="Local-Topology-Aware Aggregator (LTA-Agg)"></a>Local-Topology-Aware Aggregator (LTA-Agg)</h4><h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h3><p>对比 PALE，FRUIP ，Node2Vec 方法以及 GraphUIL 仅使用局部或全局的拓扑结构嵌入方法</p><p>衡量指标：Accuracy，F1</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3>]]></content>
    
    
    <categories>
      
      <category>科研论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Social Networks</tag>
      
      <tag>User Identity Linkage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读《A Novel Framework with Information Fusion and Neighborhood Enhancement for User Identity Linkage》</title>
    <link href="/2020/04/13/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-Novel-Framework-with-Information-Fusion-and-Neighborhood-Enhancement-for-User-Identity-Linkage%E3%80%8B/"/>
    <url>/2020/04/13/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-Novel-Framework-with-Information-Fusion-and-Neighborhood-Enhancement-for-User-Identity-Linkage%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="论文阅读《A-Novel-Framework-with-Information-Fusion-and-Neighborhood-Enhancement-for-User-Identity-Linkage》"><a href="#论文阅读《A-Novel-Framework-with-Information-Fusion-and-Neighborhood-Enhancement-for-User-Identity-Linkage》" class="headerlink" title="论文阅读《A Novel Framework with Information Fusion and Neighborhood Enhancement for User Identity Linkage》"></a>论文阅读《A Novel Framework with Information Fusion and Neighborhood Enhancement for User Identity Linkage》</h2><h3 id="Information-Fusion"><a href="#Information-Fusion" class="headerlink" title="Information Fusion"></a>Information Fusion</h3><p>整合不同信息的统一框架</p><p>Profiles：screen name —&gt; 编辑距离计算相似性</p><p>Contents：将所有的帖子放在一个文档中，然后输入到 Doc2Vec 模型计算相似性</p><p>Network Structure</p><a id="more"></a><p><img src="/2020/04/13/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-Novel-Framework-with-Information-Fusion-and-Neighborhood-Enhancement-for-User-Identity-Linkage%E3%80%8B/stage1.png" srcset="/img/loading.gif" alt="Information Fusion"></p><h3 id="Neighborhood-Enhancement"><a href="#Neighborhood-Enhancement" class="headerlink" title="Neighborhood Enhancement"></a>Neighborhood Enhancement</h3><p>graph neural network</p><p><img src="/2020/04/13/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-Novel-Framework-with-Information-Fusion-and-Neighborhood-Enhancement-for-User-Identity-Linkage%E3%80%8B/stage2.png" srcset="/img/loading.gif" alt="Neighborhood Enhancement"></p>]]></content>
    
    
    <categories>
      
      <category>科研论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Social Networks</tag>
      
      <tag>User Identity Linkage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《深入理解 Java 虚拟机》OOM 笔记</title>
    <link href="/2020/04/07/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8BOOM-%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/04/07/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8BOOM-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="实战：OutOfMemoryError-异常"><a href="#实战：OutOfMemoryError-异常" class="headerlink" title="实战：OutOfMemoryError 异常"></a>实战：OutOfMemoryError 异常</h2><h3 id="Java-堆溢出"><a href="#Java-堆溢出" class="headerlink" title="Java 堆溢出"></a>Java 堆溢出</h3><p>当堆内存（Heap Space）没有足够空间存放新创建的对象时，就会抛出 <code>java.lang.OutOfMemoryError:Java heap space</code> </p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>1、代码中可能存在大对象分配，通常是大数组</p><p>2、可能存在内存泄露（Memory Leak），大量对象没有被释放，导致在多次 GC 之后无法回收，还是无法找到一块足够大的内存容纳当前对象。</p><a id="more"></a><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaHeapSpaceDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 创建大对象</span>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">50</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];    &#125;&#125;</code></pre><p><img src="/2020/04/07/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8BOOM-%E7%AC%94%E8%AE%B0/heapOOM.png" srcset="/img/loading.gif" alt="heapOOM"></p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>1、检查是否存在大对象的分配，大数组分配<br>2、通过 jmap 命令，把堆内存 dump 下来，使用 mat 工具分析，检查是否存在内存泄露的问题<br>3、如果没有找到明显的内存泄露，使用 <code>-Xmx</code> 加大堆内存<br>4、还有一点容易被忽略，检查是否有大量的自定义的 Finalizable 对象，也有可能是框架内部提供的，考虑其存在的必要性</p><h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常。 </p><p>2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出 OutOfMemoryError 异常。</p><pre><code class="hljs java"><span class="hljs-comment">/** * 模拟栈溢出 * -Xss160k */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaVMStackSOF</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> stackLen = <span class="hljs-number">1</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stackLeak</span><span class="hljs-params">()</span></span>&#123;        stackLen++;        stackLeak();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        JavaVMStackSOF oom = <span class="hljs-keyword">new</span> JavaVMStackSOF();        <span class="hljs-keyword">try</span> &#123;            oom.stackLeak();        &#125; <span class="hljs-keyword">catch</span> (Throwable e)&#123;            System.out.println(<span class="hljs-string">"stack Length: "</span> + oom.stackLen);            <span class="hljs-keyword">throw</span> e;        &#125;    &#125;&#125;</code></pre><p><img src="/2020/04/07/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8BOOM-%E7%AC%94%E8%AE%B0/stackOOM.png" srcset="/img/loading.gif" alt="stackOOM"></p><p>无论是由于栈帧太大还是虚拟机栈容量太小，当新的栈帧内存无法分配的时候， HotSpot 虚拟机抛出的都是 StackOverflowError 异常</p><h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><p>创建了大量的线程</p><h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>1、限制线程池大小；</p><p>2、使用 -Xss 参数减少线程栈的大小；</p><h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><p>JDK 1.8 之后为元空间</p><pre><code class="hljs css"><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.OutOfMemoryError</span>: <span class="hljs-selector-tag">PermGen</span> <span class="hljs-selector-tag">space</span><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.OutOfMemoryError</span>: <span class="hljs-selector-tag">Metaspace</span></code></pre><h4 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h4><p>永久代是 HotSot 虚拟机对方法区的具体实现，存放了被虚拟机加载的类信息、常量、静态变量、JIT 编译后的代码等。</p><p>JDK8 后，元空间替换了永久代，元空间使用的是本地内存，还有其它细节变化：</p><ul><li>从 JDK 7 起，<strong>字符串常量</strong>由永久代转移到<strong>堆</strong>中</li><li>和永久代相关的 JVM 参数已移除</li></ul><p>可能原因有如下几种：</p><p>1、在 Java7 之前，频繁的错误使用 String.intern() 方法 </p><blockquote><p>String.intern() 本地方法，它的作用是如果字符串常量池中已经包含一个等于此 String 对象的字符串，则返回代表池中这个字符串的 String 对象的引用；否则，会将此 String 对象包含的字符串添加 到常量池中，并且返回此 String 对象的引用。</p><p>在 JDK 6 中，intern() 方法会把首次遇到的字符串实例复制到永久代的字符串常量池中存储，返回的也是永久代里面这个字符串实例的引用。而 JDK 7 的 intern() 方法实现不需要再拷贝字符串的实例 到永久代，字符串常量池已经移到 Java 堆中，只需要在常量池里记录一下首次出现的实例引用即可</p></blockquote><p>2、运行期间生成了大量的代理类，导致方法区被撑爆，无法卸载 </p><p>3、应用长时间运行，没有重启</p><h4 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h4><p>该 OOM 原因比较简单，解决方法有如下几种：</p><p>1、程序启动报错，检查是否永久代空间 <code>-XX:MaxPermSize</code> 或者元空间 <code>-XX:MaxMetaspaceSize</code> 设置的过小<br>2、检查代码中是否存在大量的反射操作<br>3、dump 之后通过 mat 检查是否存在大量由于反射生成的代理类<br>4、重启 JVM</p><h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>抛出 <code>java.lang.OutOfMemoryError: Direct buffer memory</code></p><p>由直接内存导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看见有什么明显的异常情况，如果内存溢出之后产生的 Dump 文件很小，而程序中又直接或间接使用了 DirectMemory（典型的间接使用就是 NIO），有可能是直接内存出了问题。</p><p> 例如：写 NIO 程序经常使用 <code>ByteBuffer</code> 来读取或写入数据，它可以使用 <code>Native</code> 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作，这样避免了在 Java 堆和 Native 堆中来回复制数据。但不断分配本地内存，堆内存很少使用，那么 JVM 就不会进行 GC，<code>DirectByteBuffer</code> 对象就不会被回收，此时堆内存充足，但是本地内存已经用光了，造成该 error</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1420980/cy16m7m2h9.jpeg?imageView2/2/w/1620" srcset="/img/loading.gif" alt="img"></p><h3 id="GC-Overhead"><a href="#GC-Overhead" class="headerlink" title="GC Overhead"></a>GC Overhead</h3><p><code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>    </p><p>GC 回收时间过长（98% 时间用来做 GC，并且回收了不到 2% 的堆内存，CPU 利用率高，但是 GC 效果不明显）</p><h3 id="创建多个线程"><a href="#创建多个线程" class="headerlink" title="创建多个线程"></a>创建多个线程</h3><p><code>java.lang.OutOfMemoryError: unable to create new native thread</code>      </p><p>一个应用进程创建了多个线程，超过系统承载极限；或者服务器不允许创建这么多个线程。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.im/post/5dc6bf65f265da4d4a306e81#heading-12" target="_blank" rel="noopener">https://juejin.im/post/5dc6bf65f265da4d4a306e81#heading-12</a></p><p><a href="https://cloud.tencent.com/developer/article/1492349" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1492349</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《深入理解 Java 虚拟机》第13章阅读笔记</title>
    <link href="/2020/04/05/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC13%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/04/05/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC13%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第-13-章-线程安全与锁优化"><a href="#第-13-章-线程安全与锁优化" class="headerlink" title="第 13 章 线程安全与锁优化"></a>第 13 章 线程安全与锁优化</h2><h3 id="一、线程安全"><a href="#一、线程安全" class="headerlink" title="一、线程安全"></a>一、线程安全</h3><p>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么就称这个对象是线程安全的。 </p><a id="more"></a><h4 id="1-Java-语言中的线程安全"><a href="#1-Java-语言中的线程安全" class="headerlink" title="1. Java 语言中的线程安全"></a>1. Java 语言中的线程安全</h4><h4 id="1-不可变"><a href="#1-不可变" class="headerlink" title="1) . 不可变"></a>1) . 不可变</h4><p>不可变的对象一定是线程安全的。</p><p>Java语言中，如果多线程共享的数据是一个<strong>基本数据类型</strong>，那么只要在定义时使用 final 关键字修饰它就可以保证它是不可变的。</p><p><strong>Java API 中不可变的类型</strong>：String，枚举类型，Long 和 Double 等数值包装类型、BigInteger 和BigDecimal 等大数据类型。</p><h4 id="2-绝对线程安全"><a href="#2-绝对线程安全" class="headerlink" title="2) . 绝对线程安全"></a>2) . 绝对线程安全</h4><p>不管运行时环境下采用何种调度方式，或者这些线程如何交替执行，调用者都不需要任何额外的同步措施。</p><h4 id="3-相对线程安全"><a href="#3-相对线程安全" class="headerlink" title="3) . 相对线程安全"></a>3) . 相对线程安全</h4><p>通常意义下的线程安全，保证对这个对象单次的操作是线程安全的，在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，可能需要在调用端使用额外的同步手段来保证调用的正确性。</p><p>例如 Vector、HashTable、Collections 的  synchronizedCollection()方法包装的集合等。</p><h4 id="4-线程兼容"><a href="#4-线程兼容" class="headerlink" title="4) . 线程兼容"></a>4) . 线程兼容</h4><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。</p><h4 id="5-线程对立"><a href="#5-线程对立" class="headerlink" title="5) . 线程对立"></a>5) . 线程对立</h4><p>线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。Java 语言天生就支持多线程，线程对立这种排斥多线程的代码是很少出现的，通常有害，应当尽量避免。</p><h4 id="2-线程安全的实现方法"><a href="#2-线程安全的实现方法" class="headerlink" title="2. 线程安全的实现方法"></a>2. 线程安全的实现方法</h4><h4 id="2-1-互斥同步-阻塞同步"><a href="#2-1-互斥同步-阻塞同步" class="headerlink" title="2.1. 互斥同步(阻塞同步)"></a>2.1. 互斥同步(阻塞同步)</h4><p><strong>同步</strong>：指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些， 当使用信号量的时候）线程使用。</p><p><strong>互斥</strong>：是实现同步的一种手段，<strong>临界区</strong>、<strong>互斥量</strong>和<strong>信号量</strong>都是常见的互斥实现方式。</p><h4 id="synchronized-关键字：最基本的互斥同步手段"><a href="#synchronized-关键字：最基本的互斥同步手段" class="headerlink" title="synchronized 关键字：最基本的互斥同步手段"></a>synchronized 关键字：最基本的互斥同步手段</h4><p>synchronized 关键字经过 Javac 编译之后，会在同步块的前后分别形成 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 这两个字节码指令。</p><p>synchronized 修饰对象，直接指定了对象参数，即对该对象锁定和解锁。</p><p>synchronized 修饰方法，根据方法的类型，实例方法取代码所在的对象实例，类方法取类型对应的 Class对象来作为线程要持有的锁。</p><p>在执行 monitorenter 指令时，首先要去尝试获取对象的锁。把锁的计数器的值增加一，而在执行 monitorexit 指令时会将锁计数器的值减一。一旦计数器的值为零，锁随即就被释放了。</p><ul><li>synchronized 修饰的同步块对同一线程可重入</li><li>在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。无法强制中断、退出。</li></ul><h4 id="java-util-concurrent-locks-Lock接口"><a href="#java-util-concurrent-locks-Lock接口" class="headerlink" title="java.util.concurrent.locks.Lock接口"></a>java.util.concurrent.locks.Lock接口</h4><p>ReentrantLock 可重入锁，Lock 接口的一种具体实现类。</p><p>比 synchronized 增加了一些高级功能：</p><ul><li>等待可中断</li><li>支持公平锁，默认非公平</li><li>锁绑定多个条件，可以同时绑定多个 Condition 对象，实现精确唤醒。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>synchronized：Java 语法层面，无法判断锁获取的状态，锁可以自动释放，Java 虚拟机更容易对其进行优化。</p><p>ReentrantLock：Java API，可以判断是否获取到锁，必须要在 finally 中手动释放锁。它比 synchronized 增加了一些高级功能，比如：等待可中断、公平锁、绑定多个条件。</p><h4 id="2-2-非阻塞同步"><a href="#2-2-非阻塞同步" class="headerlink" title="2.2. 非阻塞同步"></a>2.2. 非阻塞同步</h4><p>基于冲突检测的乐观并发策略，不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。</p><p>靠硬件来保证操作和冲突检测具有原子性。</p><p><strong>CAS 指令</strong></p><p>CAS 指令需要有三个操作数，分别是内存位置（在 Java 中可以简单地理解为变量的内存地址，用 V 表示）、旧的预期值（A）和准备设置的新值（B）。CAS 指令执行时，当且仅当 V 符合 A 时，处理器才会用B 更新 V 的值，否则就不执行更新。但是，不管是否更新了 V 的值，都会返回 V 的旧值，该处理过程是一个原子操作，执行期间不会被其他线程中断。</p><p>Java 中 CAS 操作由 sun.misc.Unsafe 类里面的 compareAndSwapInt() 和 compareAndSwapLong() 等几个方法包装提供。</p><p><strong>CAS 的漏洞 — ABA 问题</strong></p><p>问题描述：一个线程将 变量 A 改成 B，后来又改成了 A，CAS 操作会误认为该变量没有改变。</p><p>解决：带有标记的原子引用类 <code>AtomicStampedReference，</code>可以通过控制变量值的<strong>版本</strong>来保证 CAS 的正确性。</p><h4 id="2-3-无同步的方案"><a href="#2-3-无同步的方案" class="headerlink" title="2.3 无同步的方案"></a>2.3 无同步的方案</h4><p>让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证其正确性。</p><p><strong>可重入代码</strong>：所有可重入的代码都是线程安全的，但并非所 有的线程安全的代码都是可重入的。可重入代码不依赖全局变量、存储在堆上的数据和公用的系统资源， 用到的状态量都由参数中传入，不调用非可重入的方法等。</p><p><strong>线程本地存储</strong>：比如 ThreadLocal </p><h3 id="二、锁优化"><a href="#二、锁优化" class="headerlink" title="二、锁优化"></a>二、锁优化</h3><h4 id="1-自旋锁与自适应锁"><a href="#1-自旋锁与自适应锁" class="headerlink" title="1. 自旋锁与自适应锁"></a>1. 自旋锁与自适应锁</h4><p><strong>自旋锁</strong>：让后面请求锁的线程「稍等一会」，但不放弃处理器的执行时间，看持有锁的线程是否很快就会释放锁。为了让线程等待，只须让线程执行一个忙循环（自旋），这项技术就是自旋锁。</p><p>JDK 6 中对自旋锁的优化，引入了<strong>自适应的自旋</strong>。自适应意味着自旋的时间不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。</p><h4 id="2-锁消除"><a href="#2-锁消除" class="headerlink" title="2. 锁消除"></a>2. 锁消除</h4><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。</p><p>通过逃逸分析发现，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，不进行同步加锁。虽然有锁，但是可以被安全地消除掉。在解释执行时仍然会加锁，但在经过服务端编译器的即时编译之后，代码会忽略所有的同步措施而直接执行。</p><h4 id="3-锁粗化"><a href="#3-锁粗化" class="headerlink" title="3. 锁粗化"></a>3. 锁粗化</h4><p>如果虚拟机探测到有这样一串零碎的操作，都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p><h4 id="4-轻量级锁"><a href="#4-轻量级锁" class="headerlink" title="4. 轻量级锁"></a>4. 轻量级锁</h4><p>轻量级锁是JDK 6时加入的新型锁机制。</p><p>虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对 象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁。</p><h4 id="5-偏向锁"><a href="#5-偏向锁" class="headerlink" title="5. 偏向锁"></a>5. 偏向锁</h4><p>偏向锁也是 JDK 6 中引入的一项锁优化措施，它的目的是<strong>消除数据在无竞争情况下的同步原语</strong>， 进一步提高程序的运行性能。</p><p>偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p><p><img src="/2020/04/05/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC13%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/synchronized.png" srcset="/img/loading.gif" alt="synchronized 锁升级"></p><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadId 字段，在第一次访问的时候 threadId 为空，JVM 让其持有偏向锁，并将 threadId 设置为其线程 id，再次进入的时候会先判断 threadId 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p><p>使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flink 学习笔记 Event Time</title>
    <link href="/2020/03/31/Flink-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Event-Time/"/>
    <url>/2020/03/31/Flink-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Event-Time/</url>
    
    <content type="html"><![CDATA[<h3 id="Flink-学习笔记-Event-Time"><a href="#Flink-学习笔记-Event-Time" class="headerlink" title="Flink 学习笔记 Event Time"></a>Flink 学习笔记 Event Time</h3><h4 id="Processing-Time"><a href="#Processing-Time" class="headerlink" title="Processing Time"></a>Processing Time</h4><p>执行相应算子操作时机器的系统时间</p><p>当流程序运行在 proceesing time 上时，所有基于时间的算子（window）都会使用机器的系统时间。</p><p>Processing time 是最简单的“Time”概念，不需要流和机器之间的协调。 提供了最佳的性能和最低的延迟。 但是，在分布式和异步环境中，不能提供确定性，因为它易受事件到达系统速度（例如，从消息队列）、事件在系统内部算子间流动的速度以及中断的影响。</p><a id="more"></a><h4 id="Event-Time"><a href="#Event-Time" class="headerlink" title="Event Time"></a>Event Time</h4><p>事件发生的时间，这个时间在事件进入 Flink 之前就绑定好了，并且可以从事件记录中提取该 Event timeStamp。Event time 依赖依赖于数据本身，另外，事件时间程序必须指定如何生成事件时间水印（表示时间进度）。</p><h4 id="Ingestion-time"><a href="#Ingestion-time" class="headerlink" title="Ingestion time"></a>Ingestion time</h4><p>事件进入 Flink 的时间，在 source 算子操作的时候，每个时间将数据源的当前时间记作时间戳，其它在Flink 中有关时间的算子都是利用这个时间戳。</p><p><img src="/2020/03/31/Flink-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Event-Time/times_clocks.svg" srcset="/img/loading.gif" alt="img"></p><h4 id="设置时间特性"><a href="#设置时间特性" class="headerlink" title="设置时间特性"></a>设置时间特性</h4><pre><code class="hljs java"><span class="hljs-keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime);<span class="hljs-comment">// alternatively:</span><span class="hljs-comment">// env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime);</span><span class="hljs-comment">// env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span>DataStream&lt;MyEvent&gt; stream = env.addSource(<span class="hljs-keyword">new</span> FlinkKafkaConsumer09&lt;MyEvent&gt;(topic, schema, props));stream    .keyBy( (event) -&gt; event.getUser() )    .timeWindow(Time.hours(<span class="hljs-number">1</span>))    .reduce( (a, b) -&gt; a.add(b) )    .addSink(...);</code></pre><h4 id="Event-Time-和-Watermarks"><a href="#Event-Time-和-Watermarks" class="headerlink" title="Event Time 和 Watermarks"></a>Event Time 和 Watermarks</h4><p>支持 event time 的流处理器需要一种机制来衡量时间进度 — watermarks</p><p>watermarks 携带着时间戳作为数据流的一部分流动</p><p>。。。待续。。。</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flink</tag>
      
      <tag>流处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《深入理解 Java 虚拟机》第12章阅读笔记</title>
    <link href="/2020/03/30/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC12%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/30/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC12%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第12章-Java内存模型与线程"><a href="#第12章-Java内存模型与线程" class="headerlink" title="第12章　Java内存模型与线程"></a>第12章　Java内存模型与线程</h2><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>高速缓存的使用引入了「缓存一致性」问题。</p><p>而内存模型是指在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的内存模型。</p><a id="more"></a><h3 id="程序的乱序执行"><a href="#程序的乱序执行" class="headerlink" title="程序的乱序执行"></a>程序的乱序执行</h3><p>处理器为了充分利用运算单元，可能会对输入代码进行<strong>乱序执行（Out-Of-Order Execution）优化</strong>，处理器会在计算之后将乱序执行的<strong>结果重组</strong>，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。</p><h3 id="Java-内存模型（Java-Memory-Model，JMM）"><a href="#Java-内存模型（Java-Memory-Model，JMM）" class="headerlink" title="Java 内存模型（Java Memory Model，JMM）"></a>Java 内存模型（Java Memory Model，JMM）</h3><p><strong>目的</strong>：屏 蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p><p><img src="/2020/03/30/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC12%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/jmm.jpg" srcset="/img/loading.gif" alt="img"></p><p>Java 内存模型规定：</p><ul><li>所有变量都存储在主内存（Main Memory）中</li><li>每条线程有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本</li><li>线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据</li><li>不同的线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</li></ul><p><strong>注意</strong>：之前看一些资料说 volatile 是直接操作主内存的，本书中特意提到了这一点，应该是不正确的。</p><blockquote><p>根据《Java虚拟机规范》的约定，volatile 变量依然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般。  — 摘自书中注释</p></blockquote><h4 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h4><p>lock、unlock、read、load、use、assign、store、write</p><h4 id="Volatile-的特殊规则"><a href="#Volatile-的特殊规则" class="headerlink" title="Volatile 的特殊规则"></a>Volatile 的特殊规则</h4><ol><li><p>保证此变量对所有线程的可见性</p><blockquote><p>可见性：当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</p></blockquote></li><li><p>禁止指令重排序优化🚫</p><p>有 volatile 修饰的变量，赋值后多执行了一个 <code>lock addl $0x0，(%esp)</code> 操作，这个操作的作用相当于一个内存屏障 (Memory Barrier 或 Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置), lock  的作用是将本处理器的缓存写入内存，这让 volatile 变量的修改对其他处理器立即可见。</p></li><li><p>不能保证原子性</p></li></ol><h4 id="long-和-double-的非原子性协定"><a href="#long-和-double-的非原子性协定" class="headerlink" title="long 和 double 的非原子性协定"></a>long 和 double 的非原子性协定</h4><p>JMM 允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现自行选择是否要保证 64 位数据类型的 load、store、read 和 write 这四个操作的原子性，</p><h4 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h4><p><strong>1. 原子性</strong></p><p>六个原子性操作指令，可以认为基本数据类型的访问、读写都是具备原子性的</p><p><strong>2. 可见性</strong></p><p>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的。</p><p><strong>3. 有序性</strong></p><p>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程， 所有的操作都是无序的。</p><h3 id="Java-与线程"><a href="#Java-与线程" class="headerlink" title="Java 与线程"></a>Java 与线程</h3><p>线程是比进程更轻量级的调度执行单位，<strong>线程</strong>是 Java 里面进行处理器资源调度的最基本单位。</p><h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><ol><li><p><strong>内核线程实现</strong>：线程由内核来完成线程切换</p><p>实际使用的是轻量级进程 LWP，每个 LWP 对应一个内核线程 KLT。</p><p><strong>缺点</strong>：轻量级进程基于内核线程实现，各种线程操作都需要进行系统调用。而系统调需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。另外，每个轻量级进程都需要有一个内核线程的支持，要消耗一定的内核资源（如内核线程的栈 空间），因此一个系统支持轻量级进程的数量是有限的。</p></li><li><p><strong>用户线程实现</strong>：完全建立在用户空间的线程库上，用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。</p></li><li><p>用户线程加轻量级进程混合实现：一个内核线程 KLT 对应一个轻量级进程LWP，而一个 LWP 对应多个用户线程 UT</p></li></ol><h4 id="Java-线程状态转换"><a href="#Java-线程状态转换" class="headerlink" title="Java 线程状态转换"></a>Java 线程状态转换</h4><p><img src="/2020/03/30/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC12%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/thread.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java ArrayList 源码阅读笔记</title>
    <link href="/2020/03/28/Java-ArrayList-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/28/Java-ArrayList-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="ArrayList-源码阅读"><a href="#ArrayList-源码阅读" class="headerlink" title="ArrayList 源码阅读"></a>ArrayList 源码阅读</h3><p>ArrayList 是最常用的 Java 集合了，我们都知道它的一些特性：有序，元素可重复，支持随机访问，但是插入和删除元素的效率不如 LinkedList，它的底层是实现原理是什么样的呢？从源码来学习一下吧!</p><a id="more"></a><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><pre><code class="hljs java"><span class="hljs-comment">/** * 默认初始容量为 10 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;<span class="hljs-comment">/** * 一个静态的空数组 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="hljs-comment">/** * 静态的使用默认容量大小的空数组 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="hljs-comment">/** * 存放数据对象的数组 */</span><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span><span class="hljs-comment">/** * ArrayList 大小，即包含元素的数量 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<span class="hljs-comment">/** * 要分配的最大数组大小 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="hljs-number">8</span>;</code></pre><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><pre><code class="hljs java"><span class="hljs-comment">/** * 默认构造方法，创建一个初始容量为 10 的空列表 */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;<span class="hljs-comment">/** * 根据传入的容量大小，创建相应的 list */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal Capacity: "</span>+ initialCapacity);    &#125;&#125;<span class="hljs-comment">/** * 传入一个集合作为参数，生成列表 */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    elementData = c.toArray();    <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)            <span class="hljs-title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// replace with empty array.</span>        <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;    &#125;&#125;</code></pre><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>ArrayList 的扩容比较简单</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;    <span class="hljs-comment">// 扩容后的容量为原来的 1.5 倍</span>    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-comment">// 检查新容量是否大于最小需要容量，若还小，就把最小需要容量当作数组的新容量</span>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)        newCapacity = minCapacity;      <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)        newCapacity = hugeCapacity(minCapacity);    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span>    elementData = Arrays.copyOf(elementData, newCapacity);&#125;<span class="hljs-comment">// 判断新数组需要的最小容量和最大数组容量之间的关系</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?        Integer.MAX_VALUE :        MAX_ARRAY_SIZE;&#125;</code></pre><h4 id="添加元素-Add"><a href="#添加元素-Add" class="headerlink" title="添加元素 Add"></a>添加元素 Add</h4><p>构造函数只是创建了一个空的数组，在加入第一个元素的时候，才会对数组进行初始化。</p><p>当加入第一个元素的时候，size 是等于默认值 0 的，然后 add 内部调用了 <code>ensureCapacityInternal</code> 方法，参数为  1，该方法内部调用 <code>ensureExplicitCapacity</code> 方法，另外 <code>calculateCapacity</code> 方法将计算出数组的最小容量为 10，所以在 <code>ensureExplicitCapacity</code> 方法内部会调用扩容方法，创建初始化的数组。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;  <span class="hljs-comment">// 在添加元素之前，先判断添加元素是否超过数组的容量</span>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>    elementData[size++] = e;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;<span class="hljs-comment">/*  * 第一次向数组中添加元素的时候，如果是调用默认的无参构造方法，就会返回 10, 因为此时传入的 minCapcity 是 1 * 如果不是第一次向数组中添加元素，返回 minCapacity， 它是实际数组大小 + 1 */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;      <span class="hljs-comment">// 获取默认的容量和传入参数的较大值</span>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);    &#125;    <span class="hljs-keyword">return</span> minCapacity;&#125;<span class="hljs-comment">/** * 比较所需要的数组长度与实际数组的长度，如果所需要的数组长度更大，需要进行扩容 * 在这里，当第一次向数组中加入元素的时候，minCapacity = 10， 实际数组长度为 0 ，所以需要扩容 * 即，创建一个容量为 10 的数组 * 当加入第二个元素的时候，minCapacity = 2, 此时不满足 if 里面的条件，不会扩容 */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    modCount++;  <span class="hljs-comment">// 修改次数自增1</span>    <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)        grow(minCapacity);&#125;<span class="hljs-comment">/** * 将新的数据内容存放到数组的指定位置（index）上, 这里使指定位置以后的元素都向后挪动一位 */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;    rangeCheckForAdd(index);    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>  <span class="hljs-comment">// 参数列表：原数组，原数组的起始位置，目标数组，目标数组的起始位置，要复制数组的长度</span>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,                     size - index);    elementData[index] = element;    size++;&#125;</code></pre><h4 id="获取元素-Get"><a href="#获取元素-Get" class="headerlink" title="获取元素 Get"></a>获取元素 Get</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    rangeCheck(index);  <span class="hljs-comment">// 检测要获取的元素的 index 是否在 size 范围内</span>    <span class="hljs-keyword">return</span> elementData(index);  <span class="hljs-comment">// 返回数组中的元素</span>&#125;</code></pre><h4 id="替换元素-Set"><a href="#替换元素-Set" class="headerlink" title="替换元素 Set"></a>替换元素 Set</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;    rangeCheck(index);  <span class="hljs-comment">// 检测 index 是否合法</span>    E oldValue = elementData(index);    elementData[index] = element; <span class="hljs-comment">// 将原来 index 位置的值替换为新值</span>    <span class="hljs-keyword">return</span> oldValue;<span class="hljs-comment">// 返回旧值给用户</span>&#125;</code></pre><h4 id="删除元素-Remove"><a href="#删除元素-Remove" class="headerlink" title="删除元素 Remove"></a>删除元素 Remove</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    rangeCheck(index);   <span class="hljs-comment">// 检查 index 合法性</span>    modCount++;  <span class="hljs-comment">// 修改次数加1</span>    E oldValue = elementData(index); <span class="hljs-comment">// 用来返回要删除的值给用户</span>    <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">// 将要删除元素后面的元素往前移一位</span>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,                         numMoved);    elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 数组最后的位置置为 null，让 GC 回收</span>    <span class="hljs-keyword">return</span> oldValue;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
      <tag>ArrayList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flink 学习笔记（五）Sink</title>
    <link href="/2020/03/27/Flink-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89Sink/"/>
    <url>/2020/03/27/Flink-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89Sink/</url>
    
    <content type="html"><![CDATA[<h3 id="Flink-学习笔记（五）Sink"><a href="#Flink-学习笔记（五）Sink" class="headerlink" title="Flink 学习笔记（五）Sink"></a>Flink 学习笔记（五）Sink</h3><p>Data sinks 消费 DataStreams 并将其转发到文件，套接字，外部系统或打印出来。 Flink带有多种内置输出格式，这些格式封装在DataStreams的操作后面：</p><h4 id="1-打印结果"><a href="#1-打印结果" class="headerlink" title="1. 打印结果"></a>1. 打印结果</h4><pre><code class="hljs java">print() / printToErr() <span class="hljs-comment">// 在标准输出/标准错误流上打印每个元素的 toString() 值。</span></code></pre><a id="more"></a><h4 id="2-输出文件"><a href="#2-输出文件" class="headerlink" title="2. 输出文件"></a>2. 输出文件</h4><pre><code class="hljs java">writeAsText() <span class="hljs-comment">// TextOutputFormat  text 文件格式</span>writeAsCsv(...)  <span class="hljs-comment">// CsvOutputFormat csv 文件格式</span>writeUsingOutputFormat()  <span class="hljs-comment">// FileOutputFormat</span></code></pre><h4 id="3-写入-socket"><a href="#3-写入-socket" class="headerlink" title="3. 写入 socket"></a>3. 写入 socket</h4><pre><code class="hljs java">writeToSocket()  <span class="hljs-comment">// 根据 SerializationSchema 写到 socket</span></code></pre><h4 id="4-自定义的："><a href="#4-自定义的：" class="headerlink" title="4. 自定义的："></a>4. 自定义的：</h4><pre><code class="hljs java">addSink() <span class="hljs-comment">// 自定义 sink</span></code></pre><p>一般常用自定义的 sink</p><h4 id="Flink-Kafka-Producer"><a href="#Flink-Kafka-Producer" class="headerlink" title="Flink Kafka Producer"></a>Flink Kafka Producer</h4><pre><code class="hljs java">DataStream&lt;String&gt; stream = ...;FlinkKafkaProducer011&lt;String&gt; myProducer = <span class="hljs-keyword">new</span> FlinkKafkaProducer011&lt;String&gt;(        <span class="hljs-string">"localhost:9092"</span>,            <span class="hljs-comment">// broker list</span>        <span class="hljs-string">"my-topic"</span>,                  <span class="hljs-comment">// target topic</span>        <span class="hljs-keyword">new</span> SimpleStringSchema());   <span class="hljs-comment">// serialization schema</span><span class="hljs-comment">// this method is not available for earlier Kafka versions</span>myProducer.setWriteTimestampToKafka(<span class="hljs-keyword">true</span>);stream.addSink(myProducer);<span class="hljs-comment">// 可以自定义</span>Providing custom propertiesCustom partitionerAdvanced serialization schema</code></pre><p><img src="/2020/03/27/Flink-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89Sink/sinkfunction.png" srcset="/img/loading.gif" alt="sink function"></p><p>实现自定义的 function 可以继承 RichSinkFunction，重写其中的方法</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>DataStream上的 <code>write*()</code> 方法主要用于调试目的。 没有参与 Flink 的检查点，这意味着这些功能通常具有“至少一次”（at-least-once）的语义。 刷新到目标系统的数据取决于 OutputFormat 的实现。 这意味着并非所有发送到OutputFormat 的元素都立即显示在目标系统中。 同样，在失败的情况下，这些记录可能会丢失。</p><p>为了将流可靠，准确地一次传输到文件系统中，请使用 flink-connector-filesystem。 此外，通过<code>.addSink（...）</code>方法进行的自定义实现可以参与 Flink 一次精确语义的检查点。</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flink</tag>
      
      <tag>流处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flink 学习笔记（四）Transformation</title>
    <link href="/2020/03/26/Flink-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Transformation/"/>
    <url>/2020/03/26/Flink-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Transformation/</url>
    
    <content type="html"><![CDATA[<h3 id="Flink-学习笔记（四）Transformation"><a href="#Flink-学习笔记（四）Transformation" class="headerlink" title="Flink 学习笔记（四）Transformation"></a>Flink 学习笔记（四）Transformation</h3><p>算子将一个或多个数据流转换为一个新的数据流</p><p>一下是常用的算子 API，不涉及具体的原理和理论。</p><a id="more"></a><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>DataStream → DataStream        接收一个元素输出一个元素</p><pre><code class="hljs java"><span class="hljs-comment">// 将输入的数变为原来的 2 倍</span>dataStream.map(<span class="hljs-keyword">new</span> MapFunction&lt;String, Integer&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">map</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> Integer.valueOf(s) * <span class="hljs-number">2</span>;    &#125;&#125;);<span class="hljs-comment">// Java8 lambda 表达式</span>dataStream.map((MapFunction&lt;String, Integer&gt;) s -&gt; Integer.valueOf(s) * <span class="hljs-number">2</span>);</code></pre><h4 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h4><p>DataStream → DataStream        接收一个元素，可以输出0个，1个或多个元素</p><pre><code class="hljs java"><span class="hljs-comment">// 将句子根据空格分割成单词</span>dataStream.flatMap(<span class="hljs-keyword">new</span> FlatMapFunction&lt;String, String&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatMap</span><span class="hljs-params">(String s, Collector&lt;String&gt; collector)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        String[] words = s.split(<span class="hljs-string">" "</span>);        <span class="hljs-keyword">for</span> (String word : words) &#123;            collector.collect(word);        &#125;    &#125;&#125;);</code></pre><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>DataStream → DataStream</p><p>输出符合判断条件的结果</p><pre><code class="hljs java"><span class="hljs-comment">// 输出以 “hello” 开头的字符串</span>dataStream.filter(<span class="hljs-keyword">new</span> FilterFunction&lt;String&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">filter</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> s.startsWith(<span class="hljs-string">"hello"</span>);    &#125;&#125;);</code></pre><h4 id="KeyBy"><a href="#KeyBy" class="headerlink" title="KeyBy"></a>KeyBy</h4><p>DataStream → KeyedStream</p><p>对数据流进行逻辑上的分区，内部是通过 hash 进行分区的，返回 <em>KeyedStream</em></p><pre><code class="hljs java">dataStream        .flatMap(<span class="hljs-keyword">new</span> Splitter())   <span class="hljs-comment">// 对输入的字符串进行切分</span>        .keyBy(<span class="hljs-number">0</span>);<span class="hljs-comment">// 根据第一个位置进行分组</span></code></pre><h4 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h4><p>KeyedStream → DataStream  接收 keyedStream，产生一个新的数据流</p><pre><code class="hljs java"><span class="hljs-comment">// 一个可能不是很恰当的例子</span><span class="hljs-comment">// 统计相同 word 的数量</span>keyedStream.reduce(<span class="hljs-keyword">new</span> ReduceFunction&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="hljs-title">reduce</span><span class="hljs-params">(Tuple2&lt;String, Integer&gt; t1, Tuple2&lt;String, Integer&gt; t2)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Tuple2&lt;&gt;(t1._1, t1._2 + t2._2);            &#125;&#125;);</code></pre><h4 id="Fold"><a href="#Fold" class="headerlink" title="Fold"></a>Fold</h4><p>KeyedStream → DataStream 输入也是 keyedStream</p><pre><code class="hljs java"><span class="hljs-comment">// 用在序列 (1,2,3,4,5)上, 产生序列 "start-1", "start-1-2", "start-1-2-3", ...</span>DataStream&lt;String&gt; result =  keyedStream.fold(<span class="hljs-string">"start"</span>, <span class="hljs-keyword">new</span> FoldFunction&lt;Integer, String&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">fold</span><span class="hljs-params">(String current, Integer value)</span> </span>&#123;        <span class="hljs-keyword">return</span> current + <span class="hljs-string">"-"</span> + value;    &#125;  &#125;);</code></pre><h4 id="Aggregations"><a href="#Aggregations" class="headerlink" title="Aggregations"></a>Aggregations</h4><p>KeyedStream → DataStream</p><p>有 sum，min（返回最小值）, minBy（返回值最小的元素）, max, maxBy</p><h4 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h4><p>KeyedStream → WindowedStream</p><p>可以定义在以有分区的 keyedStream 上，可以根据一些特征再对 key 分组</p><pre><code class="hljs java"><span class="hljs-comment">// 时间窗口</span>keyedStream.window(TumblingEventTimeWindows.of(Time.seconds(<span class="hljs-number">5</span>)));</code></pre><h5 id="WindowAll"><a href="#WindowAll" class="headerlink" title="WindowAll"></a>WindowAll</h5><p>DataStream → AllWindowedStream</p><p>允许对常规数据流进行分组，非并行的数据转换</p><h5 id="Window-Apply"><a href="#Window-Apply" class="headerlink" title="Window Apply"></a>Window Apply</h5><p>WindowedStream → DataStream   将某个操作应用于整个窗口<br>AllWindowedStream → DataStream</p><h5 id="Window-Reduce"><a href="#Window-Reduce" class="headerlink" title="Window Reduce"></a>Window Reduce</h5><p>WindowedStream → DataStream  在 window 中应用 reduce</p><h5 id="Window-Fold"><a href="#Window-Fold" class="headerlink" title="Window Fold"></a>Window Fold</h5><p>WindowedStream → DataStream 在 window 中应用 fold</p><h5 id="Aggregations-on-windows"><a href="#Aggregations-on-windows" class="headerlink" title="Aggregations on windows"></a>Aggregations on windows</h5><p>WindowedStream → DataStream 在 window 中做聚合操作</p><h4 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h4><p>DataStream* → DataStream 合并两个或多个数据流，创建一个包含所有流中所有元素的新流。</p><h4 id="Window-Join"><a href="#Window-Join" class="headerlink" title="Window Join"></a>Window Join</h4><p>DataStream, DataStream → DataStream  根据 key 将同一 window 的两个流合并成一个流</p><pre><code class="hljs java">dataStream.join(otherStream)    .where(&lt;key selector&gt;).equalTo(&lt;key selector&gt;)    .window(TumblingEventTimeWindows.of(Time.seconds(<span class="hljs-number">3</span>)))    .apply (<span class="hljs-keyword">new</span> JoinFunction () &#123;...&#125;);</code></pre><h4 id="Interval-Join"><a href="#Interval-Join" class="headerlink" title="Interval Join"></a>Interval Join</h4><p>KeyedStream, KeyedStream → DataStream 将给定时间段内的两个 keyedstream 根据同一个 key 合并</p><h4 id="Window-CoGroup"><a href="#Window-CoGroup" class="headerlink" title="Window CoGroup"></a>Window CoGroup</h4><p>DataStream, DataStream → DataStream  根据 key 对同一个 window 的普通流进行合并</p><h4 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h4><p>DataStream, DataStream → ConnectedStreams </p><p>“连接”两个保留其类型的数据流。 连接允许两个流之间共享状态。</p><pre><code class="hljs java">DataStream&lt;Integer&gt; someStream = <span class="hljs-comment">//...</span>DataStream&lt;String&gt; otherStream = <span class="hljs-comment">//...</span>ConnectedStreams&lt;Integer, String&gt; connectedStreams = someStream.connect(otherStream);</code></pre><h4 id="CoMap-CoFlatMap"><a href="#CoMap-CoFlatMap" class="headerlink" title="CoMap, CoFlatMap"></a>CoMap, CoFlatMap</h4><p>ConnectedStreams → DataStream  connected 数据流上的 map 和 flatmap</p><h4 id="Split"><a href="#Split" class="headerlink" title="Split"></a>Split</h4><p>DataStream → SplitStream  按条件将一个数据流分成多个流</p><pre><code class="hljs java">SplitStream&lt;Integer&gt; split = someDataStream.split(<span class="hljs-keyword">new</span> OutputSelector&lt;Integer&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterable&lt;String&gt; <span class="hljs-title">select</span><span class="hljs-params">(Integer value)</span> </span>&#123;        List&lt;String&gt; output = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();        <span class="hljs-keyword">if</span> (value % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;            output.add(<span class="hljs-string">"even"</span>);  <span class="hljs-comment">// 偶数</span>        &#125;        <span class="hljs-keyword">else</span> &#123;            output.add(<span class="hljs-string">"odd"</span>);<span class="hljs-comment">// 奇数</span>        &#125;        <span class="hljs-keyword">return</span> output;    &#125;&#125;);</code></pre><h4 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h4><p>SplitStream → DataStream  从上一步的 split 流中选择一个或多个流</p><pre><code class="hljs java">DataStream&lt;Integer&gt; even = split.select(<span class="hljs-string">"even"</span>);DataStream&lt;Integer&gt; odd = split.select(<span class="hljs-string">"odd"</span>);DataStream&lt;Integer&gt; all = split.select(<span class="hljs-string">"even"</span>,<span class="hljs-string">"odd"</span>);</code></pre><h4 id="Iterate"><a href="#Iterate" class="headerlink" title="Iterate"></a>Iterate</h4><p>DataStream → IterativeStream → DataStream 通过将一个算子的输出重定向到某个先前的算子，在流中创建“反馈”循环。</p><h4 id="Extract-Timestamps"><a href="#Extract-Timestamps" class="headerlink" title="Extract Timestamps"></a>Extract Timestamps</h4><p>DataStream → DataStream  从记录中提取时间戳</p><h4 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h4><p>DataStream → DataStream 从事件流中选择属性子集，并仅将所选元素发送到下一个处理流</p><pre><code class="hljs java">DataStream&lt;Tuple3&lt;Integer, Double, String&gt;&gt; in = <span class="hljs-comment">// [...]</span>DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; out = in.project(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>);</code></pre>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flink</tag>
      
      <tag>流处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flink 学习笔记(三) DataSource</title>
    <link href="/2020/03/26/Flink-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89-DataSource/"/>
    <url>/2020/03/26/Flink-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89-DataSource/</url>
    
    <content type="html"><![CDATA[<h2 id="Flink-学习笔记-三-DataSource"><a href="#Flink-学习笔记-三-DataSource" class="headerlink" title="Flink 学习笔记(三) DataSource"></a>Flink 学习笔记(三) DataSource</h2><h3 id="1-基于集合"><a href="#1-基于集合" class="headerlink" title="1. 基于集合"></a>1. 基于集合</h3><pre><code class="hljs java">fromCollection(Collection)  <span class="hljs-comment">// 从 Java Java.util.Collection 创建数据流</span>fromCollection(Iterator, Class) <span class="hljs-comment">// 从迭代器创建</span>fromElements(T ...)<span class="hljs-comment">// 从给定的对象序列</span>fromParallelCollection(SplittableIterator, Class) <span class="hljs-comment">// 从一个迭代器中创建并行数据流</span>generateSequence(from, to)  <span class="hljs-comment">// 创建一个生成指定区间范围内的数字序列的并行数据流</span></code></pre><a id="more"></a><h3 id="2-基于文件"><a href="#2-基于文件" class="headerlink" title="2. 基于文件"></a>2. 基于文件</h3><pre><code class="hljs java">readTextFile(path) <span class="hljs-comment">// 读取文本文件，返回字符串</span>readFile(fileInputFormat, path) <span class="hljs-comment">// 读取指定输入格式的文件</span><span class="hljs-comment">/** * 根据给定的 fileInputFormat 和读取路径读取文件。 * 根据提供的 watchType，这个 source 可以定期（每隔 interval 毫秒）监测给定路径的新数据 *（FileProcessingMode.PROCESS_CONTINUOUSLY），或者处理一次路径对应文件的数据并退出 *（FileProcessingMode.PROCESS_ONCE） */</span>readFile(fileInputFormat, path, watchType, interval, pathFilter, typeInfo)</code></pre><h3 id="3-基于-Socket"><a href="#3-基于-Socket" class="headerlink" title="3. 基于 Socket"></a>3. 基于 Socket</h3><pre><code class="hljs JAVA">socketTextStream(String hostname, <span class="hljs-keyword">int</span> port) <span class="hljs-comment">// 从 socket 读取,元素可以用分隔符切分。</span></code></pre><p>Example:<br><pre><code class="hljs java">DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; sum = environment  .socketTextStream(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9000</span>)        .flatMap(<span class="hljs-keyword">new</span> Splitter())        .keyBy(<span class="hljs-number">0</span>)  <span class="hljs-comment">// 根据第一个字段做聚合</span>        .timeWindow(Time.seconds(<span class="hljs-number">5</span>))  <span class="hljs-comment">// 窗口大小</span>        .sum(<span class="hljs-number">1</span>);<span class="hljs-comment">// 对第二个字段求和</span></code></pre></p><h3 id="4-自定义"><a href="#4-自定义" class="headerlink" title="4. 自定义"></a>4. 自定义</h3><p>自定义 source，可以从 Kafka 等读取数据<br>大多数场景下都会用到自定义的情况</p><h4 id="Flink-Kafka-Source"><a href="#Flink-Kafka-Source" class="headerlink" title="Flink Kafka Source"></a>Flink Kafka Source</h4><p>基本使用方式：</p><pre><code class="hljs java">Properties properties = <span class="hljs-keyword">new</span> Properties();properties.setProperty(<span class="hljs-string">"bootstrap.servers"</span>, <span class="hljs-string">"localhost:9092"</span>);<span class="hljs-comment">// only required for Kafka 0.8</span>properties.setProperty(<span class="hljs-string">"zookeeper.connect"</span>, <span class="hljs-string">"localhost:2181"</span>);properties.setProperty(<span class="hljs-string">"group.id"</span>, <span class="hljs-string">"test"</span>);DataStream&lt;String&gt; stream = env.addSource(<span class="hljs-keyword">new</span> FlinkKafkaConsumer08&lt;&gt;(    <span class="hljs-string">"topic"</span>,   <span class="hljs-comment">// 消息的 topic</span>    <span class="hljs-comment">// DeserializationSchema/KafkaDeserializationSchema,反序列化 Kafka 中的数据</span>    <span class="hljs-keyword">new</span> SimpleStringSchema(),      <span class="hljs-comment">// Kafka 消费者的属性</span>    properties  ));<span class="hljs-comment">/* Kafka 消费者的属性 * bootstrap.servers” 逗号分隔的 brokers 列表 * “zookeeper.connect” 逗号分隔的 Zookeeper 服务器 (only required for Kafka 0.8) * “group.id” consumer group id */</span></code></pre><p>Kafka 相关：</p><ul><li><p><strong>Topic</strong>：属于特定类别的消息流称为主题。可以理解为消息的标签🏷，订阅了该 topic 的消费者会接收到所有该类消息。</p></li><li><p><strong>Producer：消息发送者</strong>。负责将消息发送到 Kafka 集群的某一个topic中。</p></li><li><p><strong>Consumer：消息消费者</strong>。订阅topic，获取消息。</p></li><li><p><strong>Broker：Kafka 集群中的每一台服务器</strong>。Kafka是一个分布式集群，其中每一台服务器都叫做Broker。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flink</tag>
      
      <tag>流处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为云服务器 Flink 环境搭建</title>
    <link href="/2020/03/26/%E5%8D%8E%E4%B8%BA%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-Flink-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/03/26/%E5%8D%8E%E4%B8%BA%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-Flink-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="华为云服务器-Flink-环境搭建"><a href="#华为云服务器-Flink-环境搭建" class="headerlink" title="华为云服务器 Flink 环境搭建"></a>华为云服务器 Flink 环境搭建</h3><h4 id="下载及安装过程"><a href="#下载及安装过程" class="headerlink" title="下载及安装过程"></a>下载及安装过程</h4><p>参考<a href="/2020/03/22/%E5%8D%8E%E4%B8%BA%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" title="华为云服务器大数据环境配置">华为云服务器大数据环境配置</a></p><p>可以找个镜像站，apache 太慢了。</p><a id="more"></a><h4 id="设置-Flink-的环境变量"><a href="#设置-Flink-的环境变量" class="headerlink" title="设置 Flink 的环境变量"></a>设置 Flink 的环境变量</h4><pre><code class="hljs bash">vi ~/.bashrc<span class="hljs-comment">## 追加下面内容</span><span class="hljs-built_in">source</span> ~/.bashrc</code></pre><pre><code class="hljs bash"><span class="hljs-built_in">export</span> FLINK_HOME=/usr/<span class="hljs-built_in">local</span>/flink  <span class="hljs-comment">## 你自己的解压目录</span><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$FLINK_HOME</span>/bin:<span class="hljs-variable">$PATH</span></code></pre><h4 id="修改FLink配置文件"><a href="#修改FLink配置文件" class="headerlink" title="修改FLink配置文件"></a>修改FLink配置文件</h4><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/flink/conf</code></pre><p>修改 masters 和 slaves。</p><p>将 masters 文件中的 localhost 替换为对应的IP地址。</p><pre><code class="hljs bash">vim masterslocalhost:8081 <span class="hljs-comment"># 替换为对应弹性公网 IP 地址</span></code></pre><p>将 slaves 文件中的 localhost 替换为对应的IP地址。</p><pre><code class="hljs bash">vim slaveslocalhost   <span class="hljs-comment"># 替换为对应弹性公网 IP 地址</span></code></pre><h4 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h4><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/flink/bin/./start-cluster.sh</code></pre><p>在浏览器输入：<a href="http://ip:8081" target="_blank" rel="noopener">http://ip:8081</a></p><p><img src="/2020/03/26/%E5%8D%8E%E4%B8%BA%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-Flink-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/flink.png" srcset="/img/loading.gif" alt="flink"></p><p>一起玩耍吧！🤗</p>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap 源码阅读</title>
    <link href="/2020/03/26/HashMap-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2020/03/26/HashMap-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="HashMap-源码阅读笔记"><a href="#HashMap-源码阅读笔记" class="headerlink" title="HashMap 源码阅读笔记"></a>HashMap 源码阅读笔记</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>java.util.HashMap<K,V>  是我们常用的一个集合类，看看源码吧！</K,V></p><p>HashMap 允许 key 和 value 为 null，不保证元素的顺序。HashMap 的 get 和 put 可以实现常数级别的复杂度。 HashMap 的初始容量 capacity 和 负载因子 load factor 对其性能的影响比较大。当 Entry 的数量超过 capacity * load factor 时，哈希表将会被 rehash（内部的数据结构重建）</p><p>另外 HashMap 非线程安全，不过可以借助 <code>Collections.synchroniedMap</code> 进行包装。</p><pre><code class="hljs java">Map m = Collections.synchronizedMap(<span class="hljs-keyword">new</span> HashMap(...));</code></pre><a id="more"></a><h4 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h4><h4 id="一、静态成员变量"><a href="#一、静态成员变量" class="headerlink" title="一、静态成员变量"></a>一、静态成员变量</h4><pre><code class="hljs java"><span class="hljs-comment">/** * 默认的初始容量 16 - 必须是 2 的幂次  */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><span class="hljs-comment">/** * 最大容量 - 必须是 2 的幂次  * MUST be a power of two &lt;= 1&lt;&lt;30. */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<span class="hljs-comment">/** * 负载因子，当 Entry 数量达到 容量 * 负载因子 时， 则扩充当前 HashMap 的容量为当前的 2 倍 */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<span class="hljs-comment">/** * 将链表转为红黑树的阈值 */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<span class="hljs-comment">/** * 红黑树转为链表的阈值 */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<span class="hljs-comment">/** * HashMap 可以转为红黑树的最小容量，如果达不到该值，首先会选择扩容 */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;</code></pre><h4 id="相关思考："><a href="#相关思考：" class="headerlink" title="相关思考："></a>相关思考：</h4><ol><li><p>容量为什么是 2 的幂次？</p><p>这就要从 hashMap 元素 put 的时候说起了，要找到放入新元素的位置，我们一般想到的思路是将 key 的 hash 值对 hash table 的长度 n 取余，但是%运算的效率比较低，于是在这里引入位运算，通过 <code>hash &amp; (n-1)</code> 来获得新元素的索引位置，只有当 n 为 2 的次幂时，才满足一个公式：<code>(n - 1) &amp; hash = hash % n</code>。（注意：这里 hash 值不是 key 的 hashCode，后面会解释。）</p></li><li><p>负载因子为什么是 0.75？</p><p>Java API 中解释：取 0.75 是时间和空间效率的一个权衡。较高的值会降低空间开销，但会增加查找成本。</p><p><strong>我的理解是</strong>：如果 load factor 取的比较小，比如 0.5, 那么达到容量的一半就会进行扩容，这样会频繁进行 resize 操作。而扩容时变成原来容量的两倍，还会使得使用空间和未使用空间的差值逐渐增加，空间利用率低下。  假如说 load factor 取的比较大，比如 1，那么要等到所有空间都用完了才进行扩容，put 时的时间效率就会很低。可以说 0.75 是 0.5-1.0 的一个中间值。</p><p><strong>🌻来自 StackOverFlow 的一个数学解释</strong>：</p><p>一个 bucket 空和非空的概率为 0.5，通过牛顿二项式等数学计算，得到这个 load factor 的值为log（2），约等于 0.693. 回答者说，可能小于0.75 大于等于log（2）的factor都能提供更好的性能，0.75这个数怎么来的，大概是方便计算？</p></li><li><p>为什么达到 8 转红黑树？</p><p>也是一个数学统计，根据泊松分布，在负载因子0.75（HashMap默认）的情况下，单个 hash 槽内元素个数为 8 的概率小于百万分之一；链表转红黑树的开销和冲突带来的额外开销的一个权衡；</p></li><li><p>为什么到 6 才转链表？</p><p>中间有个差值 7 可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p></li></ol><hr><p>源码继续来看😁</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;    <span class="hljs-keyword">int</span> h;    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);&#125;</code></pre><p>我们上面提到，计算元素 key 的索引位置时需要用到 hash 值，就是通过这个函数计算得到的，<strong>key 的 hashCode 右移 16 位，与自身做异或计算</strong>。实际上就是<strong>高低位异或</strong>。</p><p>✨<strong>这样做有什么好处呢？</strong></p><p>HashMap 的初始容量是16，要远小于 int 类型的范围，所以如果只是单纯的用 hashCode 取余来获取对应的 bucket 会大大增加哈希碰撞的概率，并且最坏情况下还会将 HashMap 变成一个单链表。主要是因为如果使用 hashCode 取余，那么相当于<strong>参与运算的只有hashCode的低位</strong>，高位是没有起到任何作用的，所以为了让 hashCode 高位也参与运算，进一步降低 hash 碰撞的概率，使得数据分布更平均，就采取了这样的优化策略。</p><h4 id="二、构造方法"><a href="#二、构造方法" class="headerlink" title="二、构造方法"></a>二、构造方法</h4><p>HashMap 在创建的时候，如果不传入初始容量，会默认建立一个 16 的 hash table，所以当需要的 HashMap 存储的元素比较大的时候，建议传入容量大小，避免频繁 resize。</p><p>另外当使用默认构造方法的时候，只是将 loadfactor 设为了 0.75，这里的 threshload 仍然为 0</p><p>而当使用后面两个构造方法的时候，初始化 loadfactor 为设定值，另外会将 hash table 的 threshold 设为大于传入容量值的最小的 2 的次幂（tableSizeFor 方法）</p><pre><code class="hljs java"><span class="hljs-comment">// 空参构造，使用初始容量 16，load factor 0.75</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span>&#125;<span class="hljs-comment">// 可以传入自定义容量的大小</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;    <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;<span class="hljs-comment">// 可以设置容量大小和 load factor</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal initial capacity: "</span> +                                           initialCapacity);    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal load factor: "</span> +                                           loadFactor);    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;    <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);&#125;<span class="hljs-comment">// 将另一个 Map 中的元素拷贝一份到自己的存储结构中</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;    putMapEntries(m, <span class="hljs-keyword">false</span>);&#125;<span class="hljs-comment">/** * 这个函数又是干什么的呢？ * 当用户传入的初始容量不是 2 的幂次时，进行 threshold 的调整 * 找到大于传入容量值的最小的那个 2 的幂次 */</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;&#125;</code></pre><h4 id="三、查找"><a href="#三、查找" class="headerlink" title="三、查找"></a>三、查找</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;    Node&lt;K,V&gt; e;    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;&#125;<span class="hljs-comment">/** * 查找的时候先判断 hash 值相等（hashCode）相等，再判断 equals 相等，提高效率 */</span><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-keyword">int</span> n; K k;  <span class="hljs-comment">// 定位 key 在 hash table 中的位置</span>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span>            ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))            <span class="hljs-keyword">return</span> first;      <span class="hljs-comment">// 链表或红黑树中查找</span>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;          <span class="hljs-comment">// 如果该节点是 TreeNode 类型，要去红黑树中查找</span>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            <span class="hljs-comment">// 查找链表</span>          <span class="hljs-keyword">do</span> &#123;                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                    <span class="hljs-keyword">return</span> e;            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><h4 id="四、插入-Put"><a href="#四、插入-Put" class="headerlink" title="四、插入 Put"></a>四、插入 Put</h4><p>hash table 的初始化是在 put 中通过调用 resize() 完成的</p><pre><code class="hljs JAVA"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);&#125;<span class="hljs-comment">/** * <span class="hljs-doctag">@return</span> previous value, or null if none */</span><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;    <span class="hljs-comment">// 若 hash table 为空，通过 resize 的方式建立 hash table</span>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)        n = (tab = resize()).length;    <span class="hljs-comment">// 计算当前要插入节点的索引位置，如果位置空，创建一个新的节点, 放入hash table</span>  <span class="hljs-comment">// 此时 p = tab[index] 即 index 位置的头结点</span>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);      <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 索引位置有元素了，产生 hash 冲突</span>        Node&lt;K,V&gt; e; K k;            <span class="hljs-comment">// 如果插入节点 key 值以及 hash 值等于链表中的第一个键值对节点时，则将 e 指向该键值对</span>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))            e = p;            <span class="hljs-comment">// 如果 p 是 TreeNode 类型，调用红黑树的插入方法</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);            <span class="hljs-comment">// 链表插入</span>        <span class="hljs-keyword">else</span> &#123;                      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;              <span class="hljs-comment">// 遍历链表到达链表尾, 即链表中不包含该节点，插入节点</span>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);                                    <span class="hljs-comment">// 当链表的长度大于等于链表转红黑树的阈值，调整为红黑树</span>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>                        treeifyBin(tab, hash);                    <span class="hljs-keyword">break</span>;                &#125;              <span class="hljs-comment">// 链表中包含该节点，停止遍历</span>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                    <span class="hljs-keyword">break</span>;                p = e;            &#125;        &#125;            <span class="hljs-comment">// 判断要插入的键值对是否存在 HashMap 中</span>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>            V oldValue = e.value;          <span class="hljs-comment">// onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值</span>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)                e.value = value;            afterNodeAccess(e);            <span class="hljs-keyword">return</span> oldValue;        &#125;    &#125;    ++modCount;  <span class="hljs-comment">// hash table 中的元素超过阈值，扩容</span>    <span class="hljs-keyword">if</span> (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p>总结：</p><p>hashtable 为空，调用 resize，创建 hash table</p><p>计算出的索引位置没有元素，直接创建一个新的节点</p><p>如果发生了 hash 冲突：</p><p>key 是否存在：</p><ul><li>若存在直接修改旧值，进行覆盖</li><li>不存在，判断该节点是链表中的元素还是红黑树：<ul><li>链表，则插入链表尾部，当链表的长度大于调整阈值时，将链表转成红黑树</li><li>红黑树，执行红黑树的操作</li></ul></li></ul><p>若 hash table 中的元素超过阈值，进行扩容。</p><p><img src="/2020/03/26/HashMap-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/hashmap.png" srcset="/img/loading.gif" alt="hashMap 插入元素流程"> </p><p>之前看过的一张图，比较清楚，链接找不到了，望作者原谅。</p><h4 id="五、扩容"><a href="#五、扩容" class="headerlink" title="五、扩容"></a>五、扩容</h4><p>当 HashMap 中的键值对数量超过 <code>hash table 容量 * load factor</code>时，进行扩容。</p><p>HashMap 按当前容量的 2 倍进行扩容，阈值也变为原来的 2 倍（如果计算过程中，阈值溢出归零，则按阈值公式重新计算）。扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去。</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab = table;  <span class="hljs-comment">// hash table 的长度</span>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;    <span class="hljs-keyword">int</span> oldThr = threshold;    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;    <span class="hljs-comment">// hash table 已经初始化过了</span>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-comment">// 当 table 的容量超过最大值，不再进行扩容</span>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span> oldTab;        &#125;      <span class="hljs-comment">// 新的容量为旧容量左移一位（2倍），并设置新的阈值为原来的 2 倍</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>    &#125;    <span class="hljs-comment">// hash table 未初始化过并且 hash table 的阈值大于0 (此时调用的是传入初始容量的构造方法)</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>)       <span class="hljs-comment">// 在构造函数里，hash table 的初始容量是保存在 threshold 当中的</span>      <span class="hljs-comment">// 将 hash table 的容量设为构造函数中设置的初始 threshold</span>        newCap = oldThr;    <span class="hljs-comment">// hash table 未被初始化，并且 hash table 阈值为0（默认构造函数）</span>    <span class="hljs-keyword">else</span> &#123;                     <span class="hljs-comment">// 容量设定为默认容量 16</span>        newCap = DEFAULT_INITIAL_CAPACITY;            <span class="hljs-comment">// 按照公式计算 threshold = capacity * loadfactor</span>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;    <span class="hljs-comment">// 根据阈值计算公式计算新的阈值，这里是真正扩容时修改 newThreshold</span>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?                  (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);    &#125;  <span class="hljs-comment">// 将新计算得到的 threshold 赋给全局变量 threshold</span>    threshold = newThr;      <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">"rawtypes"</span>,<span class="hljs-string">"unchecked"</span>&#125;)  <span class="hljs-comment">// ============== 真正的扩容操作开始了===============</span>  <span class="hljs-comment">// 创建新的 hash table 数组，并完成数组的初始化</span>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];    table = newTab;  <span class="hljs-comment">// 如果旧的 hash table 不为空，则遍历，并将键值对映射到新的 hash table 中</span>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;                oldTab[j] = <span class="hljs-keyword">null</span>;              <span class="hljs-comment">// 该位置只有一个头节点，直接计算在新的 hash table 中的位置</span>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;                            <span class="hljs-comment">// 该位置的头节点是红黑树，要对红黑树进行拆分</span>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);                            <span class="hljs-comment">// 该位置的头节点是链表中的节点</span>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;                    Node&lt;K,V&gt; next;                  <span class="hljs-comment">// 遍历链表，并将链表节点按原顺序进行分组</span>                  <span class="hljs-comment">// 根据 key 的 hash 值与原 hash table 的容量与操作的结果是否为0分为两组</span>                    <span class="hljs-keyword">do</span> &#123;                        next = e.next;                      <span class="hljs-comment">// 节点的 hash 值和旧 hash table 容量做与操作，结果是0的 </span>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)                                loHead = e;                            <span class="hljs-keyword">else</span>                                loTail.next = e;                            loTail = e;                        &#125;                        <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)                                hiHead = e;                            <span class="hljs-keyword">else</span>                                hiTail.next = e;                            hiTail = e;                        &#125;                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);                                    <span class="hljs-comment">// 将分组后的链表映射到新 hash table 中</span>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;                        loTail.next = <span class="hljs-keyword">null</span>;                        newTab[j] = loHead;                    &#125;                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;                        hiTail.next = <span class="hljs-keyword">null</span>;                        newTab[j + oldCap] = hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> newTab;&#125;</code></pre><p>总结：</p><p>计算新的 hash table 的容量和阈值</p><p>创建新的 hash table 并进行初始化，将键值对节点重新映射到新的 hash table 里。如果节点是 TreeNode 类型，则需要拆分红黑树。如果是普通节点，则节点按原顺序进行分组。</p><p>Java 1.8 扩容的过程要比 1.7 更加复杂，是为了解决 1.7 扩容时的循环引用问题，因为 HashMap 非线程安全，扩容分组指针的指向过程在纸上画一下就很容易明白了。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>本来是想了解一下 HashMap 的扩容机制的，零零散散写了这么多，可能有一些错误的地方。</p><p>另外关于链表和红黑树的转换，扩容时红黑树的拆分还没有好好研究，下次专门总结一下吧。</p><p>历史上最长的一篇博客，哈哈，蛮不容易的，但阅读源码并分析的过程也是特别快乐~~</p><p>附上讲解的比较好的几篇博客：</p><p><a href="https://segmentfault.com/a/1190000012926722?utm_source=tag-newest#comment-area" target="_blank" rel="noopener"><a href="https://segmentfault.com/a/1190000012926722" target="_blank" rel="noopener">HashMap 源码详细分析(JDK1.8)</a></a></p><p><a href="https://blog.csdn.net/pange1991/article/details/82347284" target="_blank" rel="noopener">HashMap的扩容机制—-resize()</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven 学习小记</title>
    <link href="/2020/03/24/Maven%20%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/"/>
    <url>/2020/03/24/Maven%20%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Maven-学习小记"><a href="#Maven-学习小记" class="headerlink" title="Maven 学习小记"></a>Maven 学习小记</h2><h3 id="的分类"><a href="#的分类" class="headerlink" title="\的分类"></a>\<scope\>的分类</scope\></h3><ol><li><p>compile：<strong>默认值</strong> 表示被依赖项目需要参与当前项目的编译、测试、运行，是一个比较强的依赖。在命令行输入 <code>mvn compile</code>后，maven 就会自动帮我们下载依赖 jar，为代码生成字节码文件等。</p></li><li><p>test：依赖项目仅仅参与测试相关的工作，包括测试代码的编译和执行，不会被打包，例如：junit. 在命令行输入 mvn test 项目会新增 surefire-reports(测试报告) 、 test-classes(测试类字节码)两个文件夹</p></li><li><p>runtime：表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与 compile相比，跳过了编译而已。例如 JDBC驱动，适用运行和测试阶段</p></li><li><p>provided：在运行阶段，假定目标的容器已经提供了这个jar包，app可以直接使用容器提供的jar，所以无需打包对应的jar包了。</p></li><li><p>system：从参与度来说，和 provid ed相同，不过被依赖项不会从 maven 仓库下载，而是从本地文件系统拿。需要添加 systemPath 的属性来定义路径</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flink 学习笔记API（二）</title>
    <link href="/2020/03/24/Flink-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0API%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/03/24/Flink-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0API%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="Flink-学习笔记-API-概览（二）"><a href="#Flink-学习笔记-API-概览（二）" class="headerlink" title="Flink 学习笔记 API 概览（二）"></a>Flink 学习笔记 API 概览（二）</h2><h3 id="代码架构"><a href="#代码架构" class="headerlink" title="代码架构"></a>代码架构</h3><ol><li><p>执行环境</p><pre><code class="hljs java"><span class="hljs-comment">// 流处理环境</span>StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();  <span class="hljs-comment">// 批处理环境</span>ExecutionEnvironment env   = ExecutionEnvironment.getExecutionEnvironment();</code></pre><a id="more"></a></li><li><p>创建数据源</p><p>基于Java集合：<code>fromCollection(Collection)</code> 等</p><p>基于文件的source：<code>readTextFile(path)</code>,<code>readFile(fileInputFormat, path)</code> 等</p><p>基于网络套接字的 source：<code>socketTextStream</code></p><p>自定义的source：数据源从外部系统例如 Apache Kafka、Rabbit MQ 或者 Apache Pulsar 接收数据，然后将数据送到 Flink 程序中。</p><pre><code class="hljs java">env.addSource(<span class="hljs-keyword">new</span> XXSource());</code></pre></li><li><p>对数据执行转换操作 Transformation</p><p>Map，FlatMap，Filter，KeyBy，Reduce 等</p></li><li><p>输出结果 sink</p><p>打印结果</p><p>输出文件</p><p>写入 socket</p><p>自定义的：sink 会将 <code>DataStream</code> 写出到外部系统，例如 Apache Kafka、Cassandra 或者 AWS Kinesis 等。</p></li><li><p>运行作业</p><p>Flink 程序是懒加载的，并且只有在完全搭建好之后，才能够发布到集群上执行。 调用 <code>StreamExecutionEnvironment#execute</code> 时给任务传递一个任务名参数，就可以开始运行任务。</p><pre><code class="hljs JAVA">env.execute(<span class="hljs-string">"Socket Window WordCount"</span>);</code></pre><p><img src="/2020/03/24/Flink-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0API%EF%BC%88%E4%BA%8C%EF%BC%89/flink structure.jpg" srcset="/img/loading.gif" alt="Flink 程序与数据流结构"></p><p><a href="http://www.54tianzhisheng.cn/2018/10/13/flink-introduction/" target="_blank" rel="noopener">图片来源</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flink</tag>
      
      <tag>流处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flink 学习笔记（一）</title>
    <link href="/2020/03/24/Flink-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/03/24/Flink-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="Flink-学习笔记（一）"><a href="#Flink-学习笔记（一）" class="headerlink" title="Flink 学习笔记（一）"></a>Flink 学习笔记（一）</h2><h3 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h3><p>Apache Flink 是一个框架和分布式处理引擎，用于在<strong>无边界</strong>和<strong>有边界</strong>数据流上进行<strong>有状态</strong>的计算。Flink 能在所有常见集群环境中运行，并能以内存速度和任意规模进行计算。 </p><ul><li>有界流：批量数据 — 批量计算</li><li>无界流：流式数据 — 流计算</li></ul><a id="more"></a><p>有状态：Flink 默认有状态，状态存在本地内存中，可以减少计算时间，通过 checkpoint可以存在外部存储引擎中</p><p><img src="https://flink.apache.org/img/local-state.png" srcset="/img/loading.gif" alt="img"></p><h3 id="二、Flink-特点优势"><a href="#二、Flink-特点优势" class="headerlink" title="二、Flink 特点优势"></a>二、Flink 特点优势</h3><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ol><li>高吞吐、低延时、高性能</li><li>支持事件时间概念</li><li>支持有状态计算</li><li>支持高度灵活的窗口计算</li><li>Checkpoint 容错</li></ol><p>与其他流式框架相比都有明显优势</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flink</tag>
      
      <tag>流处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为云服务器大数据环境配置</title>
    <link href="/2020/03/22/%E5%8D%8E%E4%B8%BA%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/03/22/%E5%8D%8E%E4%B8%BA%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="华为云服务器大数据环境配置"><a href="#华为云服务器大数据环境配置" class="headerlink" title="华为云服务器大数据环境配置"></a>华为云服务器大数据环境配置</h2><p>参加牛客🐂的活动，买了一台华为云服务器，40G，可以搭建一个伪分布式的大数据环境用来学习，终于可以放过自己的小本本了，开心😍🤗</p><h3 id="一、Hadoop-伪分布式安装与配置"><a href="#一、Hadoop-伪分布式安装与配置" class="headerlink" title="一、Hadoop 伪分布式安装与配置"></a>一、Hadoop 伪分布式安装与配置</h3><p>参考博客：<a href="https://bbs.huaweicloud.com/forum/thread-27950-1-1.html" target="_blank" rel="noopener">“化鲲为鹏，我有话说”十七，基于鲲鹏搭建 Hadoop 伪分布式环境</a></p><h4 id="1-Java-环境配置"><a href="#1-Java-环境配置" class="headerlink" title="1. Java 环境配置"></a>1. Java 环境配置</h4><p>安装 JDK1.8 并配置 JAVA_HOME<br><a id="more"></a></p><pre><code class="hljs bash"><span class="hljs-comment">## bash 执行命令: </span>sudo yum install java-1.8.0-openjdk java-1.8.0-openjdk-develvi ~/.bashrc<span class="hljs-built_in">source</span> ~/.bashrc</code></pre><pre><code class="hljs bash"><span class="hljs-comment">## 在 .bashrc 中追加：</span><span class="hljs-built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk</code></pre><h4 id="2-安装-Hadoop"><a href="#2-安装-Hadoop" class="headerlink" title="2. 安装 Hadoop"></a>2. 安装 Hadoop</h4><pre><code class="hljs bash"><span class="hljs-comment">## 下载 Hadoop 2.7.7</span>wget https://archive.apache.org/dist/hadoop/common/hadoop-2.7.7/hadoop-2.7.7.tar.gz<span class="hljs-comment">## 解压至 /usr/local</span>tar -zxf hadoop-2.7.7.tar.gz -C /usr/<span class="hljs-built_in">local</span><span class="hljs-comment">## 对安装目录重命名</span><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>mv ./hadoop-2.7.7/ ./hadoop<span class="hljs-comment">## 检查Hadoop是否已经正确安装:</span><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/hadoopbin/hadoop version</code></pre><h4 id="3-设置-Hadoop-的环境变量"><a href="#3-设置-Hadoop-的环境变量" class="headerlink" title="3. 设置 Hadoop 的环境变量"></a>3. 设置 Hadoop 的环境变量</h4><pre><code class="hljs bash">vi ~/.bashrc<span class="hljs-comment">## 追加下面内容</span><span class="hljs-built_in">source</span> ~/.bashrc</code></pre><pre><code class="hljs bash"><span class="hljs-built_in">export</span> HADOOP_HOME=/usr/<span class="hljs-built_in">local</span>/hadoop<span class="hljs-built_in">export</span> HADOOP_INSTALL=<span class="hljs-variable">$HADOOP_HOME</span><span class="hljs-built_in">export</span> HADOOP_MAPRED_HOME=<span class="hljs-variable">$HADOOP_HOME</span><span class="hljs-built_in">export</span> HADOOP_COMMON_HOME=<span class="hljs-variable">$HADOOP_HOME</span><span class="hljs-built_in">export</span> HADOOP_HDFS_HOME=<span class="hljs-variable">$HADOOP_HOME</span><span class="hljs-built_in">export</span> YARN_HOME=<span class="hljs-variable">$HADOOP_HOME</span><span class="hljs-built_in">export</span> HADOOP_COMMON_LIB_NATIVE_DIR=<span class="hljs-variable">$HADOOP_HOME</span>/lib/native<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HADOOP_HOME</span>/sbin:<span class="hljs-variable">$HADOOP_HOME</span>/bin</code></pre><h4 id="4-修改-Hadoop-的配置文件"><a href="#4-修改-Hadoop-的配置文件" class="headerlink" title="4. 修改 Hadoop 的配置文件"></a>4. 修改 Hadoop 的配置文件</h4><p>/usr/local/hadoop/etc/hadoop/core-site.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.tmp.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:/usr/local/hadoop/tmp<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>location to store temporary files<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.defaultFS<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://localhost:9000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><p>/usr/local/hadoop/etc/hadoop/hdfs-site.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.replication<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.name.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/name<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.datanode.data.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/data<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><h4 id="5-格式化-NameNode"><a href="#5-格式化-NameNode" class="headerlink" title="5. 格式化 NameNode"></a>5. 格式化 NameNode</h4><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/hadoopbin/hdfs namenode -format</code></pre><p>启动 NameNode 和 DataNode 进程:</p><pre><code class="hljs bash">sbin/start-dfs.shjps <span class="hljs-comment">## 查看正在运行的进程</span></code></pre><p>关闭 Hadoop 进程：</p><pre><code class="hljs bash">/usr/<span class="hljs-built_in">local</span>/hadoop/sbin/stop-dfs.sh</code></pre><p>再起启动只需要执行下面命令：<br><pre><code class="hljs bash">/usr/<span class="hljs-built_in">local</span>/hadoop/sbin/start-dfs.sh</code></pre></p><h4 id="6-配置免密登录"><a href="#6-配置免密登录" class="headerlink" title="6. 配置免密登录"></a>6. 配置免密登录</h4><p>如果在终端中输入<code>ssh localhost</code>有返回，则已经配置好了SSH keys，如果没有，新建 SSH keys 配置：</p><pre><code class="hljs bash">$ ssh-keygen -t rsa -P <span class="hljs-string">""</span></code></pre><p>为了避免每次询问你的密码，可以授权你的公钥到本地：</p><pre><code class="hljs bash">$ cat <span class="hljs-variable">$HOME</span>/.ssh/id_rsa.pub &gt;&gt; <span class="hljs-variable">$HOME</span>/.ssh/authorized_keys</code></pre><p>现在 SSH keys 就设置成功</p><h3 id="二、HBase-安装配置"><a href="#二、HBase-安装配置" class="headerlink" title="二、HBase 安装配置"></a>二、HBase 安装配置</h3><p>HBase 的安装，看了好多教程，比较混乱，自己搞一下吧</p><h4 id="1-安装-HBase"><a href="#1-安装-HBase" class="headerlink" title="1. 安装 HBase"></a>1. 安装 HBase</h4><p>直接从官网上下载的，比较慢，可以找找国内的镜像资源</p><pre><code class="hljs bash"><span class="hljs-comment">## 下载</span>wget http://archive.apache.org/dist/hbase/2.1.0/hbase-2.1.0-bin.tar.gz<span class="hljs-comment">## 解压</span>tar -zxvf hbase-2.1.0-bin.tar.gz -C /usr/<span class="hljs-built_in">local</span>/ <span class="hljs-comment">## 对安装目录重新命名</span><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/mv ./hbase-2.1.0/ ./hbase</code></pre><h4 id="2-设置-HBase-环境"><a href="#2-设置-HBase-环境" class="headerlink" title="2. 设置 HBase 环境"></a>2. 设置 HBase 环境</h4><p>仍然在 .bashrc 中追加，并使其生效</p><pre><code class="hljs bash"><span class="hljs-comment">#hbase</span><span class="hljs-built_in">export</span> HBASE_HOME=/usr/<span class="hljs-built_in">local</span>/hbase<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HBASE_HOME</span>/bin</code></pre><h4 id="3-修改-HBase-配置文件"><a href="#3-修改-HBase-配置文件" class="headerlink" title="3. 修改 HBase 配置文件"></a>3. 修改 HBase 配置文件</h4><p>配置 conf/hbase-env.sh</p><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA_HOME=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span> <span class="hljs-built_in">export</span> HBASE_CLASSPATH=/usr/<span class="hljs-built_in">local</span>/hbase/lib<span class="hljs-built_in">export</span> HBASE_PID_DIR=/usr/<span class="hljs-built_in">local</span>/hbase/data<span class="hljs-built_in">export</span> HBASE_LOG_DIR=/usr/<span class="hljs-built_in">local</span>/hbase/logs<span class="hljs-built_in">export</span> HBASE_MANAGES_ZK=<span class="hljs-literal">true</span>  <span class="hljs-comment">## 默认使用 Hbase 自带的ZK</span></code></pre><p>配置 hbase-site.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.tmp.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/usr/local/hbase/data<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.rootdir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://localhost:9000/hbase<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.cluster.distributed<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 不开启分布式模式 --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><h4 id="4-HBase-MapReduce"><a href="#4-HBase-MapReduce" class="headerlink" title="4. HBase - MapReduce"></a>4. HBase - MapReduce</h4><p>并在 hadoop-env.sh 中配置：（注意：在 for 循环之后配）<br><pre><code class="hljs bash"><span class="hljs-built_in">export</span> HADOOP_CLASSPATH=<span class="hljs-variable">$HADOOP_CLASSPATH</span>:/usr/<span class="hljs-built_in">local</span>/hbase/lib/*</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Thread 源码阅读笔记</title>
    <link href="/2020/03/20/Java-Thread-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/20/Java-Thread-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="java-lang-Thread-源码阅读笔记"><a href="#java-lang-Thread-源码阅读笔记" class="headerlink" title="java.lang.Thread 源码阅读笔记"></a>java.lang.Thread 源码阅读笔记</h2><p>Thread 类实现了 Runnable 接口</p><p>sleep,  yield, join, wait 方法的比较</p><a id="more"></a><p>sleep() 静态方法，只对当前线程有效</p><pre><code class="hljs java"><span class="hljs-comment">/**Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds, subject to the precision and accuracy of system timers and schedulers. The thread does not lose ownership of any monitors.使当前正在执行的线程在指定的毫秒数内休眠（临时停止执行）；sleep 方法不释放 monitor 对象的占有权，即不释放锁 **/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<span class="hljs-comment">// 第一个参数为毫秒，第二个参数为纳秒</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis, <span class="hljs-keyword">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    ...&#125;</code></pre><p>yield() 静态方法，只对当前线程有效</p><pre><code class="hljs java"><span class="hljs-comment">/*** 调用 yield 方法会让当前线程交出 CPU 权限，让 CPU 去执行其他的线程。* yield 方法只能让拥有相同优先级的线程有获取 CPU 执行时间的机会。* 调用 yield 方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">yield</span><span class="hljs-params">()</span></span>;</code></pre><p>join()</p><pre><code class="hljs java"><span class="hljs-comment">/** * 等待调用join方法的线程结束，再继续执行。 * 将调用join的线程优先执行，当前正在执行的线程阻塞，直到调用join方法的线程执行完毕或者被打断 * join 通过 while 检测当前线程 isAlive()是否可用，调用 Object.wait() 进行阻塞等待。 */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">long</span> base = System.currentTimeMillis();    <span class="hljs-keyword">long</span> now = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"timeout value is negative"</span>);    &#125;    <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">while</span> (isAlive()) &#123;            wait(<span class="hljs-number">0</span>);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">while</span> (isAlive()) &#123;            <span class="hljs-keyword">long</span> delay = millis - now;            <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            wait(delay);            now = System.currentTimeMillis() - base;        &#125;    &#125;&#125;</code></pre><p>wait() 属于 Object，需要其他线程调用 notify()/notifyAll() 唤醒</p><pre><code class="hljs java"><span class="hljs-comment">/** * 线程先要获取这个对象的对象锁，当前线程必须在锁对象保持同步， * 把当前线程添加到等待队列中，随后另一个拥有同一个对象锁的线程调用object.notify()，唤醒原来等待中的线程，然后释放该锁。 synchronized (obj) &#123;    while (condition does not hold)        obj.wait(timeout);&#125; */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>wait() 属于 Object 对象，线程必须先持有对象锁，然后调用wait() 方法，释放锁，进入该对象的等待队列，直到另外一个持有该对象锁的线程调用 notify() / notifyAll() 唤醒。</p></li><li><p>sleep()： 是 Thread 类的静态方法，只对当前线程有效，线程调用 sleep() 方法，会让当前线程休眠，不释放锁，直到休眠时间过，当前线程进入就绪状态</p></li><li><p>yield() 是 Thread 类的静态方法，只对当前线程有效，线程调用 yield() 方法，让出 CPU 的使用权，让正在运行的线程进入就绪状态</p></li><li><p>join()： 调用join的线程优先执行，当前正在执行的线程阻塞，直到调用 join() 方法的线程执行完毕或者被打断，比如 A 线程正在运行，线程 B 调用 join() 方法，A 需要等待 B 执行完再执行</p><p><img src="/2020/03/20/Java-Thread-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/线程生命周期图.png" srcset="/img/loading.gif" alt="图11-4 线程生命周期图.png"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java AtomicInteger 源码阅读笔记</title>
    <link href="/2020/03/20/Java-AtomicInteger-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/20/Java-AtomicInteger-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="java-util-concurrent-AtomicInteger-源码阅读笔记"><a href="#java-util-concurrent-AtomicInteger-源码阅读笔记" class="headerlink" title="java.util.concurrent.AtomicInteger 源码阅读笔记"></a>java.util.concurrent.AtomicInteger 源码阅读笔记</h2><h3 id="CAS-机制"><a href="#CAS-机制" class="headerlink" title="CAS 机制"></a>CAS 机制</h3><p><strong>自旋锁 + Unsafe类</strong></p><p>比较当前工作内存中的值和主物理内存中的值，相同则执行规定操作，否则比较直到主内存和工作内存中的值一致为止。</p><h3 id="CAS-底层原理"><a href="#CAS-底层原理" class="headerlink" title="CAS 底层原理"></a>CAS 底层原理</h3><p>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。</p><p>UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。</p><p>value 是由 volatile 修饰的，保证了value修改的可见性，在任何时刻任何线程总能拿到该变量的最新值。</p><a id="more"></a><h3 id="CAS-的缺点"><a href="#CAS-的缺点" class="headerlink" title="CAS 的缺点"></a>CAS 的缺点</h3><h4 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1. ABA 问题"></a>1. ABA 问题</h4><p><strong>例如：</strong>线程 1 从内存中取出 A，线程 2 也从内存中取出 A，线程 2 进行了一些操作将内存中的值变成了 B，然后又改回 A，这时候线程 1 进行 CAS 操作发现内存中仍然是 A，操作成功。虽然线程 1 的 CAS 操作成功，但是整个过程就是有问题的。</p><p><strong>规避：</strong>在变量前面加版本号，AtomicStampedReference 类解决 ABA 问题，该类的 compareAndSet 方法作用是首先检查当前引用是否等于预期引用，并且当前 stamp 是否等于预期 stamp，如果全部相等，则以原子方式将该引用和该 stamp 的值设置为给定的更新值。</p><h4 id="2-循环尝试，多线程开销大"><a href="#2-循环尝试，多线程开销大" class="headerlink" title="2. 循环尝试，多线程开销大"></a>2. 循环尝试，多线程开销大</h4><h4 id="3-只能保证一个共享变量的原子操作。"><a href="#3-只能保证一个共享变量的原子操作。" class="headerlink" title="3. 只能保证一个共享变量的原子操作。"></a>3. <strong>只能保证一个共享变量的原子操作</strong>。</h4><h3 id="AtomicInteger-源码解读"><a href="#AtomicInteger-源码解读" class="headerlink" title="AtomicInteger 源码解读"></a>AtomicInteger 源码解读</h3><p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，使执行效率大为提升。</p><pre><code class="hljs java">// setup to use Unsafe.compareAndSwapInt for updatesprivate static final Unsafe unsafe = Unsafe.getUnsafe();private static final long valueOffset;static &#123;    try &#123;       //  public native long objectFieldOffset(Field var1);        valueOffset = unsafe.objectFieldOffset              (AtomicInteger.class.getDeclaredField("value"));    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125;private volatile int value;</code></pre><p>AtomicInteger.getAndIncrement() </p><pre><code class="hljs java"><span class="hljs-comment">/** * Atomically increments by one the current value.  对当前值原子加一 * * <span class="hljs-doctag">@return</span> the previous value */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">// Unsafe 类下：</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4)</span> </span>&#123;    <span class="hljs-keyword">int</span> var5;  <span class="hljs-comment">// 自旋锁，compareAndSwap，直到期望值和内存中的值一致则进行操作</span>    <span class="hljs-keyword">do</span> &#123;        var5 = <span class="hljs-keyword">this</span>.getIntVolatile(var1, var2);    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));    <span class="hljs-keyword">return</span> var5;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
      <tag>原子类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot 2.x 学习一</title>
    <link href="/2020/03/19/SpringBoot-2-x-%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
    <url>/2020/03/19/SpringBoot-2-x-%E5%AD%A6%E4%B9%A0%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot-学习记录"><a href="#SpringBoot-学习记录" class="headerlink" title="SpringBoot 学习记录"></a>SpringBoot 学习记录</h2>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 线程</title>
    <link href="/2020/03/17/ThreadLocal%20%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/03/17/ThreadLocal%20%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal-学习"><a href="#ThreadLocal-学习" class="headerlink" title="ThreadLocal 学习"></a>ThreadLocal 学习</h2><h3 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h3><p><code>java.lang.ThreadLocal&lt;T&gt;</code> 根据 Java 8 Docs 的翻译，ThreadLocal 提供线程局部变量，每一个线程都有一个独立的变量副本。ThreadLocal 一般是一个类的 private static 字段。</p><a id="more"></a><h3 id="二、ThreadLocal-原理"><a href="#二、ThreadLocal-原理" class="headerlink" title="二、ThreadLocal 原理"></a>二、ThreadLocal 原理</h3><h3 id="ThreadLocal-源码"><a href="#ThreadLocal-源码" class="headerlink" title="ThreadLocal 源码"></a>ThreadLocal 源码</h3><h4 id="1-set-方法"><a href="#1-set-方法" class="headerlink" title="1. set() 方法"></a>1. set() 方法</h4><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;  <span class="hljs-comment">// 获取当前线程</span>Thread t = Thread.currentThread();  <span class="hljs-comment">// 获取 ThreadLocalMap threadlocals</span>    ThreadLocalMap map = getMap(t);    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)        map.set(<span class="hljs-keyword">this</span>, value);  <span class="hljs-comment">// 将当前对象设置为 key，并设置 value</span>    <span class="hljs-keyword">else</span>        createMap(t, value);&#125;</code></pre><p>ThreadLocalMap 是  ThreadLocal 的静态内部类</p><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;  <span class="hljs-comment">// 继承弱引用的 Entry 类</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;        Object value;<span class="hljs-comment">// 使用 ThreadLocal 作为 key</span>        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;            <span class="hljs-keyword">super</span>(k);              value = v;        &#125;&#125;</code></pre><h4 id="2-getMap-方法"><a href="#2-getMap-方法" class="headerlink" title="2. getMap() 方法"></a>2. getMap() 方法</h4><pre><code class="hljs Java"><span class="hljs-comment">/** * <span class="hljs-doctag">@param</span>  t the current thread * <span class="hljs-doctag">@return</span> the map */</span><span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;  <span class="hljs-comment">// 返回当前线程的 threadlocals（ThreadLocalMap）</span>    <span class="hljs-keyword">return</span> t.threadLocals;&#125;Thread.java<span class="hljs-comment">// 每一个线程中都有一个 ThreadLocalMap 类型的成员 threadLocals</span>ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>;</code></pre><h4 id="3-get-方法"><a href="#3-get-方法" class="headerlink" title="3. get() 方法"></a>3. get() 方法</h4><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 当前线程对象</span>    Thread t = Thread.currentThread();  <span class="hljs-comment">// 获取当前线程对象维护的 ThreadLocalMap 对象 threadLocals</span>    ThreadLocalMap map = getMap(t);    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 获得 ThreadLocalMap 的 Entry 节点</span>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)            T result = (T)e.value;  <span class="hljs-comment">// 从 Entry 节点获取存储的 Value 副本值返回。</span>            <span class="hljs-keyword">return</span> result;        &#125;    &#125;    <span class="hljs-keyword">return</span> setInitialValue();&#125;</code></pre><h4 id="4-remove-方法"><a href="#4-remove-方法" class="headerlink" title="4. remove() 方法"></a>4. remove() 方法</h4><pre><code class="hljs JAVA"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;    ThreadLocalMap m = getMap(Thread.currentThread());    <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span>)        m.remove(<span class="hljs-keyword">this</span>);&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>每个 Thread 维护着一个 ThreadLocalMap 的引用</p></li><li><p>ThreadLocalMap 是 ThreadLocal 的内部类，用 Entry 来进行存储</p></li><li><p>调用 ThreadLocal 的 set() 方法时，实际上就是往 ThreadLocalMap 设置值，key 是ThreadLocal 对象，值是传递进来的对象</p></li><li><p>调用 ThreadLocal 的 get() 方法时，实际上就是往 ThreadLocalMap 获取值，key 是ThreadLocal 对象</p></li><li><p>ThreadLocal 本身并不存储值，它只是作为一个 key 来让线程从 ThreadLocalMap 获取value。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java ArrayList 那些小事情</title>
    <link href="/2020/03/15/Java-ArrayList-%E9%82%A3%E4%BA%9B%E5%B0%8F%E4%BA%8B%E6%83%85/"/>
    <url>/2020/03/15/Java-ArrayList-%E9%82%A3%E4%BA%9B%E5%B0%8F%E4%BA%8B%E6%83%85/</url>
    
    <content type="html"><![CDATA[<h2 id="ArrayList-那些小事情"><a href="#ArrayList-那些小事情" class="headerlink" title="ArrayList 那些小事情"></a>ArrayList 那些小事情</h2><p>我们都知道在 Java Collection 集合中 ，ArrayList 是最常用的，但不能保证线程安全的集合类。如何进行改进呢？</p><ol><li>Vector 类</li><li>Collections.synchronizedList</li><li>java.util.concurrent.CopyOnWriteArrayList</li></ol><a id="more"></a><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h3 id="Collections-synchronizedList"><a href="#Collections-synchronizedList" class="headerlink" title="Collections.synchronizedList"></a>Collections.synchronizedList</h3><h3 id="java-util-concurrent-CopyOnWriteArrayList"><a href="#java-util-concurrent-CopyOnWriteArrayList" class="headerlink" title="java.util.concurrent.CopyOnWriteArrayList"></a>java.util.concurrent.CopyOnWriteArrayList</h3><h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 开发错误记录1</title>
    <link href="/2020/03/15/Java-%E5%BC%80%E5%8F%91%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%951/"/>
    <url>/2020/03/15/Java-%E5%BC%80%E5%8F%91%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%951/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-开发错误记录"><a href="#Java-开发错误记录" class="headerlink" title="Java 开发错误记录"></a>Java 开发错误记录</h2><p>记录开发中遇到的错误，希望可以避免再犯。</p><p>成长为一个优秀的 Java 工程师，在犯错改错，避免再犯的路上一直前进！</p><a id="more"></a><p><a href="error.jpg">!error</a></p><p>以上代码看似没有问题，往 list 中添加 FeedContent 对象，但最后结果全是重复数据！</p><h4 id="为什么呢？"><a href="#为什么呢？" class="headerlink" title="为什么呢？"></a>为什么呢？</h4><p>因为将对象 add 进 list 时，放入 list 的是对象的引用，虽然每次为对象重新 set 值，但实际上仍然是同一个对象，每次都是重新赋值覆盖之前的数据，所以循环的都是重复的数据。</p><p><strong>因此 new 对象应该放在循环里面，保证每次加入 list 的都是新的对象。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发错误记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Data Jpa (二)</title>
    <link href="/2020/03/06/Spring-Data-Jpa-%E4%BA%8C/"/>
    <url>/2020/03/06/Spring-Data-Jpa-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring-Data-JPA-二"><a href="#Spring-Data-JPA-二" class="headerlink" title="Spring Data JPA  (二)"></a>Spring Data JPA  (二)</h2><h3 id="一、定义查询方法"><a href="#一、定义查询方法" class="headerlink" title="一、定义查询方法"></a>一、定义查询方法</h3><p>两种定义查询方法：</p><ol><li>从方法名派生查询</li><li>手动定义 @Query</li></ol><p>待查询功能的方法名由查询策略（关键字）、查 询字段和一些限制性条件组成。</p><p>一些关键字：And，Or，Is，Equals，Between，LessThan，IsNull，Like，OrderBy，Not，In，IgnoreCase 等</p><a id="more"></a><h4 id="参数选择"><a href="#参数选择" class="headerlink" title="参数选择"></a>参数选择</h4><p>Pageable，Slice，Sort</p><pre><code class="hljs java"><span class="hljs-function">Page&lt;User&gt; <span class="hljs-title">findUserByName</span><span class="hljs-params">(String name, Pageable pageable)</span></span>;<span class="hljs-function">Slice&lt;User&gt; <span class="hljs-title">findUserByEmail</span><span class="hljs-params">(String email, Pageable pageable)</span></span>;<span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findUserByName</span><span class="hljs-params">(String name, Sort sort)</span></span>;<span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findUserByNameAndEmail</span><span class="hljs-params">(String name, Pageable pageable)</span></span>;</code></pre><h4 id="限制查询"><a href="#限制查询" class="headerlink" title="限制查询"></a>限制查询</h4><p>通过关键字来限制 first 或 top</p><pre><code class="hljs java"><span class="hljs-function">User <span class="hljs-title">findFirstByOrderByNameAsc</span><span class="hljs-params">()</span></span>;<span class="hljs-function">User <span class="hljs-title">findTopByOrderByEmailDesc</span><span class="hljs-params">()</span></span>;<span class="hljs-function">Page&lt;User&gt; <span class="hljs-title">queryFirst10ByName</span><span class="hljs-params">(String name, Pageable pageable)</span></span>;<span class="hljs-function">Slice&lt;User&gt; <span class="hljs-title">findTop3ByEmail</span><span class="hljs-params">(String email, Pageable pageable)</span></span>;</code></pre><h4 id="查询结果的形式"><a href="#查询结果的形式" class="headerlink" title="查询结果的形式"></a>查询结果的形式</h4><p>除了 Iterator，List，Set 还支持 Spring Data’s Streamable</p><pre><code class="hljs java">UserRepository:<span class="hljs-function">Streamable&lt;User&gt; <span class="hljs-title">findUserByFirstNameContaining</span><span class="hljs-params">(String name)</span></span>;<span class="hljs-function">Streamable&lt;User&gt; <span class="hljs-title">findUserByLastNameContaining</span><span class="hljs-params">(String name)</span></span>;Controller:Streamable&lt;User&gt; result = userRepository.findUserByFirstNameContaining(str)                .and(userRepository.findUserByLastNameContaining(str));</code></pre><p>使用Java 8 Stream<T>作为返回类型来逐步处理查询方法的结果</T></p><pre><code class="hljs java"><span class="hljs-function">Stream&lt;User&gt; <span class="hljs-title">readAllByFirstNameNotNull</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 关闭资源</span><span class="hljs-keyword">try</span> (Stream&lt;User&gt; userStream = userRepository.readAllByFirstNameNotNull())&#123;<span class="hljs-comment">// 操作</span>&#125;</code></pre><h3 id="二、注解式查询"><a href="#二、注解式查询" class="headerlink" title="二、注解式查询"></a>二、注解式查询</h3><p>@Query</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Query &#123;    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;    <span class="hljs-function">String <span class="hljs-title">countQuery</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;    <span class="hljs-function">String <span class="hljs-title">countProjection</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">nativeQuery</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;    <span class="hljs-function">String <span class="hljs-title">countName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Data JPA (一)</title>
    <link href="/2020/03/05/Spring-Data-JPA-%E4%B8%80/"/>
    <url>/2020/03/05/Spring-Data-JPA-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h2><h3 id="一-JPA"><a href="#一-JPA" class="headerlink" title="一. JPA"></a>一. JPA</h3><p>JPA 是 <code>Java Persistence API</code> 的简称，包括：</p><ol><li>一套 API 标准</li><li>面向对象的查询语言</li><li>ORM(object/relational metadata) 元数据的映射</li></ol><a id="more"></a><h3 id="二-Spring-Data"><a href="#二-Spring-Data" class="headerlink" title="二. Spring Data"></a>二. Spring Data</h3><p>基于 Spring 的数据访问编程模型，同时保留底层数据存储的特殊特性，让开发者轻松得使用数据访问技术。支持 <strong>NoSQL 数据库</strong> 和 <strong>关系型数据库</strong>。</p><h3 id="三-Spring-Data-JPA"><a href="#三-Spring-Data-JPA" class="headerlink" title="三. Spring Data JPA"></a>三. Spring Data JPA</h3><p>Spring Data JPA 是 Spring Data 的子项目。</p><p>Repository 接口与其实现类的关系结构图：</p><p><a href="repository.jpeg">!类的关系图</a></p><h3 id="四-使用-Spring-Data-JPA-进行持久层开发的步骤"><a href="#四-使用-Spring-Data-JPA-进行持久层开发的步骤" class="headerlink" title="四. 使用 Spring Data JPA 进行持久层开发的步骤"></a>四. 使用 Spring Data JPA 进行持久层开发的步骤</h3><ol><li>声明持久层的接口，该接口继承<code>Repository</code></li><li>在接口中声明需要的方法</li><li></li></ol><h3 id="五-PA-基础查询方法"><a href="#五-PA-基础查询方法" class="headerlink" title="五. PA 基础查询方法"></a>五. PA 基础查询方法</h3><p>Repository 主要作为标记接口，捕获要使用的类型，并发现扩展此接口的接口。</p><h4 id="4-1-CrudRepository方法"><a href="#4-1-CrudRepository方法" class="headerlink" title="4.1 CrudRepository方法"></a>4.1 CrudRepository方法</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CrudRepository</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">ID</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Repository</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">ID</span>&gt; </span>&#123;    &lt;S extends T&gt; <span class="hljs-function">S <span class="hljs-title">save</span><span class="hljs-params">(S var1)</span></span>;  <span class="hljs-comment">// 保存实体方法</span>    &lt;S extends T&gt; <span class="hljs-function">Iterable&lt;S&gt; <span class="hljs-title">saveAll</span><span class="hljs-params">(Iterable&lt;S&gt; var1)</span></span>; <span class="hljs-comment">// 批量保存</span>    <span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">findById</span><span class="hljs-params">(ID var1)</span></span>;  <span class="hljs-comment">// 根据主键查询实体</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">existsById</span><span class="hljs-params">(ID var1)</span></span>;<span class="hljs-comment">// 根据主键判断实体是否存在</span>    <span class="hljs-function">Iterable&lt;T&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 查询实体的所有列表</span>    <span class="hljs-function">Iterable&lt;T&gt; <span class="hljs-title">findAllById</span><span class="hljs-params">(Iterable&lt;ID&gt; var1)</span></span>; <span class="hljs-comment">// 根据主键列表查询实体列表</span>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 查询总数</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(ID var1)</span></span>; <span class="hljs-comment">// 根据主键删除</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(T var1)</span></span>;   <span class="hljs-comment">// </span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteAll</span><span class="hljs-params">(Iterable&lt;? extends T&gt; var1)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteAll</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h4 id="4-2-PagingAndSortingRepository-方法"><a href="#4-2-PagingAndSortingRepository-方法" class="headerlink" title="4.2 PagingAndSortingRepository 方法"></a>4.2 PagingAndSortingRepository 方法</h4><p>PagingAndSortingRepository 继承 CrudRepository 所有的基本方法，它增加了分页和排序等对查询结 果进行限制的基本的、常用的、通用的一些分页方法。</p><pre><code class="hljs java"><span class="hljs-meta">@NoRepositoryBean</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PagingAndSortingRepository</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">ID</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">CrudRepository</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">ID</span>&gt; </span>&#123;    <span class="hljs-function">Iterable&lt;T&gt; <span class="hljs-title">findAll</span><span class="hljs-params">(Sort var1)</span></span>;  <span class="hljs-comment">// 根据排序取所有对象的集合</span>    <span class="hljs-function">Page&lt;T&gt; <span class="hljs-title">findAll</span><span class="hljs-params">(Pageable var1)</span></span>;  <span class="hljs-comment">// 根据分页和排序进行查询，并用Page对象封装。Pageable 对象包含分页和Sort对象</span>&#125;</code></pre><h4 id="4-3-JpaRepository-方法"><a href="#4-3-JpaRepository-方法" class="headerlink" title="4.3 JpaRepository 方法"></a>4.3 JpaRepository 方法</h4><p>JpaRepository 开始是对关系型数据库进行抽象封装，它继承了 PagingAndSortingRepository，也就继承了其所有方法，并且实现类是 SimpleJpaRepository。从类图上还可以看出 JpaRepository 继承和拥有了 QueryByExampleExecutor 的相关方法。它支持Query By Example， 批量删除，提高删除效率，手动刷新数据库的更改方法，并将默认实 现的查询结果变成了List。</p><pre><code class="hljs Java"><span class="hljs-meta">@NoRepositoryBean</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">ID</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">PagingAndSortingRepository</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">ID</span>&gt;, <span class="hljs-title">QueryByExampleExecutor</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">findAll</span><span class="hljs-params">(Sort var1)</span></span>;    <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">findAllById</span><span class="hljs-params">(Iterable&lt;ID&gt; var1)</span></span>;    &lt;S extends T&gt; <span class="hljs-function">List&lt;S&gt; <span class="hljs-title">saveAll</span><span class="hljs-params">(Iterable&lt;S&gt; var1)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>;    &lt;S extends T&gt; <span class="hljs-function">S <span class="hljs-title">saveAndFlush</span><span class="hljs-params">(S var1)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteInBatch</span><span class="hljs-params">(Iterable&lt;T&gt; var1)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteAllInBatch</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">T <span class="hljs-title">getOne</span><span class="hljs-params">(ID var1)</span></span>;    &lt;S extends T&gt; <span class="hljs-function">List&lt;S&gt; <span class="hljs-title">findAll</span><span class="hljs-params">(Example&lt;S&gt; var1)</span></span>;    &lt;S extends T&gt; <span class="hljs-function">List&lt;S&gt; <span class="hljs-title">findAll</span><span class="hljs-params">(Example&lt;S&gt; var1, Sort var2)</span></span>;&#125;</code></pre><h4 id="4-4-Repository的实现类SimpleJpaRepository"><a href="#4-4-Repository的实现类SimpleJpaRepository" class="headerlink" title="4.4 Repository的实现类SimpleJpaRepository"></a>4.4 Repository的实现类SimpleJpaRepository</h4>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>JPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac 安装配置Hadoop 3.X 采坑记录</title>
    <link href="/2020/03/04/Mac-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEHadoop-3-X-%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/03/04/Mac-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEHadoop-3-X-%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Mac-安装配置Hadoop-3-X-采坑记录"><a href="#Mac-安装配置Hadoop-3-X-采坑记录" class="headerlink" title="Mac 安装配置Hadoop 3.X 采坑记录"></a>Mac 安装配置Hadoop 3.X 采坑记录</h2><p>想要学习Hadoop，于是在Mac本机上想要配置Hadoop 伪分布式集群，折腾了一上午，在各种报错修改下，终于搞定了，于是写下该文，供参考。</p><p>环境配置基础：</p><p>已经安装 JDK1.8，homebrew， 具体细节不做阐述</p><a id="more"></a><h3 id="Hadoop-安装"><a href="#Hadoop-安装" class="headerlink" title="Hadoop 安装"></a>Hadoop 安装</h3><p>采用 homebrew 安装，终端输入：</p><pre><code class="hljs bash">$ brew install hadoop</code></pre><p>Hadoop 安装成功。Hadoop 环境变量也无需设置。</p><p>运行 Hadoop 测试：</p><pre><code class="hljs bash">$ hadoop version</code></pre><h3 id="Hadoop-配置"><a href="#Hadoop-配置" class="headerlink" title="Hadoop 配置"></a>Hadoop 配置</h3><h4 id="伪分布式模式"><a href="#伪分布式模式" class="headerlink" title="伪分布式模式"></a>伪分布式模式</h4><p><strong>1. 远程登录设置</strong><br>伪分布式模式需要模拟远程登录 localhost。</p><p>首先确保远程登录（系统偏好设置-共享）是开放的且能被所有用户使用或者可以被当前用户访问，设置如下图。</p><p><a href="config.png">!配置位置</a></p><p>如果在终端中输入<code>ssh localhost</code>有返回，则你已经配置好了SSH keys，如果没有，新建 SSH keys 配置：</p><pre><code class="hljs bash">$ ssh-keygen -t rsa -P <span class="hljs-string">""</span></code></pre><p>为了避免每次询问你的密码，可以授权你的公钥到本地：</p><pre><code class="hljs bash">$ cat <span class="hljs-variable">$HOME</span>/.ssh/id_rsa.pub &gt;&gt; <span class="hljs-variable">$HOME</span>/.ssh/authorized_keys</code></pre><p>现在 SSH keys 就设置成功</p><p><strong>2. 配置文件设置</strong></p><p>配置文件目录为：/usr/local/Cellar/hadoop/3.2.1(Hadoop 版本号)/libexec/etc/hadoop</p><p><strong>hadoop-env.sh 文件配置</strong></p><p>输入命令，查看 Java 的安装路径：</p><pre><code class="hljs bash">$ /usr/libexec/java_home</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 打开注释，并加入 java 安装路径</span><span class="hljs-built_in">export</span> JAVA_HOME=<span class="hljs-string">"/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home"</span></code></pre><p><strong>core-site.xml 文件配置</strong></p><p>设置 Hadoop 的临时目录和文件系统</p><p>localhost:9000 表示本地主机。如果使用远程主机，要用相应的 IP 地址来代替，填写远程主机的域名，</p><pre><code class="hljs text">&lt;configuration&gt; &lt;property&gt;   &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;   &lt;value&gt;【临时目录的位置，可以自己设置】&lt;&#x2F;value&gt;   &lt;description&gt;A base for other temporary directories.&lt;&#x2F;description&gt; &lt;&#x2F;property&gt;  &lt;property&gt;   &lt;name&gt;fs.default.name&lt;&#x2F;name&gt;   &lt;value&gt;hdfs:&#x2F;&#x2F;localhost:9000&lt;&#x2F;value&gt; &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt;</code></pre><p><strong>hdfs-site.xml 文件配置</strong></p><p>dfs.replication 通常为3, 由于我们只有一台主机和一个伪分布式模式的 DataNode，将此值修改为1。</p><pre><code class="hljs text">&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;        &lt;value&gt;1&lt;&#x2F;value&gt;    &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt;</code></pre><p><strong>mapred-site.xml 文件配置</strong></p><p>设置数据处理框架</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-comment">&lt;!--指定mapreduce运行在yarn上--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.framework.name<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>yarn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapred.job.tracker<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>localhost:9010<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><p><strong>yarn-site.xml 文件配置</strong></p><p>yarn.resourcemanager.address 端口不应该为 localhost:9000</p><p>配置时参考某一教程，端口配置为9000，yarn 可以启动，但是mapreduce 任务无法运行，错误信息为：ERROR: “org.apache.hadoop.ipc.RpcNoSuchProtocolException(Unknown protocol: org.apache.hadoop.yarn.api.ApplicationClientProtocolPB” while running mapping in Hive environment</p><p>并且 localhost:8042 可以正常访问，但 localhost:8088 无法访问</p><p>修改端口后，localhost:8088 可正常访问</p><p>但运行mapreduce 任务出错：</p><p><strong>错误: 找不到或无法加载主类org.apache.hadoop.mapreduce.v2.app.MRAppMaster</strong></p><p>往上的解决方案是，在终端输入：</p><pre><code class="hljs bash">$ hadoop classpath</code></pre><p>将返回信息加入 yarn-site.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.application.classpath<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>输入刚才返回的 Hadoop classpath 路径<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><p>但是输入hadoop classpath 返回的路径信息太长了，不好看，于是修改至下</p><pre><code class="hljs text">&lt;configuration&gt;&lt;!-- Site specific YARN configuration properties --&gt;    &lt;property&gt;        &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;        &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;    &lt;&#x2F;property&gt;    &lt;property&gt;        &lt;name&gt;yarn.resourcemanager.address&lt;&#x2F;name&gt;        &lt;value&gt;localhost:8032&lt;&#x2F;value&gt;    &lt;&#x2F;property&gt;    &lt;property&gt;        &lt;name&gt;yarn.nodemanager.env-whitelist&lt;&#x2F;name&gt;&lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME&lt;&#x2F;value&gt;&lt;&#x2F;property&gt; &lt;&#x2F;configuration&gt;</code></pre><p>以上，需要修改和配置的文件应该已经没有问题了。</p><h3 id="启动-Hadoop"><a href="#启动-Hadoop" class="headerlink" title="启动 Hadoop"></a>启动 Hadoop</h3><p><strong>1. 格式化 HDFS</strong></p><p>在启动 Hadoop 之前要先格式化 HDFS，通过创建存储目录和初始化元数据来格式化和创建新的文件系统：</p><pre><code class="hljs bash">$ hadoop namenode -format</code></pre><p><strong>2. 启动 Hadoop</strong></p><p>启动 HDFS：</p><pre><code class="hljs bash">$ start-dfs.sh</code></pre><p>会出现警告『WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform… using builtin-java classes where applicable』，其实就是缺少本地库，不会影响 Hadoop 的使用，只是影响效率。解决方案可参考：</p><p><a href="https://link.zhihu.com/?target=http%3A//rockyfeng.me/hadoop_native_library_mac.html">Mac OSX 下 Hadoop 使用本地库提高效率</a> （未试验）</p><p>启动数据处理 <code>mapreduce</code>框架 <code>yarn</code>:</p><pre><code class="hljs bash">$ start-yarn.sh</code></pre><p>Hadoop 启动完成，通过浏览器查看<code>hadoop</code>的详细信息：</p><pre><code class="hljs text">http:&#x2F;&#x2F;localhost:50070&#x2F;  hadoop 2.X版本http:&#x2F;&#x2F;localhost:9870&#x2F;   hadoop 3.X版本</code></pre><p>也可以使用 jps 命令查看守护进程：</p><pre><code class="hljs bash">$ jps</code></pre><p>查看 ResourceManager </p><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//localhost:8088/</span></code></pre><p>查看 NodeManager</p><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//localhost:8042/</span></code></pre><p>用完关闭服务</p><pre><code class="hljs bash">/usr/<span class="hljs-built_in">local</span>/Cellar/hadoop/3.2.1/sbin $ ./stop-all.sh</code></pre>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac MySQL 安装</title>
    <link href="/2020/03/04/Mac-MySQL-%E5%AE%89%E8%A3%85/"/>
    <url>/2020/03/04/Mac-MySQL-%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="Mac-MySql-安装配置"><a href="#Mac-MySql-安装配置" class="headerlink" title="Mac MySql 安装配置"></a>Mac MySql 安装配置</h2><p>安装完后，mysql -h localhost -u root -p 时候报错，</p><pre><code class="hljs routeros"><span class="hljs-builtin-name">ERROR</span> 1045 (28000): Access denied <span class="hljs-keyword">for</span><span class="hljs-built_in"> user </span><span class="hljs-string">'root'</span>@<span class="hljs-string">'localhost'</span> (using password: <span class="hljs-literal">YES</span>)</code></pre><a id="more"></a><p>第一步：删除 <code>/usr/local/mysql/data/</code> 下的 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> 文件。</p><p>第二步：在系统偏好设置中停止Mysql服务</p><p>第三步：<code>cd /usr/local/mysql/bin/</code> 执行<code>./mysqld_safe --skip-grant-tables &amp;</code>（mysql会自动重启,系统偏好设置中mysql的状态会变成running）</p><p>第四步 执行 <code>./mysql</code> 回车后，输入命令 <code>FLUSH PRIVILEGES;</code> 回车后，输入命令 <code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;你的新密码&#39;;</code></p><p>安装数据库以后，idea 无法连接，查看数据库端口<code>&#39;show global variables like &#39;port&#39;;&#39;</code> 发现端口为0，</p><p>在 <code>/Library/LaunchDaemons</code> 下的 <code>com.oracle.oss.mysql.mysqld.plist</code> 文件中的 <code>ProgramArguments</code> 下添加 <code>&lt;string&gt;--port=3306&lt;/string&gt;</code> 保存退出</p><p>重启 MySQL 数据库，再次查看 MySQL 端口，数据库连接正常。</p>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 线程</title>
    <link href="/2019/10/26/Java-%E7%BA%BF%E7%A8%8B/"/>
    <url>/2019/10/26/Java-%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h1><h2 id="1-基本概念：程序-进程-线程"><a href="#1-基本概念：程序-进程-线程" class="headerlink" title="1. 基本概念：程序 - 进程 - 线程"></a>1. 基本概念：程序 - 进程 - 线程</h2><p><strong>程序(program)</strong> 是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。</p><p><strong>进程(process)</strong> 是<strong>程序的一次执行过程</strong>，或是正在运行的一个程序。动态过程：有它自身的产生、存在和消亡的过程。</p><p>如：运行中的QQ，运行中的MP3播放器</p><p>PS: 程序是静态的，进程是动态的</p><p><strong>线程(thread)</strong>，进程可进一步细化为线程，是一个程序内部的一条执行路径。</p><a id="more"></a><p>一个进程（程序的执行过程），可以分化为并行执行的多个线程（多个子程序）</p><p>若一个程序可同一时间执行多个线程，就是支持多线程的</p><h4 id="何时需要多线程？"><a href="#何时需要多线程？" class="headerlink" title="何时需要多线程？"></a>何时需要多线程？</h4><p>程序需要同时执行两个或多个任务。</p><p>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。</p><p>需要一些后台运行的程序时。</p><h2 id="2-多线程的创建和启动"><a href="#2-多线程的创建和启动" class="headerlink" title="2. 多线程的创建和启动"></a>2. 多线程的创建和启动</h2><p>Java语言的JVM允许程序运行多个线程，它通过 <code>java.lang.Thread</code> 类来实现。</p><p>Thread类的特性:</p><ul><li><p>每个线程都是通过某个特定 Thread 对象的 <code>run()</code> 方法来完成操作的，经常把 <code>run()</code> 方法的主体称为 <strong>线程体</strong>，想要在开启的多线程中运行的代码逻辑，就写到 <code>run()</code> 方法里</p></li><li><p>通过该 Thread 对象的 <code>start()</code> 方法来调用这个线程，即运行 <code>run()</code> 方法</p></li></ul><h3 id="Tread-类"><a href="#Tread-类" class="headerlink" title="Tread 类"></a>Tread 类</h3><p>构造方法：</p><p><strong>Thread()</strong>：创建新的Thread对象</p><p><strong>Thread(String threadname)</strong>：创建线程并指定线程实例名</p><p><strong>Thread(Runnable target)</strong>：指定创建线程的目标对象，它实现了Runnable接口中的run方法</p><p><strong>Thread(Runnable target, String name)</strong>：创建新的Thread对象 </p><h3 id="创建线程的两种方式"><a href="#创建线程的两种方式" class="headerlink" title="创建线程的两种方式"></a>创建线程的两种方式</h3><ol><li><p>继承 Thread 类</p><ul><li>定义子类继承Thread类。</li><li>子类中重写Thread类中的run方法。</li><li>创建Thread子类对象，即创建了线程对象。</li><li>调用线程对象start方法：启动线程，调用run方法。</li></ul></li><li><p>实现 Runnable 接口</p><ul><li><p>定义子类，实现 Runnable 接口。</p></li><li><p>子类中重写 Runnable 接口中的 run 方法。</p></li><li><p>通过 Thread 类含参构造器创建线程对象。</p></li><li><p>将 Runnable 接口的子类对象作为实际参数传递给 Thread 类的构造方法中。</p></li><li><p>调用 Thread 类的 start 方法：开启线程，调用 Runnable 子类接口的 run 方法。</p></li></ul></li></ol><p><strong>继承方式和实现方式的联系与区别</strong><br><code>public class Thread extends Object implements Runnable</code></p><p><strong>区别</strong><br>继承 Thread:    线程代码存放 Thread 子类 run 方法中。重写 run 方法<br>实现 Runnable：线程代码存在接口的子类的 run 方法。实现 run 方法</p><p><strong>实现接口方式的好处</strong></p><ul><li>避免了单继承的局限性</li><li>多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。</li></ul><p><strong>一般使用实现接口方式来实现多线程</strong></p><p><strong>使用多线程的优点</strong></p><ol><li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</li><li>提高计算机系统CPU的利用率</li><li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</li></ol><h4 id="Thread-类的有关方法"><a href="#Thread-类的有关方法" class="headerlink" title="Thread 类的有关方法"></a>Thread 类的有关方法</h4><p><strong>void start():</strong> 启动线程，并执行对象的 run() 方法</p><p><strong>run():</strong> 线程在被调度时执行的操作</p><p><strong>String  getName():</strong> 返回线程的名称</p><p><strong>void setName(String name)</strong>: 设置该线程名称</p><p><strong>static currentThread():</strong>  返回当前线程</p><p><strong>static void yield()</strong>： 线程让步<br>暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程<br>若队列中没有同优先级的线程，忽略此方法</p><p><strong>join()</strong> ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止<br>低优先级的线程也可以获得执行 </p><p><strong>static void sleep(long millis)</strong>：(指定时间:毫秒)<br>令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。<br>抛出InterruptedException异常</p><p><strong>stop():</strong> 强制线程生命期结束</p><p><strong>boolean isAlive()</strong>：返回boolean，判断线程是否还活着</p><h4 id="线程的优先级-哪个线程有较大的概率被执行"><a href="#线程的优先级-哪个线程有较大的概率被执行" class="headerlink" title="线程的优先级: 哪个线程有较大的概率被执行"></a>线程的优先级: 哪个线程有较大的概率被执行</h4><p>线程的优先级是用数字1-10表示的，数字越大优先级越高，如果没有设置优先级，默认为5</p><p><strong>线程的优先级控制</strong><br>MAX_PRIORITY (10);<br>MIN _PRIORITY（1）;<br>NORM_PRIORITY（5）;</p><p><strong>涉及的方法：</strong><br>getPriority()：返回线程优先值<br>setPriority(int newPriority)：改变线程的优先级<br>线程创建时继承父线程的优先级</p><h2 id="3-线程的生命周期"><a href="#3-线程的生命周期" class="headerlink" title="3. 线程的生命周期"></a>3. 线程的生命周期</h2><p>JDK 中用 <code>Thread.State</code> 枚举表示了线程的几种状态</p><p>要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用 Thread 类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的 <strong>五种状态</strong>：</p><p><strong>新建</strong>： 当一个 Thread 类或其子类的对象被声明并创建时，新生的线程对象处于新建状态（线程实例的创建）</p><p><strong>就绪</strong>：处于新建状态的线程被 start() 后，将进入线程队列等待 CPU 时间片，此时它已具备了运行的条件</p><p><strong>运行</strong>：当就绪的线程被调度并获得处理器资源时,便进入运行状态， run() 方法定义了线程的操作和功能（run方法的代码开始执行）</p><p><strong>阻塞</strong>：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态（run 方法的代码暂停执行）</p><p><strong>死亡</strong>： 线程完成了它的全部工作或线程被提前强制性地中止 （执行stop() 方法，断电，杀掉进程）</p><p><img src="/2019/10/26/Java-%E7%BA%BF%E7%A8%8B/Thread_state.png" srcset="/img/loading.gif" alt="Thread State"> </p><h2 id="4-线程的同步"><a href="#4-线程的同步" class="headerlink" title="4. 线程的同步"></a>4. 线程的同步</h2><p><strong>问题的提出</strong></p><p>多个线程执行的不确定性引起执行结果的不稳定</p><p>多个线程对账本的共享，会造成操作的不完整性，会破坏数据。</p><p><strong>多线程出现了安全问题</strong></p><p><strong>问题的原因</strong></p><p>当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。</p><p><strong>解决办法</strong></p><p>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。</p><p><strong>Synchronized 关键字的使用</strong></p><ul><li><p>synchronized 放在方法声明中，表示整个方法为 <strong>同步方法</strong>。<strong>针对对象加同步锁</strong></p><p>例如：</p><p><code>public synchronized void show (String name){ ….}</code></p></li><li><p>synchronized (对象）{// 需要被同步的代码；}  <strong>针对某一段代码加同步锁</strong></p><p><code>synchronized(this);</code> // 用 this 锁代码块是代表当前的对象，如果在方法中也有 <code>synchronized(this)</code> 的代码块使用的都是同一个同步锁。</p></li></ul><p><strong>总结</strong>：</p><p>在普通方法上加同步锁 synchronized 锁的是当前方法对应的对象，当前对象的所有加了同步锁的方法共用一个同步锁</p><p>静态方法加  synchronized 同步锁，所有对象共用一个同步锁</p><p>代码块加同步锁：</p><ul><li>代码块  <code>synchronized (this)</code> 所有当前对象的  <code>synchronized (this)</code> 同步的代码都是使用同一个同步锁</li><li>代码块  <code>synchronized (对象)</code>  不同对象不同锁</li></ul><h4 id="线程的死锁"><a href="#线程的死锁" class="headerlink" title="线程的死锁"></a>线程的死锁</h4><p>死锁</p><p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</p><p>解决方法</p><p>专门的算法、原则，比如加锁顺序一致</p><p>尽量减少同步资源的定义，尽量避免锁未释放的场景</p><h2 id="5-线程通信"><a href="#5-线程通信" class="headerlink" title="5. 线程通信"></a>5. 线程通信</h2><p><strong>wait() 与 notify() 和 notifyAll()</strong></p><p><strong>wait()</strong>：令当前线程挂起并放弃CPU、同步资源，使别的线程可访问并修改共享资源，而当前线程排队等候再次对资源的访问</p><p><strong>notify()</strong>：唤醒正在排队等待同步资源的线程中优先级最高者结束等待</p><p><strong>notifyAll()</strong>：唤醒正在排队等待资源的所有线程结束等待.</p><p><code>Java.lang.Object</code> 提供的这三个方法 <strong>只有在 synchronized 方法或 synchronized 代码块中才能使用</strong>，否则会报 <code>java.lang.IllegalMonitorStateException</code> 异常</p><h4 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait() 方法"></a>wait() 方法</h4><p>在当前线程中调用方法： <code>对象名.wait()</code></p><p>使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 <code>notify</code> (或<code>notifyAll</code>) 为止。</p><p>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</p><p><strong>调用此方法后，当前线程将释放对象监控权 ，然后进入等待</strong></p><p>在当前线程被 notify 后，要重新获得监控权，然后从断点处继续代码的执行。</p><h4 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify()/notifyAll()"></a>notify()/notifyAll()</h4><p>在当前线程中调用方法： <code>对象名.notify()</code></p><p>功能：唤醒等待该对象监控权的一个线程。</p><p>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</p><h2 id="经典：生产者-消费者问题"><a href="#经典：生产者-消费者问题" class="headerlink" title="经典：生产者/消费者问题"></a>经典：生产者/消费者问题</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 反射</title>
    <link href="/2019/10/24/Java-%E5%8F%8D%E5%B0%84/"/>
    <url>/2019/10/24/Java-%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java 反射"></a>Java 反射</h1><p>Java 能够反射的前提：已经加载过这个类，就可以通过类名来寻找到这个类的所有相关信息</p><p><strong>Java Reflection</strong></p><p>Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</p><a id="more"></a><p><strong>Java反射机制提供的功能</strong></p><p>​    在运行时判断任意一个对象所属的类</p><p>​    在运行时构造任意一个类的对象</p><p>​    在运行时判断任意一个类所具有的成员变量和方法</p><p>​    在运行时调用任意一个对象的成员变量和方法</p><p>​    生成动态代理</p><p><strong>Java反射机制研究及应用</strong></p><p><strong>反射相关的主要API：</strong><br><code>java.lang.Class</code> ：代表一个类<br><code>java.lang.reflect.Method</code>：代表类的方法<br><code>java.lang.reflect.Field</code>：代表类的成员变量<br><code>java.lang.reflect.Constructor</code>：代表类的构造方法</p><h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><p>反射可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。</p><p> Class本身也是一个类</p><p> Class 对象只能由系统建立对象</p><p> 一个类在 JVM 中只会有一个Class实例 </p><p> 一个Class对象对应的是一个加载到 JVM 中的一个 .class 文件</p><p> 每个类的实例都会记得自己是由哪个 Class 实例所生成</p><p> 通过 Class 可以完整地得到一个类中的完整结构 </p><p><strong>实例化 Class 类对象(四种方法)</strong> </p><ul><li><p>前提：若已知具体的类，通过类的 <code>class</code> 属性获取，该方法 最为安全可靠，程序性能最高<br>​      实例：<code>Class  clazz = String.class;</code></p></li><li><p>前提：已知某个类的实例，调用该实例的 <code>getClass()</code> 方法获取 Class 对象<br>​     实例：<code>Class clazz = “www.xyd.com”.getClass();</code></p></li><li><p>前提：已知一个类的全类名，且该类在类路径下，可通过 Class 类的静态方法 <code>forName()</code> 获取，可能抛出 <code>ClassNotFoundException</code><br>​     实例： <code>Class clazz = Class.forName (“java.lang.String”);</code></p></li></ul><p>其他方式(不做要求)<br>   <code>ClassLoader cl = this.getClass().getClassLoader();</code><br>   <code>Class clazz4 = cl.loadClass(“类的全类名”);</code></p><h2 id="通过反射调用类的完整结构"><a href="#通过反射调用类的完整结构" class="headerlink" title="通过反射调用类的完整结构"></a>通过反射调用类的完整结构</h2><p>使用反射可以取得：</p><p><strong>1. 实现的全部接口</strong></p><p><code>public Class&lt;?&gt;[] getInterfaces()</code>  确定此对象所表示的类或接口实现的接口。 </p><p><strong>2. 所继承的父类</strong></p><p><code>public Class&lt;? Super T&gt; getSuperclass()</code> 返回表示此 Class 所表示的实体（类、接口、基本类型）的父类的 Class。</p><p><strong>3. 全部的构造器</strong></p><p><code>public Constructor&lt;T&gt;[] getConstructors()</code> 返回此 Class 对象所表示的类的所有 public 构造方法。</p><p><code>public Constructor&lt;T&gt;[] getDeclaredConstructors()</code> 返回此 Class 对象表示的类声明的所有构造方法。</p><p>Constructor类中：</p><p>取得修饰符: <code>public int getModifiers();</code></p><p>取得方法名称: <code>public String getName();</code></p><p>取得参数的类型：<code>public Class&lt;?&gt;[] getParameterTypes();</code></p><p><strong>4. 全部的方法</strong></p><p> <code>public Method[] getDeclaredMethods()</code></p><p> 返回此 Class 对象所表示的类或接口的全部方法</p><p> <code>public Method[] getMethods()</code></p><p> 返回此 Class 对象所表示的类或接口的 public 的方法</p><p> Method类中：</p><p> <code>public Class&lt;?&gt; getReturnType()</code> 取得全部的返回值</p><p> <code>public Class&lt;?&gt;[] getParameterTypes()</code> 取得全部的参数</p><p> <code>public int getModifiers()</code> 取得修饰符</p><p> <strong>5. 全部的Field</strong></p><p><code>public Field[] getFields()</code>  返回此Class对象所表示的类或接口的 public 的 Field。</p><p><code>public Field[] getDeclaredFields()</code>  返回此Class对象所表示的类或接口的全部Field。</p><p>Field方法中：</p><p><code>public int getModifiers()</code>  以整数形式返回此 Field 的修饰符</p><p><code>public Class&lt;?&gt; getType()</code>  得到Field的属性类型</p><p><code>public String getName()</code>  返回Field的名称。</p><p><strong>6. 类所在的包</strong>  </p><p><code>Package getPackage()</code></p><h2 id="通过反射调用类中的指定方法、指定属性"><a href="#通过反射调用类中的指定方法、指定属性" class="headerlink" title="通过反射调用类中的指定方法、指定属性"></a>通过反射调用类中的指定方法、指定属性</h2><p> <strong>1. 调用指定方法</strong></p><p> 通过反射，调用类中的方法，通过Method类完成。</p><p>步骤：</p><ul><li><p>通过 Class 类的 <code>getMethod (String name, Class…parameterTypes)</code> 方法取得一个 Method 对象，并设置此方法操作时所需要的参数类型。</p></li><li><p>之后使用 <code>Object invoke(Object obj, Object[] args)</code> 进行调用，并向方法中传递要设置的 obj 对象的参数信息。</p></li></ul><p><strong>Object invoke(Object obj, Object …  args)</strong></p><p> <strong>说明：</strong></p><ul><li><p>Object 对应原方法的返回值，若原方法无返回值，此时返回 null</p></li><li><p>若原方法若为静态方法，此时形参 Object obj 可为 null</p></li><li><p>若原方法形参列表为空，则 Object[] args 为 null</p></li><li><p>若原方法声明为 private,则需要在调用此 invoke() 方法前，显式调用方法对象的setAccessible(true) 方法，将可访问 private 的方法。    </p></li></ul><p><strong>2. 调用指定属性</strong>  </p><p>在反射机制中，可以直接通过 Field 类操作类中的属性，通过 Field 类提供的 set() 和 get() 方法就可以完成设置和取得属性内容的操作。</p><p><code>public Field getField(String name)</code> 返回此 Class 对象表示的类或接口的指定的public 的 Field。</p><p><code>public Field getDeclaredField(String name)</code> 返回此 Class 对象表示的类或接口的指定的Field。</p><p> <strong>在Field中：</strong></p><p><code>public Object get(Object obj)</code> 取得指定对象 obj 上此 Field 的属性内容</p><p><code>public void set(Object obj,Object value)</code> 设置指定对象 obj 上此 Field 的属性内容</p><p>注：在类中属性都设置为 private 的前提下，在使用 set() 和 get() 方法时，首先要使用 Field 类中的 <code>setAccessible(true)</code> 方法将需要操作的属性设置为可以被外部访问。</p><p><code>public void setAccessible(true)</code> 访问私有属性时，让这个属性可见。 </p><h2 id="Java-动态代理"><a href="#Java-动态代理" class="headerlink" title="Java 动态代理"></a>Java 动态代理</h2><p><strong>Proxy</strong> ：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态地生成实现类。</p><p>创建一个动态代理类所对应的Class对象</p><p><code>static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)</code> 直接创建一个动态代理对象</p><p><strong>注意</strong></p><p>如果一个对象想要通过 <code>Proxy.newProxyInstance</code> 方法被代理，那么这个对象的类一定要有相应的接口。</p><p><strong>动态代理步骤</strong>  </p><ul><li><p>创建一个实现接口 <strong>InvocationHandler</strong> 的类，它必须实现 <code>invoke</code> 方法，以完成代理的具体操作。</p></li><li><p>创建被代理的类以及接口</p></li><li><p>通过 Proxy 的静态方法 <code>newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)</code> 创建一个Subject接口代理</p></li><li><p>通过 Subject 代理调用 RealSubject 实现类的方法</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读《Cross-Network Embedding for Multi-Network Alignment》—_19</title>
    <link href="/2019/10/20/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ACross-Network-Embedding-for-Multi-Network-Alignment%E3%80%8B%E2%80%94-19/"/>
    <url>/2019/10/20/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ACross-Network-Embedding-for-Multi-Network-Alignment%E3%80%8B%E2%80%94-19/</url>
    
    <content type="html"><![CDATA[<h1 id="Cross-Network-Embedding-for-Multi-Network-Alignment-—-WWW19"><a href="#Cross-Network-Embedding-for-Multi-Network-Alignment-—-WWW19" class="headerlink" title="Cross-Network Embedding for Multi-Network Alignment — WWW19"></a>Cross-Network Embedding for Multi-Network Alignment — WWW19</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><h2 id="Research-Objective"><a href="#Research-Objective" class="headerlink" title="Research Objective"></a>Research Objective</h2><p>提出了一个新的跨网络的嵌入方法 CrossMNA，解决 multi-network alignment 问题。 </p><a id="more"></a><h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><p>锚节点（anchor nodes）：网络间共享的用户</p><p>锚链接（anchor link）：跨网络的锚节点之间的关系 </p><p>目前网络对齐方法存在的问题：</p><ul><li>拓扑一致性：不同网络中的相同节点拥有一致的连接结构。虽然一个节点在相关网络中可能具有某些相似的特征，但由于网络语义的特殊性，每个网络中的局部结构连接可能完全不同。  </li><li>样本点对学习：多个网络的学习</li><li>Attributes Dependence  </li></ul><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>CrossMNA 对每一个网络提取一个额外的特征向量 network vector，反映了网络之间全局结构的差异。如果两个网络的这两个向量是相似的，那么这两个网络的全局结构是相似的。</p>]]></content>
    
    
    <categories>
      
      <category>科研论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Social Networks</tag>
      
      <tag>User Identity Linkage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读《Joint Link Prediction and Network Alignment via Cross-graph Embedding》IJCAI19</title>
    <link href="/2019/10/20/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AJoint-Link-Prediction-and-Network-Alignment-via-Cross-graph-Embedding%E3%80%8BIJCAI19/"/>
    <url>/2019/10/20/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AJoint-Link-Prediction-and-Network-Alignment-via-Cross-graph-Embedding%E3%80%8BIJCAI19/</url>
    
    <content type="html"><![CDATA[<h1 id="Joint-Link-Prediction-and-Network-Alignment-via-Cross-graph-Embedding-IJCAI19"><a href="#Joint-Link-Prediction-and-Network-Alignment-via-Cross-graph-Embedding-IJCAI19" class="headerlink" title="Joint Link Prediction and Network Alignment via Cross-graph Embedding - IJCAI19"></a>Joint Link Prediction and Network Alignment via Cross-graph Embedding - IJCAI19</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><h2 id="Research-Objective"><a href="#Research-Objective" class="headerlink" title="Research Objective"></a>Research Objective</h2><p>网络对齐与链路预测任务是相关的，交替地进行两个任务，可以相互促进，特别是对于提高两个任务的 recall 性能。本文提出了一个联合链路预测和网络对齐的框架，并据此设计了一种新的交叉网络的节点嵌入技术来进行信息传播。</p><a id="more"></a><h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><p><strong>Network Alignment</strong></p><p><strong>Seed vertices and seed set</strong></p><p><strong>Link Prediction within a network</strong></p><p><strong>The k-hop neighbors</strong></p><p><strong>Topological and structural similarity</strong></p><ul><li><p>topological similarity：两个节点之间最短路径的倒数</p></li><li><p>structural similarity ：两个网络中两个节点之间的距离</p><script type="math/tex; mode=display">f(u, v)=\sum_{k=0}^{K} \operatorname{dist}\left(s_{k}(u), s_{k}(v)\right)</script></li></ul><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2>]]></content>
    
    
    <categories>
      
      <category>科研论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Social Networks</tag>
      
      <tag>User Identity Linkage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读《Neural Link Prediction Over Aligned Networks》_AAAI18</title>
    <link href="/2019/10/19/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ANeural-Link-Prediction-Over-Aligned-Networks%E3%80%8B-AAAI18/"/>
    <url>/2019/10/19/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ANeural-Link-Prediction-Over-Aligned-Networks%E3%80%8B-AAAI18/</url>
    
    <content type="html"><![CDATA[<h1 id="Neural-Link-Prediction-Over-Aligned-Networks"><a href="#Neural-Link-Prediction-Over-Aligned-Networks" class="headerlink" title="Neural Link Prediction Over Aligned Networks"></a>Neural Link Prediction Over Aligned Networks</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>这篇文章是如何利用对齐的两个网络增强一个网络中的链路预测性能。对于特征分别利用深度网络进行提取，最后一起用来进行链路预测。</p><p>链路预测问题，不是社交网络对齐问题。</p><a id="more"></a><h2 id="Research-Objective"><a href="#Research-Objective" class="headerlink" title="Research Objective"></a>Research Objective</h2><p> 给定两个对齐的网络，本文的目标是对这两个网络进行联合建模，以提高两个网络的预测质量。</p><p>提出一个基于对齐网络的多层神经网络框架 MNN,  在该框架中，将每个异质目标或特征视为一个单独的目标通道。分别为每个目标通道构造一个神经网络，而所有的神经网络共享一组公共的顶点嵌入。 </p><h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><h3 id="Link-Prediction"><a href="#Link-Prediction" class="headerlink" title="Link Prediction"></a>Link Prediction</h3><p>单个网络的链路预测问题可以分为<strong>基于相似性的方法</strong>和<strong>基于模型的方法</strong>。</p><p><strong>Similarity-based</strong></p><p>为每一对节点分配相似性分数，然后根据相似性分数进行链路预测。</p><ul><li>common neighbors</li><li>Leicht-Holme-Newman index</li><li>node rank based algorithms </li></ul><p><strong>Model-based</strong></p><p> 基于网络结构或连接机制的假设建立模型，然后用观测到的网络结构去训练网络</p><ul><li>hierarchical graph based models 基于层次图的模型</li><li>latent factor models </li><li>深度模型<ul><li>DeepWork：DeepWalk将节点视为单词，将随机游动序列视为句子，然后应用单词嵌入技术来计算顶点嵌入。</li><li>node2vec：biased random walk</li><li>SDNE</li></ul></li></ul><h3 id="Network-Alignment"><a href="#Network-Alignment" class="headerlink" title="Network Alignment"></a>Network Alignment</h3><h3 id="Multi-Task-Learning"><a href="#Multi-Task-Learning" class="headerlink" title="Multi-Task Learning"></a>Multi-Task Learning</h3><p><strong>Aligned Network</strong></p><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2>]]></content>
    
    
    <categories>
      
      <category>科研论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Social Networks</tag>
      
      <tag>User Identity Linkage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读《Structure Based User Identification across Social Networks》</title>
    <link href="/2019/10/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AStructure-Based-User-Identification-across-Social-Networks%E3%80%8B/"/>
    <url>/2019/10/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AStructure-Based-User-Identification-across-Social-Networks%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Structure-Based-User-Identification-across-Social-Networks"><a href="#Structure-Based-User-Identification-across-Social-Networks" class="headerlink" title="Structure Based User Identification across Social Networks"></a>Structure Based User Identification across Social Networks</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><h2 id="Research-Objective"><a href="#Research-Objective" class="headerlink" title="Research Objective"></a>Research Objective</h2><p>纯粹通过朋友关系用无监督方法识别不同社交网络中的匿名的相同用户</p><p>提出了一种无监督的用户身份识别算法 —— Friend Relationship-based User Identification without Prior Knowledge（FRUI-P）。从网络结构中提取每个用户的多个维度的特征， 然后从多维特征中评价任意两个不同SNs用户的相似性。</p><p>提出一个 Friend Feature Vector Machine（FFVM）来进行网络的随机游走。 </p><a id="more"></a><h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><h4 id="1-Candidate-Identical-User-Pair"><a href="#1-Candidate-Identical-User-Pair" class="headerlink" title="1 Candidate Identical User Pair"></a>1 Candidate Identical User Pair</h4><h4 id="2-Identical-Users"><a href="#2-Identical-Users" class="headerlink" title="2 Identical Users"></a>2 Identical Users</h4><script type="math/tex; mode=display">\ddot{\mathrm{I}}\left(\mathrm{U}_{i}^{A}, \mathrm{U}_{j}^{B}\right)  \\ 如果 U_i^A 和 U_j^B是真实世界的一个人，那么  U_i^A = U_j^B</script><h4 id="3-Context"><a href="#3-Context" class="headerlink" title="3 Context"></a>3 Context</h4><p>具有较高概率预测用户$U_i$的用户集合，通过随机游走来构建用户的上下文</p><h4 id="4-Positive-Sample"><a href="#4-Positive-Sample" class="headerlink" title="4 Positive Sample"></a>4 Positive Sample</h4><p>$(C_i, U_i)$</p><h4 id="5-Negative-User-Set，Negative-Sample"><a href="#5-Negative-User-Set，Negative-Sample" class="headerlink" title="5 Negative User Set，Negative Sample"></a>5 Negative User Set，Negative Sample</h4><p>除了$U_i$以外的用户定义为$N_i$, 是$C_i$的负用户，$N_i = U - {U_i}$</p><h4 id="6-Friend-Feature-Vector"><a href="#6-Friend-Feature-Vector" class="headerlink" title="6 Friend Feature Vector"></a>6 Friend Feature Vector</h4><p>嵌入 friend 特征的 x 维向量</p><h4 id="7-Friend-Feature-Similarity"><a href="#7-Friend-Feature-Similarity" class="headerlink" title="7 Friend Feature Similarity"></a>7 Friend Feature Similarity</h4><p>跨平台的用户识别问题可以定义为：</p><script type="math/tex; mode=display">f\left(\mathrm{U}_{i}^{A}, \mathrm{U}_{j}^{B} | \mathrm{SN}^{A}, \mathrm{SN}^{B}\right)=\left\{\begin{array}{ll}{1,} & {\mathrm{U}_{i}^{A}=\mathrm{U}_{j}^{B}} \\ {0,} & {\text { otherwise }}\end{array}\right.</script><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h3 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h3><p><strong>Profile-Based User Identification </strong></p><p>Screen name，gender，birthday，city，profile image</p><p><strong>Content-Based User Identification</strong></p><p>基于用户发布 posts 的时间和位置以及用户的写作风格</p><p><strong>Network Structure-Based User Identification</strong></p><ul><li><p>监督方法</p></li><li><p>半监督方法</p></li><li><p>无监督方法</p></li></ul><p><strong>Network Embedding </strong></p><h3 id="无先验知识的用户识别"><a href="#无先验知识的用户识别" class="headerlink" title="无先验知识的用户识别"></a>无先验知识的用户识别</h3><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2>]]></content>
    
    
    <categories>
      
      <category>科研论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Social Networks</tag>
      
      <tag>User Identity Linkage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO流</title>
    <link href="/2019/10/16/Java-IO%E6%B5%81/"/>
    <url>/2019/10/16/Java-IO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-IO-流"><a href="#Java-IO-流" class="headerlink" title="Java IO 流"></a>Java IO 流</h1><h2 id="java-io-File-类的使用"><a href="#java-io-File-类的使用" class="headerlink" title="java.io.File 类的使用"></a>java.io.File 类的使用</h2><p><strong>File 类</strong></p><p><code>java.io.file</code> 类：文件和目录路径名的抽象表示形式，与平台无关</p><p><code>File</code> 能新建、删除、重命名文件和目录，但 <code>File</code> 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。</p><a id="more"></a><p>File 类的方法：</p><pre><code class="hljs Java">访问文件名：file.getName(); <span class="hljs-comment">// 获取文件名</span>file.getPath(); <span class="hljs-comment">// 获取文件或文件夹的路径,就是 new file 时候写的文件路径</span>file.getAbsolutePath(); <span class="hljs-comment">// 获取当前文件的绝对路径</span>file.getAbsoluteFile(); <span class="hljs-comment">// 获取一个用当前文件的绝对路径构建的file对象</span>file.getParent(); <span class="hljs-comment">// 返回当前文件或者文件夹的父级路径</span>file.renameTo(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"D:\\learn\\Java\\t1.txt"</span>));   <span class="hljs-comment">// 给文件或文件夹重命名</span>文件检测file.exists(); <span class="hljs-comment">// 判断文件或文件夹是否存在</span>file.canWrite();file.canRead();file.isFile(); <span class="hljs-comment">// 判断当前file对象是否是文件</span>file.isDictionary();file.lastModified(); <span class="hljs-comment">// 获取文件的最后修改时间，返回的是一个毫秒数</span>file.length();  <span class="hljs-comment">// 返回文件的长度，单位是字节数</span>文件的相关操作file.createNewFile();  <span class="hljs-comment">// 创建新文件</span>file.delete();  <span class="hljs-comment">// 删除文件</span>目录操作file.mkdir();  <span class="hljs-comment">// 创建单层目录</span>file.mkdirs(); <span class="hljs-comment">// 创建多层目录</span>file.list();  <span class="hljs-comment">// 返回当前文件夹的子集的名称，包括文件和目录</span>file.listFiles();  <span class="hljs-comment">// 返回当前文件夹的子集的File对象</span></code></pre><p><code>File</code> 对象可以作为参数传递给流的构造函数。</p><p><code>File</code> 类的常见构造方法：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">File</span><span class="hljs-params">(String pathname)</span><span class="hljs-keyword">public</span> <span class="hljs-title">File</span><span class="hljs-params">(String parent, String child)</span></span></code></pre><h2 id="IO-原理及流的分类"><a href="#IO-原理及流的分类" class="headerlink" title="IO 原理及流的分类"></a>IO 原理及流的分类</h2><p>IO 流用来处理设备之间的数据传输。</p><p>Java 程序中，对于数据的输入/输出操作以“流”的方式进行。</p><p>Java.io 包下提供了各种“流”类和接口，用以获取不同中类的数据，并通过标准的方法输入或输出数据。</p><p>输入 input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中</p><p>输出 output：将程序（内存）数据输出到磁盘、光盘等存储设备中</p><p><strong>流的分类</strong></p><p>按操作<strong>数据单位</strong>不同分为：字节流（8 bit），字符流（16 bit）</p><p>按数据流的流向不同分为：输入流、输出流</p><p>按流的角色的不同分为：节点流、处理流</p><div class="table-container"><table><thead><tr><th>抽象基类</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table></div><p>IO 流体系</p><div class="table-container"><table><thead><tr><th>分类</th><th>字节输入流</th><th>字节输出流</th><th>字符输入流</th><th>字符输出流</th></tr></thead><tbody><tr><td>抽象基类</td><td>InputStream</td><td>OutputStream</td><td>Reader</td><td>Writer</td></tr><tr><td>访问文件</td><td>FileInputStream</td><td>FileOutputStream</td><td>FileReader</td><td>FileWriter</td></tr><tr><td>缓冲流</td><td>BufferedInputStream</td><td>BufferedOutputStream</td><td>BufferedReader</td><td>BufferedWriter</td></tr><tr><td>转换流</td><td></td><td></td><td>InputStreamReader</td><td>OutputStreamWriter</td></tr></tbody></table></div><h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p><strong>文件字节流</strong></p><p>非常通用，可以用来操作字符的文档，还可以操作任何其他类型文件（图片、压缩包等），因为字节流直接使用二进制</p><p><strong>文件字符输入流</strong></p><p>读取文件操作步骤：</p><ol><li><p>建立一个流对象，将已存在的一个文件加载进流</p><p>FileReader fr = new FileReader(“Test.txt”);</p></li><li><p>创建一个临时存放数据的数组</p><p>char[] ch = new char[1024];</p></li><li><p>调用流对象的读取方法将流中的数据读入到数组中</p><p>fr.read(ch);</p></li></ol><p><strong>注意</strong></p><p>定义文件路径时，可以用 <code>/</code> 或 <code>\\</code></p><p>在写入一个文件时，如果目录下有同名文件将被覆盖</p><p>在读文件时，必须保证该文件已存在，否则出现异常。</p><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>为了提高数据读写的速度，Java API 提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组。</p><p>BufferedInputStream 和 BufferedOutputStream</p><p>BufferedReader 和 BufferedWriter</p><p>对于输出的缓冲流，写出的数据会先在内存中缓存，使用 flush() 将会使内存中的数据立刻写出。</p><p>缓冲流就是先把数据缓冲到内存里，在内存中去做io操作，基于内存的io操作大概能比基于硬盘的io操作快75000多倍。</p><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>转换流提供了在字节流和字符流之间的转换</p><p><code>InputStreamReader</code> 和 <code>OutputStreamWriter</code></p><p>字节流中的数据都是字符时，转成字符流操作更高效。</p><p><code>InputStreamReader</code> 用于将字节流中读取的字节按照字符集解码成字符，需要和 <code>InputStream</code> 套接.</p><h2 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h2><p><code>System.in</code> 和 <code>System.out</code> 分别代表了系统标准的输入和输出设备</p><p>默认输入设备是键盘，输出设备是显示器</p><p><code>System.in</code> 的类型是 <code>InputStream</code></p><p><code>System.out</code> 的类型是 <code>PrintStream</code>，其是 <code>OutputStream</code> 的子类 <code>FileOutputStream</code> 的子类</p><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p><code>PrintStream(字节打印流)</code> 和 <code>PrintWriter(字符打印流)</code> 提供了一系列重载的 <code>print</code> 和 <code>println</code> 方法，用于多种数据类型的输出。</p><p><code>PrintStream</code> 和 <code>PrintWriter</code> 的输出不会抛出异常，有自动 <code>flush</code> 功能。</p><p><code>System.out</code> 返回的是 <code>PrintStream</code> 的实例。</p><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>读取基本数据类型</p><p>DataInputStream </p><p>DataOutputStream</p><h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><p>ObjectInputStream</p><p>ObjectOutputStream</p><p>用于存储和读取对象的处理流。它的强大之处就是可以把 Java 中的对象写入到数据源中，也能把对象从数据源中还原回来。</p><p>序列化（Serialize）：用 <code>ObjectOutputStream</code> 类将一个 Java 写入IO流中</p><p>反序列化（Deserialize）：用 <code>ObjectInputStream</code> 类从IO流中恢复该 Java 对象</p><p>不能序列化 static 和 transient 修饰的成员变量。因为序列化和反序列化针对的是<strong>对象</strong>的各种属性，不包括类的属性。</p><p>序列化的好处是可将任何实现了 Serializable 接口的对象转换为字节数据，使其在保存和传输时可被还原。</p><p>如果需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口：<code>Serializable</code> 、<code>Externalizable</code> 一般用后面那个</p><p>凡是实现了 <code>Serializable</code>  接口的类都有一个表示序列化版本标识符的静态变量：</p><p><code>private static final long serialVersionUID;</code> <code>serialVersionUID</code> 表示不同版本的兼容性</p><p>若某个类实现了 <code>Serializable</code> 接口，该类的对象就是可序列化的：<br>    创建一个 <code>ObjectOutputStream</code><br>    调用 <code>ObjectOutputStream</code> 对象的 <code>writeObject(对象)</code> 方法输出可序列化对象。注意写出一次，操作 <code>flush()</code><br>反序列化<br>    创建一个 <code>ObjectInputStream</code><br>    调用 <code>readObject()</code> 方法读取流中的对象</p><h2 id="RandomAccessFile-类"><a href="#RandomAccessFile-类" class="headerlink" title="RandomAccessFile 类"></a>RandomAccessFile 类</h2><p>RandomAccessFile 类支持“随机访问”方式，程序可以直接跳到文件的任意位置来读、写文件</p><p>​    支持只访问文件的部分内容</p><p>​    可以向已存在的文件后追加内容</p><p>RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。    </p><p>RandomAccessFile 类对象可以自由移动记录指针：</p><p>   <code>long getFilePointer()</code>：获取文件记录<strong>指针</strong>的当前<strong>位置</strong></p><p>   <code>void seek(long pos)</code> ： 将文件记录指针定位到<strong>pos</strong> 位置</p><p><strong>构造器</strong></p><p>   <code>public RandomAccessFile(File file, String mode)</code></p><p>   <code>public RandomAccessFile(String name, String mode)</code></p><p>创建 RandomAccessFile 类实例需要指定一个 <code>mode</code> 参数，该参数指定 RandomAccessFile 的访问模式：</p><p><strong>r:</strong> 以只读方式打开</p><p><strong>rw</strong>：打开以便读取和写入</p><p><strong>rwd</strong>：打开以便读取和写入；同步文件内容的更新</p><p><strong>rws</strong>：打开以便读取和写入；同步文件内容和元数据的更新</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
      <tag>IO 流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 枚举类</title>
    <link href="/2019/10/15/Java-%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
    <url>/2019/10/15/Java-%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-枚举和注解"><a href="#Java-枚举和注解" class="headerlink" title="Java 枚举和注解"></a>Java 枚举和注解</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>在某些情况下，一个类的对象是有限而且固定的。</p><p>手动实现枚举类：</p><ul><li><code>private</code> 修饰构造器</li><li>属性使用 <code>private final</code> 修饰</li><li>把该类的所有实例都使用 <code>public static final</code> 修饰</li></ul><a id="more"></a><h3 id="enum-关键字用于定义枚举类"><a href="#enum-关键字用于定义枚举类" class="headerlink" title="enum 关键字用于定义枚举类"></a><code>enum</code> 关键字用于定义枚举类</h3><p>枚举类和普通类的区别：</p><ul><li>使用 <code>enum</code> 定义的枚举类默认继承了 <code>java.lang.Enum</code> 类</li><li>枚举类的构造器只能使用 <code>private</code> 访问控制符</li><li>枚举类的所有实例必须在枚举类中显式列出（<code>，</code>分隔 <code>；</code>结尾）。列出的所有实例系统会自动添加 <code>public static final</code> 修饰</li><li>所有的枚举类都提供了一个 <code>values</code> 方法，该方法可以很方便地遍历所有的枚举值</li></ul><p>JDK 1.5 中可以在 <code>switch</code> 表达式中使用枚举类的对象作为表达式，<code>case</code> 子句可以直接使用枚举值的名字，无需添加枚举类作为限定。</p><p>若枚举只有一个成员，则可以作为一种单子模式的实现方式。</p><h3 id="实现接口的枚举类"><a href="#实现接口的枚举类" class="headerlink" title="实现接口的枚举类"></a>实现接口的枚举类</h3><p>和普通 Java 类一样枚举类可以实现一个或多个接口</p><p>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法。</p><h2 id="Annotation（注解）概述"><a href="#Annotation（注解）概述" class="headerlink" title="Annotation（注解）概述"></a>Annotation（注解）概述</h2><p>从JDK5开始，Java增加了对元数据（MetaData）的支持，也就是 Annotation</p><p>Annotation 其实就是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用 Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。</p><p>Annotation 可以像修饰一样被使用，可用于<strong>修饰包，类，构造器，方法，成员变量，参数，局部变量的声明</strong>，这些信息被保存在 Annotation 的 <code>“name = value&quot;</code> 对中</p><p>Annotation 能被用来为程序元素（类，方法，成员变量等）设置元数据。</p><p>使用 Annotation 时要在其前面增加@符号，并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素。</p><p>三个基本的 Annotation：</p><ul><li>@Override ：限定重写父类方法，该注释只能用于方法</li><li>@Deprecated：用于表示某个程序元素（类、方法等）已过时</li><li>@SuppressWarnings：抑制编译器警告</li></ul><p>自定义 Annotation，使用 <code>@interface</code> 关键字</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 泛型</title>
    <link href="/2019/10/14/Java-%E6%B3%9B%E5%9E%8B/"/>
    <url>/2019/10/14/Java-%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-泛型"><a href="#Java-泛型" class="headerlink" title="Java 泛型"></a>Java 泛型</h1><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>只有指定类型才可以添加到集合中：类型安全</p><p>读取出来的对象不需要强转，便捷</p><p><strong>Java中的泛型，只在编译阶段有效。</strong>在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，<strong>泛型信息不会进入到运行阶段。</strong></p><a id="more"></a><h2 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h2><h3 id="1-泛型类"><a href="#1-泛型类" class="headerlink" title="1. 泛型类"></a>1. 泛型类</h3><p>对象实例化时不指定泛型，默认为Object</p><p>泛型不同的引用不能相互赋值</p><pre><code class="hljs Java"><span class="hljs-comment">/** * 泛型类 * <span class="hljs-doctag">@param</span> &lt;T&gt;  此处的泛型T可以任意取名，一般使用T(type) */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;    <span class="hljs-keyword">private</span> T t;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setT</span><span class="hljs-params">(T t)</span></span>&#123;        <span class="hljs-keyword">this</span>.t = t;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getT</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.t;    &#125;&#125;</code></pre><h3 id="2-泛型方法"><a href="#2-泛型方法" class="headerlink" title="2. 泛型方法"></a>2. 泛型方法</h3><p>方法，也可以被泛型化，不管此时定义在其中的类是不是泛型化的。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。</p><p>在类上定义的泛型，可以在普通的方法中使用。</p><p>在静态方法中，不能使用类定义的泛型，如果使用泛型，只能使用静态方法自己定义的泛型。</p><p>泛型方法在调用之前没有固定的数据类型，在调用时，传入的参数是什么类型，就会把泛型改成什么类型。也就说，泛型方法会在调用时确定泛型具体的数据类型。</p><h3 id="3-泛型接口"><a href="#3-泛型接口" class="headerlink" title="3. 泛型接口"></a>3. 泛型接口</h3><p><strong>接口定义</strong></p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;    <span class="hljs-function">T <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong>实现接口</strong></p><p>未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需要将泛型的声明也一起加到类中。</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitGenerator</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;&#125;</code></pre><p>传入泛型实参时，定义一个生产器实现这个接口，虽然只创建了一个泛型接口 <code>Generator&lt;T&gt;</code>, 但是我们可以为 <code>T</code> 传入无数个实参, 形成无数种类型的 Generator 接口</p><p>在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型。</p><pre><code class="hljs Java">Generator&lt;T&gt;, <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">next</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 中的T都要替换成传入的String类型</span></code></pre><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>不确定集合中的元素具体的数据类型，使用 <code>？</code> 表示所有类型</p><pre><code class="hljs Java"> <span class="hljs-comment">// test 方法需要一个list集合的参数，但是不确定list集合中数据的具体类型</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(List&lt;?&gt; list)</span></span>&#123; System.out.println(list);&#125;</code></pre><p><strong>有限制的通配符</strong></p><p><code>&lt;? extends Person&gt;</code>（无穷小，Person）</p><p>只允许泛型为 Person 及 Person 子类的引用调用</p><p><code>&lt;? super Person&gt;</code>（Person，无穷大）</p><p>只允许泛型为 Person 及 Person 父类的引用调用</p><p><code>&lt;? extends Comparable&gt;</code>（无穷小，Person）</p><p>只允许泛型为实现 Comparable 接口的实现类的引用调用</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读《Graph-Neural-Networks-A-Review-of-Methods-and-Applications》</title>
    <link href="/2019/10/13/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AGraph-Neural-Networks-A-Review-of-Methods-and-Applications%E3%80%8B/"/>
    <url>/2019/10/13/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AGraph-Neural-Networks-A-Review-of-Methods-and-Applications%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="论文阅读《Graph-Neural-Networks-A-Review-of-Methods-and-Applications》"><a href="#论文阅读《Graph-Neural-Networks-A-Review-of-Methods-and-Applications》" class="headerlink" title="论文阅读《Graph-Neural-Networks-A-Review-of-Methods-and-Applications》"></a>论文阅读《Graph-Neural-Networks-A-Review-of-Methods-and-Applications》</h1><h2 id="Graph-Nerual-Network"><a href="#Graph-Nerual-Network" class="headerlink" title="Graph Nerual Network"></a>Graph Nerual Network</h2>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>Graph Neural Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GNN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合</title>
    <link href="/2019/10/12/Java-%E9%9B%86%E5%90%88/"/>
    <url>/2019/10/12/Java-%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>Java 集合类存放于 <code>java.util</code> 包中，是一个用来存放对象的容器</p><ul><li>Java 集合只能存放对象。</li><li>集合存放的是多个对象的引用，对象本身还是存放在堆内存中</li><li>集合可以存放不同类型，不限数量的数据类型</li></ul><a id="more"></a><p>Java 集合可分为 <code>Set</code>、<code>List</code>、<code>Map</code> 三种大体系：</p><ul><li><code>Set</code>：无序、不可重复集合</li><li><code>List</code>：有序，可重复集合</li><li><code>Map</code>：具有映射关系的集合</li></ul><p>在 JDK5 之后，增加了泛型，Java集合可以记住容器中对象的数据类型</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p><code>HashSet</code> 是 <code>Set</code> 接口的典型实现，大多数时候使用 <code>Set</code> 集合时都使用这个实现类。我们大多数时候说的 <code>Set</code> 集合值得都是 <code>HashSet</code></p><p><code>HashSet</code> 按 <code>Hash</code> 算法来存储集合中的元素，因此具有很好的存取和查找性能。</p><p><code>HashSet</code> 具有以下特点：</p><ul><li>不能保证元素的排列顺序</li><li>不可重复</li><li><code>HashSet</code> 不是线程安全的</li><li>集合元素可以是 <code>null</code></li></ul><p>当向 <code>HashSet</code> 集合中存入一个元素时，<code>HashSet</code> 会调用该对象的 <code>hashCode()</code> 方法来得到该对象的 <code>hashCode</code> 值，然后根据 <code>hashCode</code> 值确定该对象在 <code>HashSet</code> 中的存储位置。</p><p>如果两个元素的 <code>equals()</code> 方法返回 <code>true</code>，但它们的 <code>hashCode()</code> 返回值不相等，<code>hashSet</code> 将会把它们存储在不同的位置，但依然可以添加成功。</p><p><strong>Hashset 方法</strong></p><pre><code class="hljs Java">set.add(); <span class="hljs-comment">// 添加元素</span>set.remove(); <span class="hljs-comment">// 移除元素</span>set.contains(); <span class="hljs-comment">// 判断是否包含某个元素</span>set.clear();<span class="hljs-comment">// 清空集合</span>set.size(); <span class="hljs-comment">// 集合中元素的个数</span><span class="hljs-comment">/* 集合的遍历 */</span><span class="hljs-comment">// 使用迭代器遍历集合</span>Iterator iterator = set.iterator();<span class="hljs-keyword">while</span> (iterator.hasNext())&#123;    System.out.println(iterator.next());&#125;<span class="hljs-comment">// for each 迭代集合</span><span class="hljs-keyword">for</span> (Object object: set) &#123;  <span class="hljs-comment">// 取出set中的每一个元素，赋值给object，直到循环set所有值</span>    System.out.println(object);&#125;</code></pre><p><strong>hashCode() 方法</strong></p><p>HashSet集合判断两个元素相等的标准：两个对象通过 <code>equals()</code> 方法比较相等，并且两个对象的 <code>hashCode()</code> 方法返回值也相等。</p><p>如果两个对象通过 <code>equals()</code> 方法返回 <code>true</code>，这两个对象的 <code>hashCode</code> 值也应该相同。</p><p>如果想让集合只能存同样类型的对象，使用<strong>泛型</strong>:</p><pre><code class="hljs Java">Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();  <span class="hljs-comment">// 该集合只能存 String 类型的数据</span></code></pre><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p><code>TreeSet</code> 是 <code>SortedSet</code> 接口的实现类，<code>TreeSet</code> 可以确保集合元素处于排序状态。<code>TreeSet</code> 支持两种排序方法：<strong>自然排序</strong>和<strong>定制排序</strong>。默认情况下，<code>TreeSet</code> 采用自然排序。</p><p><strong>自然排序</strong></p><p>排序：<code>TreeSet</code> 会调用集合元素的 <code>compareTo(Object obj)</code> 方法来比较元素之间的大小关系，然后将集合元素按升序排列</p><ul><li>如果 this &gt; obj, 返回正数 1</li><li>如果 this &lt; obj, 返回负数 -1</li><li>如果 this = obj, 返回 0，则认为这两个对象相等</li><li>必须放入同样类的对象（默认会进行排序）否则可能会发生类型转换异常，可以使用泛型来进行限制。</li></ul><p><strong>定制排序</strong></p><p>如果要实现定制排序，则需要在创建 <code>TreeSet</code> 集合对象时，提供一个 <code>Comparator</code> 接口的实现类对象。由该 <code>Comparator</code> 对象负责集合元素的排序逻辑。</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Person</span>&gt; </span>&#123;  <span class="hljs-comment">// 按照年龄排序</span>    <span class="hljs-keyword">int</span> age;    String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age, String name)</span></span>&#123;        <span class="hljs-keyword">this</span>.age = age;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person o1, Person o2)</span> </span>&#123;  <span class="hljs-comment">// 按年龄从小到大排序</span>        <span class="hljs-keyword">if</span> (o1.age &gt; o2.age)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (o1.age &lt; o2.age)&#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre><h3 id="List-与-ArrayList"><a href="#List-与-ArrayList" class="headerlink" title="List 与 ArrayList"></a>List 与 ArrayList</h3><p><code>List</code> 代表一个元素有序，且可重复的集合，集合中的每个元素都有其对应的顺序</p><p><code>List</code> 允许使用重复元素，可以通过索引来访问指定位置的元素集合</p><p><code>List</code> 默认按元素的添加顺序设置元素的索引</p><p><code>List</code> 集合里添加了一些根据索引来操作集合的方法</p><pre><code class="hljs Java">list.get(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 通过索引来访问指定位置的集合元素</span>list.add(<span class="hljs-number">1</span>,<span class="hljs-string">"f"</span>);  <span class="hljs-comment">// 在指定索引下标的位置插入数据</span>List&lt;String&gt; l = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();l.add(<span class="hljs-string">"123"</span>);l.add(<span class="hljs-string">"456"</span>);list.addAll(<span class="hljs-number">2</span>, l); <span class="hljs-comment">// 在指定索引下标的位置插入集合</span>list.indexOf(<span class="hljs-string">"d"</span>);  <span class="hljs-comment">// 获取指定元素在集合中第一次出现的索引下标</span>list.lastIndexOf(<span class="hljs-string">"d"</span>);  <span class="hljs-comment">// 获取指定元素在集合中最后一次出现的索引下标</span>list.remove(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 根据指定的索引下标移除数据</span>list.set(<span class="hljs-number">1</span>, <span class="hljs-string">"ff"</span>); <span class="hljs-comment">// 根据指定索引下标修改元素</span>List&lt;String&gt; sublist = list.subList(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);  <span class="hljs-comment">// 根据索引下标的起始位置截取元素，前闭后开</span></code></pre><h3 id="ArrayList-和-Vector"><a href="#ArrayList-和-Vector" class="headerlink" title="ArrayList 和 Vector"></a>ArrayList 和 Vector</h3><p><code>ArrayList</code> 和 <code>Vector</code> 是 <code>List</code> 接口的两个典型实现。</p><p>区别：</p><ul><li><code>Vector</code> 是一个古老的集合，通常建议使用 <code>ArrayList</code></li><li><code>ArrayList</code> 是线程不安全的， 而 <code>Vector</code> 是线程安全的</li><li>即使为保证 <code>List</code> 集合线程安全，也不推荐使用 <code>Vector</code></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><code>Map</code> 用于保存具有映射关系的数据，因此 <code>Map</code> 集合里保存着两组值，一组值用于保存 <code>Map</code> 里的 <code>Key</code>，另外一组用于保存 <code>Map</code> 里的 <code>Value</code></p><p><code>Map</code> 中的 <code>Key</code> 和 <code>Value</code> 都可以是任何引用类型的数据</p><p><code>Map</code> 中的 <code>key</code> 不允许重复，即同一个 <code>Map</code> 对象的任何两个 <code>Key</code> 通过 <code>equals()</code> 方法比较返回 <code>false</code></p><p><code>Key</code> 和 <code>Value</code> 之间存在单向一对一关系，即通过指定的 <code>Key</code> 总能找到唯一的确定的 <code>Value</code> </p><pre><code class="hljs Java">map.put(<span class="hljs-string">"b"</span>,<span class="hljs-number">1</span>);  <span class="hljs-comment">// 添加数据</span>   map.get(<span class="hljs-string">"b"</span>);  <span class="hljs-comment">// 根据 key 取值</span>map.remove(<span class="hljs-string">"c"</span>);  <span class="hljs-comment">// 根据 key 移除键值对</span>map.size();  <span class="hljs-comment">// map 集合的元素个数</span>System.out.println(map.containsKey(<span class="hljs-string">"e"</span>));  <span class="hljs-comment">// 判断当前的 map 集合是否包含指定的 key</span>System.out.println(map.containsValue(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 判断当前的 map 集合是否包含指定的 value</span><span class="hljs-comment">// 遍历 map 集合</span>Set&lt;String&gt; keySet = map.keySet(); <span class="hljs-comment">// 获取 map 所有的 key</span>map.values(); <span class="hljs-comment">// 获取 map 所有的 value</span><span class="hljs-keyword">for</span> (String key:keySet)&#123;System.out.println(<span class="hljs-string">"Key: "</span> + key + <span class="hljs-string">"\t Value: "</span>+ map.get(key));&#125;<span class="hljs-comment">// map.entrySet();</span>Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();<span class="hljs-keyword">for</span>(Map.Entry&lt;String, Integer&gt; en: entrySet)&#123;System.out.println(<span class="hljs-string">"Key: "</span> + en.getKey() + <span class="hljs-string">"\t Value: "</span> + en.getValue());&#125;</code></pre><h3 id="HashMap-和-Hashtable"><a href="#HashMap-和-Hashtable" class="headerlink" title="HashMap 和 Hashtable"></a>HashMap 和 Hashtable</h3><p><code>HashMap</code> 和 <code>HashValue</code> 是 Map 接口的两个典型实现类。</p><p>区别：</p><ul><li><code>Hashtable</code> 是一个古老的 Map 实现类，不建议使用</li><li><code>Hashtable</code> 是一个线程安全的 Map 实现，但 <code>HashMap</code> 是线程不安全的</li><li><code>Hashtable</code> 不允许使用 <code>null</code> 作为 <code>key</code> 和 <code>value</code>， 而 <code>HashMap</code> 可以</li></ul><p>与 <code>HashSet</code> 集合不能保证元素的顺序一样，<code>Hashtable</code>、<code>HashMap</code> 也不能保证其中 <code>key-value</code> 对的顺序</p><p><code>Hashtable</code>、<code>HashMap</code> 判断两个 <code>Key</code> 相等的标准是：两个 <code>key</code> 通过 <code>equals()</code> 方法返回 <code>true</code>，<code>hashCode</code>值也相等</p><p><code>Hashtable</code>、<code>HashMap</code>  相等的标准是：两个<code>value</code> 通过 <code>equalsHashMap</code> 判断两个 <code>Values</code> 方法返回 <code>true</code></p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p><code>TreeMap</code> 存储 <code>Key-Value</code> 对时，需要根据 <code>Key</code> 对 <code>key-value</code> 对进行排序。<code>TreeMap</code> 可以保证所有的 <code>Key-Value</code> 对处于有序状态.</p><p><code>TreeMap</code> 的 <code>key</code> 的排序：</p><ul><li>自然排序：<code>TreeMap</code> 的所有的 <code>Key</code> 必须实现 <code>Comparable</code> 接口，而且所有的 <code>Key</code> 应该是同一个类的对象，否则会抛出 <code>ClassCastException</code></li><li>定制排序：创建 <code>TreeMap</code> 时，传入一个 <code>Comparator</code> 对象，该对象负责对 <code>TreeMap</code> 中所有 <code>key</code> 进行排序。此时，不需要 <code>Map</code> 的 <code>Key</code> 实现 <code>Comparable</code> 接口</li></ul><h3 id="操作集合的工具类-Collections"><a href="#操作集合的工具类-Collections" class="headerlink" title="操作集合的工具类 Collections"></a>操作集合的工具类 Collections</h3><p>Collections 是一个操作 Set、List 和 Map 等集合的工具类</p><p>Collections 中提供了大量方法对集合进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。</p><p>排序操作：</p><ul><li><code>reverse(List)</code>: 反转 List 元素顺序</li><li><code>shuffle(List)</code>  对 List 集合元素进行随机排序</li><li><code>sort(List)</code> 根据元素的自然顺序对指定 List 集合元素按升序排序</li><li><code>sort(List, Comparator)</code> 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li><li><code>swap(List, int i, int j)</code> 将指定 list 集合中的 i 处元素 和 j 处元素进行交换</li></ul><p><strong>查找、替换</strong></p><ul><li><code>Object max(Collection)</code>：根据元素的自然顺序，返回给定集合中的最大元素</li><li><code>Object max(Collection, Comparator)</code>：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li><li><code>Object min(Collection)</code></li><li><code>Object min(Collection, Comparator)</code></li><li><code>int frequency(Collection, Object)</code>：返回指定集合中指定元素的出现次数</li><li><code>boolean replaceAll(List list, Object oldVal, Object newVal)</code> ：使用新值替换 List 对象的所有指定旧值</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
      <tag>Java 集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 异常处理</title>
    <link href="/2019/10/11/Java-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2019/10/11/Java-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java 异常处理"></a>Java 异常处理</h1><p>任何一种程序设计语言设计的程序在运行时都有可能出现错误，例如：除数为0，数组下标越界，要读写的文件不存在等</p><p>捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生</p><a id="more"></a><p>对于这些错误，一般有两种解决方法：</p><ul><li>遇到错误就终止程序的运行</li><li>由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理</li></ul><p><strong>异常</strong>：在Java语言中，将程序执行中发生的不正常情况称为“异常”</p><p>Java中的异常用于处理非预期的情况，如文件没找到，、网络错误、非法参数</p><p>Java程序运行过程中所发生的异常事件可分为两类：</p><ul><li>Error：JVM系统内部错误、资源耗尽等严重情况</li><li>Exception：其他因编程错误或偶然的外在因素导致的一般性问题，例如：<ul><li>空指针访问</li><li>试图读取不存在的文件</li><li>网络连接中断</li></ul></li></ul><p><strong>异常处理机制</strong></p><p>在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x/y运算时，要检测分母为0，数据为空，输入的不是数据而是字符等。过多的分支会导致程序的代码加长，可读性差。因此采用异常机制。</p><p>Java 异常处理：Java采用异常处理机制，将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁，并易于维护</p><p>Java 提供的是异常处理的抓抛模型。</p><p>Java 程序的执行过程中如出现异常，会自动生成一个异常类对象，该异常对象将被提交给 Java 运行时系统，这个过程为抛出（throw）异常。</p><p>如果一个方法内抛出异常，该异常会被抛出到调用方法中。如果异常没有在调用方法中处理，它继续被抛出给这个方法的调用者。这个程序将一直继续下去，直到异常被处理。这一过程称为捕获（catch）异常。</p><p>如果一个异常回到 <code>main()</code> 方法，并且 <code>main()</code> 也不处理，则程序运行终止。</p><p>程序员通常只能处理 Exception，而对 Error 无能为力</p><p><strong>捕获异常</strong></p><pre><code class="hljs Java"><span class="hljs-keyword">try</span>&#123;    ... <span class="hljs-comment">// 可能产生异常的代码</span>&#125;<span class="hljs-keyword">catch</span>(ExceptionName1 e)&#123;    ... <span class="hljs-comment">// 当产生ExceptionName1 型异常时的处置措施</span>&#125;<span class="hljs-keyword">catch</span>(ExceptionName2 e)&#123;    ... <span class="hljs-comment">// 当产生ExceptionName2 型异常时的处置措施</span>&#125;[<span class="hljs-keyword">finally</span>]&#123;    ... <span class="hljs-comment">// 无条件执行的语句</span>&#125;</code></pre><p><strong>声明抛出异常</strong></p><p>声明抛出异常是Java中处理异常的第二种方式</p><p>​    如果一个方法（中的语句执行）可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显式地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理</p><p>​    在方法声明中用  <code>throws</code> 子句可以声明抛出异常的列表， <code>throws</code> 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFile</span><span class="hljs-params">(String file)</span> <span class="hljs-keyword">throws</span> FileNotFoundException</span>&#123;    ......    <span class="hljs-comment">// 读文件的操作可能产生 FileNotFoundException 类型的异常</span>    FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(file);    ......&#125;</code></pre><p>重写方法声明抛出异常的原则：重写方法不能抛出比被重写方法范围更大的异常类型，即<strong>子类不能抛出比父类方法更大范围的异常</strong></p><p><strong>人工抛出异常</strong></p><p><strong>创建用户自定义异常类</strong></p><p>用户自定义异常类 <code>MyException</code> ，用于描述数据取值范围错误信息。用户自己的异常类必须继承现有的异常类。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读《Connecting Users across Social Media Sites: A Behavioral-Modeling Approach》</title>
    <link href="/2019/10/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AConnecting-Users-across-Social-Media-Sites-A-Behavioral-Modeling-Approach%E3%80%8B/"/>
    <url>/2019/10/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AConnecting-Users-across-Social-Media-Sites-A-Behavioral-Modeling-Approach%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Connecting-Users-across-Social-Media-Sites-A-Behavioral-Modeling-Approach"><a href="#Connecting-Users-across-Social-Media-Sites-A-Behavioral-Modeling-Approach" class="headerlink" title="Connecting Users across Social Media Sites: A Behavioral-Modeling Approach"></a>Connecting Users across Social Media Sites: A Behavioral-Modeling Approach</h1><blockquote><p>Zafarani R , Liu H . Connecting users across social media sites: a behavioral-modeling approach.[C]// Acm Sigkdd International Conference on Knowledge Discovery &amp; Data Mining. ACM, 2013.</p></blockquote><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>这篇文章真得是绝了，信息量少，通过各种角度各种层面构建特征的方式可谓无所不用其极。但也值得学习。</p><p>而且必须拿到很多个社交网站的用户名数据，先验用户名数据集才比较好。</p><p>2013年发表在KDD上的文章，由此可见计算机发展得迅速。</p><a id="more"></a><h2 id="Research-Objective"><a href="#Research-Objective" class="headerlink" title="Research Objective"></a>Research Objective</h2><p>解决跨社交媒体的用户标识问题：</p><ol><li>识别用户的独一无二的行为模式</li><li>利用这些行为模式构建特征</li><li>使用机器学习方法进行用户的识别</li></ol><h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><p>使用最少的信息确定两个用户是否是同一个身份。</p><p>已知一个用户在一些社交网站上的 <strong>用户名</strong> ，现有一个候选用户名 c ，判断c是否是该用户在该社交网站上的用户名。</p><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h3 id="MOBIUS：行为模式与特征构建"><a href="#MOBIUS：行为模式与特征构建" class="headerlink" title="MOBIUS：行为模式与特征构建"></a>MOBIUS：行为模式与特征构建</h3><p>MOBIUS: MOdeling Behavior for Identifying Users across Sites </p><p>在一个社交网络上，尽量使自己的用户名和别人的不同。人类个体倾向于选择 “not long, not random, and have abundant redundancy”的用户名，这可以帮助我们挖掘其中的特征。</p><p>从用户选择不同社交网络用户名的行为模式中可以提取一下三类特征：</p><ul><li>（candidate）Username Features：从候选用户名中提取的特征，例如：用户名的长度</li><li>Prior-Username Features：例如：先验用户名的个数</li><li>Username  &lt;-&gt; Prior-Username Features ：先验用户名和候选用户名之间的关系，例如：相似性</li></ul><h4 id="1-Patterns-due-to-Human-Limitations"><a href="#1-Patterns-due-to-Human-Limitations" class="headerlink" title="1. Patterns due to Human Limitations"></a>1. Patterns due to Human Limitations</h4><ul><li><p>Limitations in Time and Memory </p><ul><li><p>选择之前用过的用户名 — &gt; 将候选用户名 c 在以前的用户名中重复的次数作为一个特征</p></li><li><p>用户名的长度：$\min <em>{u \in U} l</em>{u} \leq l<em>{c} \leq \max </em>{u \in U} l_{u}$  候选用户名的长度应该在之前用过的用户名的长度之间。 — &gt;  将候选用户名的长度和以前用户名的长度分布作为特征。</p><p>用户名长度的分布特征可以用一个五元组来表示：</p></li></ul><script type="math/tex; mode=display">\left(\mathbb{E}\left[l_{u}\right], \sigma\left[l_{u}\right], \operatorname{med}\left[l_{u}\right], \min _{u \in U} l_{u}, \max _{u \in U} l_{u}\right)</script><ul><li>在之前的用户名中有多少个唯一的新的用户名 $uniqueness=\frac{|u n i q(U)|}{|U|}$</li></ul></li><li><p>Knowledge Limitation</p><ul><li>用户名中单词的数量</li><li>用户名单词数量的分布特征</li><li>用户名使用的字母的数量</li></ul></li></ul><h4 id="2-外在因素"><a href="#2-外在因素" class="headerlink" title="2. 外在因素"></a>2. 外在因素</h4><ul><li>Typing Patterns </li><li>Language Patterns ：用户名的语言</li></ul><h4 id="3-内部因素"><a href="#3-内部因素" class="headerlink" title="3. 内部因素"></a>3. 内部因素</h4><ul><li>Personal Attributes and Personality Traits <ul><li>Personal Information：使用字母的分布情况</li><li>Username Randomness：用户名字母分布的熵</li></ul></li><li>Habits<ul><li>Username Modification </li><li>Generating Similar Usernames </li><li>Username Observation Likelihood </li></ul></li></ul><p><img src="/2019/10/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AConnecting-Users-across-Social-Media-Sites-A-Behavioral-Modeling-Approach%E3%80%8B/features.png" srcset="/img/loading.gif" alt="features"></p><h3 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h3><p>Naive Bayes </p><p>十折交叉验证</p><h4 id="Feature-Importance-Analysis"><a href="#Feature-Importance-Analysis" class="headerlink" title="Feature Importance Analysis"></a>Feature Importance Analysis</h4><p>odds-ratios（逻辑回归系数）</p>]]></content>
    
    
    <categories>
      
      <category>科研论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Social Networks</tag>
      
      <tag>User Identity Linkage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读《A comparative study on network alignment techniques》</title>
    <link href="/2019/10/07/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-comparative-study-on-network-alignment-techniques%E3%80%8B/"/>
    <url>/2019/10/07/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-comparative-study-on-network-alignment-techniques%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="A-comparative-study-on-network-alignment-techniques"><a href="#A-comparative-study-on-network-alignment-techniques" class="headerlink" title="A comparative study on network alignment techniques"></a>A comparative study on network alignment techniques</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>从矩阵对齐和网络表示学习的角度总结了state-of-the-art的7种方法，并建立了一个统一的基准平台。同时他们还研究了不同网络因素对于这些方法的影响。</p><p>这篇文章对于7种方法的介绍非常详细（数学真得好难），可以参考。</p><p>但是数据集对于该问题是主要的影响因素，但是公开数据集特别少。</p><a id="more"></a><h2 id="Research-Objective"><a href="#Research-Objective" class="headerlink" title="Research Objective"></a>Research Objective</h2><p>比较现有网络对齐的方法</p><p>评估公共框架下的 Network Alignment 技术</p><p>本研究的主要目的是提供一个灵活而强大的工具，以支持比较和促进网络对齐技术的基准分析。</p><h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><p>文章中将目前的 Network Align 方法分为 <strong>spectral methods</strong>（基于邻接矩阵的操作） 和 <strong>network representation methods</strong> (节点用嵌入向量表示，能够捕捉到网络的结构信息)</p><p>虽然Network Alignment方法的研究已经很长时间了，但由于缺少公共数据集和共同的评价指标，还没有比较过这些方法的性能。</p><h3 id="Network-alignment-methods"><a href="#Network-alignment-methods" class="headerlink" title="Network alignment methods"></a>Network alignment methods</h3><p>网络对齐技术利用结构一致性和属性一致性假设来构建它们的模型。</p><p>结构一致性：同质性原则，即邻近的节点倾向于在不同的网络中维持它们之间的关系</p><p>属性一致性：属于同一身份的在不同网络上的节点可能保持相同的属性(特征)</p><ul><li><h4 id="Spectral-methods-—-matrix-factorization-矩阵分解"><a href="#Spectral-methods-—-matrix-factorization-矩阵分解" class="headerlink" title="Spectral methods — matrix factorization 矩阵分解"></a>Spectral methods — matrix factorization 矩阵分解</h4><p>使用矩阵分解，直接计算对齐矩阵 S </p><p><img src="/2019/10/07/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-comparative-study-on-network-alignment-techniques%E3%80%8B/spectral_method.png" srcset="/img/loading.gif" alt="spectral_method"></p><p>将输入的图用连接矩阵的形式表示，Spectral methods 以损失函数的形式定义模型，模型考虑了源和目标网络的邻接矩阵；节点特征为常量，对齐矩阵S为变量。在对准过程中，根据结构和/或属性一致性假设，通过优化损失函数来学习得到对准矩阵。</p><p>Spectral methods 不同之处在于构建模型时使用什么一致性原则以及该原则如何使用的</p><ul><li><p><strong>IsoRank</strong>：如果来自不同网络的两个节点的邻居是相似的，那么这两个节点是相似的。因此该方法中，节点的相似性取决于两个节点邻居的相似性。</p><p>similarity：</p><script type="math/tex; mode=display">\mathbf{S}\left(u_{s}, v_{t}\right)=\sum_{w_{s} \in N\left(u_{s}\right)} \sum_{w_{t} \in N\left(v_{t}\right)} \frac{1}{\left|N\left(u_{s}\right)\right|\left|N\left(v_{t}\right)\right|} \mathbf{S}\left(w_{s}, w_{t}\right)  \\u_{s}源网络的节点，v_t目标网络的节点，N(u)节点u的邻居集合  \\上面的公式可以写成：S=CS \\where \\\mathbf{C}[i, j][u, v]=\left\{\begin{array}{ll}{\frac{1}{|N(u)||N(v)|},} & {\text { if }(i, u) \in E_{s},(i, v) \in E_{t}} \\ {0,} & {\text { otherwise }}\end{array}\right.  \\通过迭代的方法更新S\\\mathbf{S}^{k+1} \leftarrow \frac{\mathbf{C S}^{k}}{\left|\mathbf{C S}^{k}\right|}  \\其中S^{k}是第k次迭代的对齐矩阵</script><p>该方法对于网络的结构较敏感</p></li><li><p><strong>BigAlign</strong></p><p>利用网络节点的原始特征和手工提取的特征，如节点度、权重、集群系数等，将源网络和目标网络转换成二分图，从而解决网络对齐问题。</p><p>求置换矩阵 P，使损失函数最小化:</p><script type="math/tex; mode=display">\mathbb{L}(\mathbf{P})=\left\|\mathbf{P D}_{s} \mathbf{P}^{T}-\mathbf{D}_{t}\right\|_{F}^{2}</script><p>P 用于对 $D<em>{s}$ 的行进行重新排序，$P^{t}$ 用于对 $D</em>{t}$ 的列进行重新排序。难解。</p><p>将图转化成二分图然后最小化损失函数：</p><script type="math/tex; mode=display">\begin{aligned} \mathbb{L}(\mathbf{P}, \mathbf{Q}) &=\left\|\mathbf{P D}_{s} \mathbf{Q}-\mathbf{D}_{t}\right\|_{F}^{2}+\lambda \sum_{i, j} \mathbf{P}(i, j)+\phi \sum_{i, j} \mathbf{Q}(i, j) \\ &=\operatorname{Tr}\left(\mathbf{P D}_{s} \mathbf{Q}\left(\mathbf{P D}_{s} \mathbf{Q}\right)^{T}-2 \mathbf{P D}_{s} \mathbf{Q} \mathbf{D}_{t}^{T}\right)+\lambda \mathbf{1}^{T} \mathbf{P} \mathbf{1}+\phi \mathbf{1}^{T} \mathbf{Q} \mathbf{1} \end{aligned} \\其中 Tr(·) 是矩阵的迹, \lambda \sum_{i, j} \mathbf{P}(i, j) 是矩阵的稀疏性约束 \\</script><p>上面的损失函数可以通过 <strong>alternating projected gradient descent (APGD)  </strong>来优化：</p><script type="math/tex; mode=display">\begin{array}{l}{\mathbf{P}_{k+1}=\mathbf{P}_{k}-\eta_{P} \cdot\left(2\left(\mathbf{P}_{k} \mathbf{D}_{s} \mathbf{Q}_{k}-\mathbf{D}_{t}\right) \mathbf{Q}_{k}^{T} \mathbf{D}_{s}^{T}+\lambda \mathbf{1} \mathbf{I}^{T}\right)} \\ {\left.\mathbf{Q}_{k+1}=\mathbf{Q}_{k}-\eta_{Q} \cdot\left(2 \mathbf{D}_{s}^{T} \mathbf{P}_{k+1}^{T} \mathbf{D}_{s} \mathbf{Q}_{k}-\mathbf{D}_{t}\right)+\phi \mathbf{1} \mathbf{1}^{T}\right)}\end{array} \\P_k 是第k次迭代的矩阵P，\eta_{P},\eta_{Q}为APGD算法的步长</script><p>仅用属性信息而忽略了拓扑信息。</p></li><li><p><strong>FINAL</strong></p><p>通过定义结构相似性、节点特征相似性和边特征的相似性条件</p><script type="math/tex; mode=display">\begin{aligned} \mathbb{L}(\mathbf{S}) &=\sum_{u_{s}, v_{s}, u_{t}, v_{t}}\left[\frac{\mathbf{S}\left(u_{s}, u_{t}\right)}{\sqrt{f\left(u_{s}, u_{t}\right)}}-\frac{\mathbf{S}\left(v_{s}, v_{t}\right)}{\sqrt{f\left(v_{s}, v_{t}\right)}}\right] \\ & \times \mathbf{D}_{s}\left(u_{s}, v_{s}\right) \mathbf{D}_{t}\left(u_{t}, v_{t}\right) \end{aligned} \\\begin{array}{l}{\times \mathbb{1}\left(A\left(u_{s}\right)=A\left(u_{t}\right)\right) \mathbb{1}\left(A\left(v_{s}\right)=A\left(v_{t}\right)\right)} \\ {\times \mathbb{1}\left(A_{e}\left(u_{s}, v_{s}\right)=A_{e}\left(u_{t}, v_{t}\right)\right)}\end{array} \\其中A_e是边属性矩阵，\mathbb{1}(\cdot)是一个指示函数，如果括号中的条件正确，则返回1，\sqrt{f\left(u, u\right)} 是一个归一化因子</script><p><img src="/2019/10/07/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-comparative-study-on-network-alignment-techniques%E3%80%8B/FINAL.png" srcset="/img/loading.gif" alt="FINAL"></p><blockquote><p>数学好难，没看懂。。。</p></blockquote></li><li><p><strong>REGAL</strong></p><p>两个节点之间的相似性：</p><script type="math/tex; mode=display">\mathbf{S}^{\prime}(u, v)=\exp \left(-\lambda_{s} \cdot\left\|\mathbf{d}_{u}-\mathbf{d}_{v}\right\|^{2}-\lambda_{a} \cdot \operatorname{dist}(\mathbf{A}(u), \mathbf{A}(v))\right)</script></li><li></li></ul></li><li><h4 id="Representation-learning-methods"><a href="#Representation-learning-methods" class="headerlink" title="Representation learning methods"></a>Representation learning methods</h4><p>embedding generation 嵌入的生成</p><p>alignment matrix generation 对齐矩阵的生成</p><p>对于基于嵌入的网络对齐方法，不同之处在于embedding function 和 mapping function</p><ul><li><p><strong>PALE</strong></p><p><img src="/2019/10/07/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-comparative-study-on-network-alignment-techniques%E3%80%8B/PALE.png" srcset="/img/loading.gif" alt="PALE"></p><blockquote><p><a href="https://tiantianliu2018.github.io/2019/09/28/论文阅读《Predict-Anchor-Links-across-Social-Networks-via-an-Embedding-Approach》/">https://tiantianliu2018.github.io/2019/09/28/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8APredict-Anchor-Links-across-Social-Networks-via-an-Embedding-Approach%E3%80%8B/</a></p><p>我之前的阅读笔记。</p></blockquote><p>首先对网络进行扩展：如果在source网络中 $u_s$ 和 $v_s$存在边，并且知道这两个在target网络中对应的节点 $u_t$ 和 $v_t$, 那么  $u_t$ 和 $v_t$ 之间也应该有边，因此通过这样的方式扩展网络</p><p><strong>Emdedding function</strong></p><script type="math/tex; mode=display">\theta(v_i) = E[i]</script><p>其中 $E$ 是 embedding matrix，它是通过最小化如下损失得到的：</p><script type="math/tex; mode=display">\mathbb{L}(\mathbf{E})=\log \sigma\left(\mathbf{u}^{T} \cdot \mathbf{v}\right)+\sum_{k=1}^{K} \mathbb{E}_{w \alpha P_{n}(v)}\left[\log \left(1-\sigma\left(\mathbf{u}^{T} \cdot \mathbf{w}\right)\right)\right]</script><p>其中 $(u,v) \in E$  是观测到的边，$w$ 是通过在E中负采样的节点</p><p><strong>Mapping function</strong></p><script type="math/tex; mode=display">\phi\left(\mathbf{u}_{s}\right)=\mathbf{M} \times \mathbf{u}_{s}</script><p>$M$ 是一个$d×d$ 的矩阵，通过最小化下面的损失函数得到：</p><script type="math/tex; mode=display">\mathbb{L}(\mathbf{M})=\sum_{\mathbf{H}\left(v_{s}, v_{t}\right)=1}\left\|\phi\left(\mathbf{v}_{\mathbf{s}}\right)-\mathbf{v}_{t}\right\|</script><p>$H$ 是先验对齐矩阵</p></li><li><p><strong>DeepLink</strong></p><p>embedding graph 与PALE是一样的，但在mapping function中考虑了mapping的方向</p><p><img src="/2019/10/07/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-comparative-study-on-network-alignment-techniques%E3%80%8B/DEEPLINK.png" srcset="/img/loading.gif" alt="DEEPLINK"></p><p><strong>Emdedding function</strong></p><script type="math/tex; mode=display">\theta(v_i) = E[i]</script><p>参数 $E$ 的 loss function:</p><script type="math/tex; mode=display">\mathbb{L}_{\theta}(\mathbf{E})=\log \sigma(\mathbf{u} \cdot \mathbf{v})+\sum_{k=1}^{K} \mathbb{E}_{w \propto P_{n}(v)}[\log (1-\sigma(\mathbf{u} \cdot \mathbf{w}))]</script><p>DeepLink方法认为如果 $v$ 是 $u$随机游走过程中的节点，则认为这两个节点相似。</p><p><strong>Mapping function</strong></p><p>从源网络 $G_s$ 到目标网络 $G_t$ 的 mapping function</p><script type="math/tex; mode=display">\phi_{s, t}\left(\mathbf{u}_{s}\right)=\mathbf{M}_{s, t} \times \mathbf{u}_{s}+\mathbf{b}_{s, t}</script><p>类似的 从目标网络 $G_t$ 到源网络 $G_s$ 的 mapping function</p><script type="math/tex; mode=display">\phi_{t, s}\left(\mathbf{u}_{t}\right)=\mathbf{M}_{t, s} \times \mathbf{v}_{t}+\mathbf{b}_{t, s}</script><p>参数 $\phi<em>{s, t}$ 通过最优化如下loss function得到（$\phi</em>{t, s}$ 类似）：</p><script type="math/tex; mode=display">\mathbb{L}\left(\mathbf{W}_{s, t}, \mathbf{b}_{s, t}\right) =\sum_{\left(v_{s}, v_{t}\right) \in H} \min \left(1-\cos \left(\phi\left(\mathbf{v}_{s}\right), \mathbf{v}_{t}\right)\right)</script><p>对于两个网络中的同一个用户，他们的嵌入向量应该是相似的，因此，通过最小化损失函数来改进 $\phi<em>{s, t}$ 和 $\phi</em>{t, s}$:</p><script type="math/tex; mode=display">\mathbb{L}\left(\mathbf{W}_{s, t}, \mathbf{b}_{s, t}, \mathbf{W}_{t, s}, \mathbf{b}_{t, s}\right)=\operatorname{dist}\left(\phi_{t, s}\left(\phi_{s, t}(\mathbf{u})\right), \mathbf{u}\right)</script><p>对于监督学习，最大化 reward function</p><script type="math/tex; mode=display">r_{s, t}^{u}=\frac{1}{k} \sum_{w \in T_{k}(u)} \log (\cos (\mathbf{w}, \mathbf{v})+1)  \\其中 T_k(u) 是G_t中与\phi_{s,t}(u) embedding最接近的top-k个节点  \\\phi_{t,s}的reward \, function 为：\\r_{t, s}^{v}=\frac{1}{k} \sum_{w \in T_{k}(v)} \log (\cos (\mathbf{w}, \mathbf{u})+1)</script><blockquote><p><a href="https://tiantianliu2018.github.io/2019/09/15/论文阅读《DeepLink-A-Deep-Learning-Approach-for-User-Identity-Linkage》/">https://tiantianliu2018.github.io/2019/09/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADeepLink-A-Deep-Learning-Approach-for-User-Identity-Linkage%E3%80%8B/</a><br> 之前的论文阅读笔记<br> 又一大堆数学公式推导，好像没有看下去。</p></blockquote></li><li><p><strong>IONE</strong></p><p>IONE 与 PALE 的 mapping function 是相同的，但是其 embedding function 更加复杂，它在计算节点的嵌入时考虑了节点的邻居特征。</p><p><strong>Embedding function</strong></p><p>一个 embedding 矩阵，其中的每一行是由三个向量拼接到一起的：节点向量、输入上下文向量、输出上下文向量，最终其 embedding function 为：</p><script type="math/tex; mode=display">\theta_i = E[i], E \in \mathbb{R}^{|V| \times 3 d}</script><p>该方法的思想是：一个节点的节点向量可以影响其邻居的输入上下文向量，而其邻居的节点向量可以影响其输出上下文向量。</p><p>为了学习 $E$, 该方法需要满足两个目标：</p><ol><li><p>每个图中相邻的节点应该具有类似的节点嵌入</p><p>为了实现该目标，可以通过考虑一个节点向量相对于其邻居的输入上下文向量的贡献概率来实现：</p><script type="math/tex; mode=display">p_{1}(u | v)=\frac{\exp \left(\mathbf{u}^{\prime T} \cdot \mathbf{v}\right)}{\sum_{w \in G} \exp \left(\mathbf{w}^{\prime T} \cdot \mathbf{v}\right)}</script><p>其经验定义为：</p><script type="math/tex; mode=display">\hat{p}_{1}(u, v)=\frac{w_{u, v}}{|\{v |(u, v) \in E\}|}\\其中w_{u,v}是边(u,v)的权重</script><p>类似的，一个节点向量对其邻居的输出上下文向量的贡献的概率及其经验定义：</p><script type="math/tex; mode=display">\begin{aligned} p_{2}(v | u) &=\frac{\exp \left(\mathbf{v}^{\prime \prime T} \cdot \mathbf{u}\right)}{\sum_{w \in G} \exp \left(\mathbf{w}^{\prime \prime} T \cdot \mathbf{u}\right)} \\ \hat{p}_{2}(u, v) &=\frac{w_{u, v}}{|\{v |(v, u) \in E\}|} \end{aligned}</script><p>$p_1$ 应该和 $p_2$ 是相似的，于是有如下目标函数：</p><script type="math/tex; mode=display">\begin{aligned} \mathbb{L}_{1}(\mathbf{E})=&-\sum_{G \in\left\{G_{s}, G_{t}\right\}} \sum_{(u, v) \in G} w_{u, v} \log p_{1}(v | u) \\ &-\sum_{G \in\left\{G_{s}, G_{t}\right\}} \sum_{(u, v) \in G} w_{u, v} \log p_{2}(u | v) \end{aligned}</script></li><li><p>具有近似嵌入的节点是很好的对齐节点的候选节点</p><p>在两个网络中，两个节点如果是同一个用户，那么这两个节点是可以相互代替的，其代替的程度应该是由这两个节点是同一个用户的可信度确定的，基于这一点，对目标函数L1进行修改，将相应节点的信息考虑如下：</p><script type="math/tex; mode=display">\begin{aligned} \mathbb{L}_{2}(\mathbf{E})=&-\sum_{w_{t} \in G_{t}} \sum_{\left(u_{s}, v_{s}\right) \in V_{s}} w_{u_{s}, v_{s}} p_{a}\left(u_{s} | w_{t}\right) \log p_{1}\left(v_{s} | w_{t}\right) \\ &-\sum_{w_{t} \in G_{t}} \sum_{\left(u_{s}, v_{s}\right) \in V_{s}} w_{u_{s}, v_{s}} p_{a}\left(v_{s} | w_{t}\right) \log p_{1}\left(u_{s} | w_{t}\right) \\ &-\sum_{w_{s} \in G_{s}} \sum_{\left(u_{t}, v_{t}\right) \in V_{t}} w_{u_{t}, v_{t}} p_{a}\left(u_{t} | w_{s}\right) \log p_{1}\left(v_{t} | w_{s}\right) \\ &-\sum_{w_{s} \in G_{s}} \sum_{\left(u_{t}, v_{t}\right) \in V_{t}} w_{u_{t}, v_{t}} p_{a}\left(v_{t} | w_{s}\right) \log p_{1}\left(u_{t} | w_{s}\right) \end{aligned}</script><p>最终通过最小化联合目标函数，得到嵌入的参数</p><script type="math/tex; mode=display">\mathbb{L}(\mathbf{E}) = \mathbb{L}_{1}(\mathbf{E}) + \mathbb{L}_{2}(\mathbf{E})</script></li></ol><p><strong>Mapping function</strong></p><p>IONE的映射函数是PALE的映射函数的一个特例，映射矩阵M是单位矩阵</p><blockquote><pre><code>           [https://tiantianliu2018.github.io/2019/09/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AAligning-Users-Across-Social-Networks-Using-Network-Embedding%E3%80%8B/](https://tiantianliu2018.github.io/2019/09/30/论文阅读《Aligning-Users-Across-Social-Networks-Using-Network-Embedding》/)   之前的论文阅读笔记</code></pre></blockquote></li></ul></li></ul><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p><img src="/2019/10/07/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AA-comparative-study-on-network-alignment-techniques%E3%80%8B/benchmark.png" srcset="/img/loading.gif" alt="Benchmark"></p><h3 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h3><p><strong>Real-world datasets</strong>：这些数据集的质量好像都不太高</p><ul><li>S1. Douban online vs Douban offline </li><li>S2. Flickr vs Lastfm </li><li>S3. Flickr vs MySpace</li><li>S4. Twitter vs Facebook </li><li>S5. Twitter vs Foursquare </li></ul><p><strong>Synthetic datasets</strong></p><ul><li>Partial synthetic：用真实网络生成目标网络</li><li>Full synthetic：</li></ul><hr><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><h3 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h3><p><strong>Accuracy</strong></p><script type="math/tex; mode=display">acc = \frac {\# {correctly \ \ identified \ \ node \ \ pairs}}{\# {groundtruth\ \ node\ \ pairs}}</script><p><strong>Precision@k</strong></p><script type="math/tex; mode=display">Precision@k = \frac {\# {Times \ \ that \ \ target \ \ node \ \ in \ \ top \ k \ \ similarity \ \ candiates}}{\#{groundtruth \ \  node \ \ pairs}}</script><p><strong>Mean Average Precision (MAP) </strong></p><script type="math/tex; mode=display">MAP = mean(\frac{1}{ra}) \\ra 是排序后的候选序列中匹配节点的rank</script><h3 id="Evaluation-procedure"><a href="#Evaluation-procedure" class="headerlink" title="Evaluation procedure"></a>Evaluation procedure</h3><ul><li>Structural noise level </li><li>Attribute noise level </li><li>Graph size </li><li>Graph size imbalance </li><li>Graph density </li><li>Graph connectivity </li><li>Number of connected components </li></ul><h3 id="Experimental-evaluation"><a href="#Experimental-evaluation" class="headerlink" title="Experimental evaluation"></a>Experimental evaluation</h3><p>评估以上因素对于实验的影响</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>克服真实网络中的结构和属性不稳定性是网络对齐面临的主要挑战之一</p><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2>]]></content>
    
    
    <categories>
      
      <category>科研论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Social Networks</tag>
      
      <tag>User Identity Linkage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 高级特性2</title>
    <link href="/2019/10/07/Java-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A72/"/>
    <url>/2019/10/07/Java-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A72/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-高级特性2"><a href="#Java-高级特性2" class="headerlink" title="Java 高级特性2"></a>Java 高级特性2</h1><h2 id="关键字-static"><a href="#关键字-static" class="headerlink" title="关键字 static"></a>关键字 static</h2><p>无论是否产生了对象或无论产生了多少对象，某些特定的数据在内存空间里只有一份</p><p>如果想让一个类的所有实例共享数据，应该使用<strong>类变量</strong></p><p>类变量：不用实例化，直接<code>类名.属性名</code> 就可以使用，是类的一部分，被所有这个类的实例化对象所共享，也可以叫做静态变量，用<code>static</code> 来修饰</p><p>实例变量：只有实例化后才能使用，属于实例化对象的一部分</p><a id="more"></a><p><strong>类属性、类方法的设计思想</strong></p><p>类属性作为该类各个对象之间共享的变量。在设计类时，分析哪些类属性不因对象的不同而改变，将这些属性设置为类属性。相应的方法设置为类方法。</p><p>如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用</p><p><strong>使用范围</strong></p><p>可用static修饰属性、方法、代码块、内部类</p><p><strong>被修饰后的成员具备以下特点</strong></p><p>随着类的加载而加载</p><p>优先于对象存在</p><p>修饰的成员，被所有该类的对象所共享</p><p>访问权限允许时，可不创建对象，直接被类调用</p><p><strong>类方法</strong></p><p>在static 方法内部只能访问类的<code>static</code>属性，不能访问类的非<code>static</code>属性</p><p>做工具类用最多</p><p>因为不需要实例就可以访问 <code>static</code> 方法，因此 <code>static</code>  方法内部不能有 <code>this</code> 和 <code>super</code></p><p>重载的方法需同为 <code>static</code>  或非 <code>static</code> </p><hr><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p><strong>设计模式</strong> 就是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。即在实际编程中，逐渐总结出的一些解决问题的套路。</p><p><strong>类的单例模式</strong>：采取一定的方法保证在整个软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法。</p><p>例如：实例化对象的创建要消耗大量的时间和资源。</p><p><strong>单例模式的实现方式</strong></p><ul><li><p>饿汉式</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Single</span> </span>&#123;    <span class="hljs-comment">/**     * 实现私有的构造函数，调用这个类的就不能直接用new来创建对象     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Single</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-comment">// 私有的Single类变量，只能在类内部访问</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Single single = <span class="hljs-keyword">new</span> Single();    <span class="hljs-comment">// getSingle() 为 static，不用创建对象即可访问</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Single <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> single;    &#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Single s1 = Single.getInstance();  <span class="hljs-comment">// 访问静态方法</span>Single s2 = Single.getInstance();<span class="hljs-keyword">if</span>(s1==s2)&#123;System.out.println(<span class="hljs-string">"s1 is equals to s2!"</span>);&#125;    &#125;&#125;</code></pre></li><li><p>懒汉式：最开始对象是null，直到有第一个人调用才new一个对象，之后都调用这个对象</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Single1</span> </span>&#123;<span class="hljs-comment">// 先私有化构造方法，保证在此类的外部，不能调用本类的构造器</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Single1</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-comment">// 先声明类的引用</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Single1 single = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 设置公有的方法来访问类的实例</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Single1 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// 如果类的实例未创建，先创建，再返回给调用者</span>        <span class="hljs-keyword">if</span> (single==<span class="hljs-keyword">null</span>)&#123;            single = <span class="hljs-keyword">new</span> Single1();        &#125;        <span class="hljs-comment">// 若有了实例，直接返回给调用者</span>        <span class="hljs-keyword">return</span> single;    &#125;&#125;</code></pre></li></ul><hr><h2 id="理解-main-方法的语法"><a href="#理解-main-方法的语法" class="headerlink" title="理解 main 方法的语法"></a>理解 main 方法的语法</h2><p>由于 Java 虚拟机需要调用类的 <code>main()</code> 方法，所以该方法的访问权限是 <code>public</code>，又因为 java 虚拟机在执行 <code>main()</code> 方法时不必创建对象，所以该方法是 <code>static</code> 的，该方法接收一个 String 类型的数组参数，该数组中保存执行 java 命令时传递给所运行的类的参数。</p><p>Java 运行的类名 第一个参数 第二个参数 第三个参数 … …</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;&#125;</code></pre><hr><h2 id="类的成员之四：初始化块"><a href="#类的成员之四：初始化块" class="headerlink" title="类的成员之四：初始化块"></a>类的成员之四：初始化块</h2><p>初始化块（代码块）作用：对Java对象进行初始化</p><p>程序的执行顺序：</p><p>声明成员变量默认初始化 -&gt; 显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）-&gt; 构造器再对成员进行赋值操作</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;    <span class="hljs-comment">// 非静态代码块</span>    &#123;        System.out.println(<span class="hljs-string">""</span>);    &#125;    <span class="hljs-comment">// 静态代码块，只能使用静态的成员属性和方法</span>    <span class="hljs-keyword">static</span>&#123;        System.out.println(<span class="hljs-string">""</span>);    &#125;&#125;</code></pre><p>一个类中初始化块若有修饰符，则只能被 <code>static</code> 修饰，称为静态代码块，当类被载入时，类属性的声明和静态代码块先后顺序被执行，且<strong>只能被执行一次</strong>。</p><p><code>static</code> 块通常用于初始化 static（类）属性</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> total;    <span class="hljs-keyword">static</span>&#123;        total = <span class="hljs-number">100</span>; <span class="hljs-comment">// 为 total 赋初值</span>    &#125;    ...... <span class="hljs-comment">// 其他属性或方法声明</span>&#125;</code></pre><p><strong>非静态代码块</strong>：没有 static 修饰的代码块</p><ul><li><p>可以有输出语句</p></li><li><p>可以对类的属性声明进行初始化操作</p></li><li><p>可以调用静态和非静态的变量或方法</p></li><li><p>若有多个非静态代码块，那么按照从上到下的顺序依次执行</p></li><li><p>每次创建对象的时候，都会执行一次，且先于构造器执行</p></li></ul><p><strong>静态代码块</strong>：static 修饰的代码块</p><ul><li><p>可以有输出语句</p></li><li><p>可以对类的属性声明进行初始化操作</p></li><li>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法</li><li>若有多个静态代码块，那么按照从上到下的顺序依次执行</li><li>静态代码块的执行要先于非静态代码块</li><li>静态代码块只执行一次</li></ul><p><strong>在匿名类中，用代码块代替构造方法</strong></p><hr><h2 id="关键字-final"><a href="#关键字-final" class="headerlink" title="关键字 final"></a>关键字 final</h2><p>在 Java 中声明类、属性和方法时，可以用关键字 <code>final</code> 来修饰，表示”最终“</p><p><strong><code>final</code> 标记的类不能被继承。</strong> 提高安全性，提高程序的可读性。</p><p>​    String 类、System 类、StringBuffer 类</p><p>​    <code>final</code> 修饰类</p><pre><code class="hljs Java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;&#125; <span class="hljs-comment">// 错误，final类不能被继承</span>&#125;</code></pre><p><strong><code>final</code> 标记的方法不能被子类重写</strong></p><p>​    Object 类中的 getClass()</p><p><strong><code>final</code> 标记的变量（成员变量或局部变量）即称为常量。</strong>名称大写，且只能被赋值一次。</p><p>​    final 标记的成员变量必须在声明的同时或在每个构造方法中或代码块中显式赋值，然后才能使用。</p><p>​    <code>final</code>、<code>static</code>  一起修饰变量，称为全局变量。</p><p>​    常量定义名称约定使用大写，如果由多个单词组成名称，用 <code>_</code> 连接</p><hr><h2 id="抽象类（abstract-class）"><a href="#抽象类（abstract-class）" class="headerlink" title="抽象类（abstract class）"></a>抽象类（abstract class）</h2><p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p><p>用 <code>abstract</code> 关键字来修饰一个类时，这个类叫做抽象类；</p><p>用 <code>abstract</code> 来修饰一个方法时，该方法叫做抽象方法。</p><p>​    抽象方法：只有方法的声明，没有方法的实现。以分号结束：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">abstractMethod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;</code></pre><p>含有抽象方法的类必须声明为抽象类</p><p><strong>抽象类不能被实例化。</strong>抽象类是用来作为父类被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。</p><p>不能用 <code>abstract</code> 修饰属性、私有方法、构造器、静态方法和 <code>final</code> 方法。</p><p><strong>抽象类应用</strong></p><p>抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类。</p><hr><h2 id="模板方法设计模式（TemplateMethod）"><a href="#模板方法设计模式（TemplateMethod）" class="headerlink" title="模板方法设计模式（TemplateMethod）"></a>模板方法设计模式（TemplateMethod）</h2><p>抽象类体现的就是一种模板模式的设计，<strong>抽象类作为多个子类的通用模板，</strong>子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p><blockquote><p>抽象类就像一个大纲，里面的抽象方法就是每个章节的标题。子类，去根据这些标题将每个章节细化出来。</p></blockquote><p><strong>解决的问题</strong></p><p>当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</p><p>编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类去实现，就是一种模板模式。</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Template</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTime</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">// 定义子类不能重写的方法</span>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();        code();        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();        System.out.println(<span class="hljs-string">"code() 方法执行时间是："</span>+ (end - start));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">code</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 抽象方法，由子类去实现</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubTemplate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Template</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">code</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10000</span>;i++)&#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><hr><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java 不支持多重继承。有了接口，就可以得到多重继承的效果。</p><p>接口（interface）是 <strong>抽象方法</strong> 和 <strong>常量值</strong> 的定义的集合</p><p>从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现。</p><p>实现接口类：</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InterfaceA</span></span>&#123;&#125;</code></pre><p>一个类可以实现多个接口，接口也可以继承其它接口。</p><p><strong>接口的特点</strong></p><ul><li>用 <code>interface</code> 来定义</li><li>接口中所有成员变量都 <strong>默认由 <code>public static final</code> 修饰 （全局常量）</strong></li><li>接口中所有方法都 <strong>默认是由 <code>public abstract</code> 修饰的 (抽象方法)</strong></li><li>接口没有构造器</li><li>接口采用多层继承机制</li></ul><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runner</span></span>&#123;    <span class="hljs-keyword">int</span> ID = <span class="hljs-number">1</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>实现接口的类必须实现提供接口中所有方法的具体实现内容，方可实例化，否则，仍为抽象类。</p><p><strong>接口的主要用途是被实现类实现</strong>（面向接口编程）</p><p>与继承关系类似，接口与实现类之间存在多态性。</p><p>定义 Java 类的语法格式，先写 <code>extends</code>，后写 <code>implements</code></p><pre><code class="hljs Java">&lt;modifier&gt; class &lt;name&gt; [extends &lt;superclass&gt;] [implements &lt;interfce&gt;[,&lt;interface]*]&#123;&#125;</code></pre><p>一个类可以实现多个无关的接口。</p><p>与继承关系类似，接口与实现类之间存在多态。</p><p>如果实现接口的类中没有实现接口中的全部方法，必须将此类定义为抽象类。</p><p>抽象类是对于一类事物的高度抽象，其中既有属性也有方法；接口是对方法的抽象，也就是对一系列动作的抽象。</p><hr><h2 id="工厂方法（FactoryMethod）"><a href="#工厂方法（FactoryMethod）" class="headerlink" title="工厂方法（FactoryMethod）"></a>工厂方法（FactoryMethod）</h2><p>工厂方法模式是设计模式中应用最为广泛的模式，在面向对象的编程中，对象的创建工作非常简单，对象的创建时机却很重要。FactoryMethod解决的就是这个问题，它通过面向对象的手法，将所要创建的具体对象的创建工作延迟到了子类，从而提供了一种扩展的策略，较好的解决了这种紧耦合的关系。</p><p>通过工厂把 new 对象隔离，通过产品的接口可以接收不同实际产品的实现类，实例的类名的改变不影响其他合作开发人员的编程。</p><hr><h2 id="类的成员之五：内部类"><a href="#类的成员之五：内部类" class="headerlink" title="类的成员之五：内部类"></a>类的成员之五：内部类</h2><p>在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。</p><p>Inner class 一般用于在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。</p><p>​    Inner class 的名字不能与包含它的类名相同</p><p>Inner class 可以使用外部类的私有数据，因为它是外部类的成员，同一个类的成员之间可相互访问。而外部类要访问内部类中的成员需要 <code>内部类.成员</code> 或者 <code>内部类对象.成员</code></p><p>分类：</p><ul><li>成员内部类（static 成员内部类和非static成员内部类）</li><li>局部内部类（不谈修饰符）、匿名内部类</li></ul><p><strong>内部类的特性</strong></p><ul><li><p>Inner class 作为类的成员</p><p>​    可以声明为 <code>final</code></p><p>​    和外部类不同，Inner class 可声明为 <code>private</code> 或 <code>protected</code></p><p>​    Inner class 可以声明为 <code>static</code> 的，但此时就不能再使用外部类的 <code>非static</code> 成员变量</p></li><li><p>Inner class 作为类：</p><p>​    可以声明为 <code>abstract</code> 类，因此可以被其他内部类继承</p></li></ul><p>【注意】：非 static 的内部类中的成员不能声明为 <code>static</code> 的，只有在外部类或 <code>static</code> 的内部类中才可以声明 <code>static</code> 成员</p><p><strong>作用</strong></p><p>主要解决 Java 不能<strong>多重继承</strong>的问题</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读《Mapping Users across Social Media Platforms by Integrating Text and Structure Information》</title>
    <link href="/2019/10/06/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AMapping-Users-across-Social-Media-Platforms-by-Integrating-Text-and-Structure-Information%E3%80%8B/"/>
    <url>/2019/10/06/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AMapping-Users-across-Social-Media-Platforms-by-Integrating-Text-and-Structure-Information%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Mapping-Users-across-Social-Media-Platforms-by-Integrating-Text-and-Structure-Information-2017-IEEE-ISI"><a href="#Mapping-Users-across-Social-Media-Platforms-by-Integrating-Text-and-Structure-Information-2017-IEEE-ISI" class="headerlink" title="Mapping Users across Social Media Platforms by Integrating Text and Structure Information - 2017 IEEE ISI"></a>Mapping Users across Social Media Platforms by Integrating Text and Structure Information - 2017 IEEE ISI</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>这篇文章的思路比较简单清晰：首先将不同社交网络获得的用户信息分为文本信息和网络结构信息。</p><p>文本信息又分为用户描述（word2vec embedding)、用户名（表示成单词列表）和地理位置信息（分层次划分），网络结构信息就是获得不同平台上两个用户的共同朋友，作为一个集合。对于用户描述，计算两个用户之间的余弦相似性，对于用户名和朋友关系，计算 Jaccard Index，对于地理位置，直接匹配最低层次的划分是否相同，相同则相似性为1，最后通过线性加权的方式得到整体的相似性。给整体相似性设置一个阈值，如果大于该阈值，表明这两个用户是一个人，否则，不是一个人。</p><p>这篇文章有很多可以改进的东西。</p><a id="more"></a><h2 id="Research-Objective"><a href="#Research-Objective" class="headerlink" title="Research Objective"></a>Research Objective</h2><p>提出一种 mapping method 能够整个 <strong>文本</strong> 和 <strong>结构</strong> 的信息</p><p>模型首先基于word2vec或字符串匹配来表示用户名、描述、位置信息，以关系网络表示的朋友关系信息作为结构信息。然后利用这些信息，利用 Jaccard index 或余弦相似度进行相似度计算。采用线性模型获取用户对的整体相似度，进行用户映射。</p><h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><p>文本信息和社交网络特征的融合应用。</p><p>关键是文本和结构信息的有效表示和相似性的计算。</p><p>文本信息和社交网络结构信息反映了用户的行为模式。但目前存在的方法都是基于单一信息的user mapping。</p><h3 id="Text-information-based-mapping-method"><a href="#Text-information-based-mapping-method" class="headerlink" title="Text information based mapping method"></a>Text information based mapping method</h3><p>利用用户的文本信息：用户名、位置、年龄、标签以及用户在社交网络中产生的content等</p><h3 id="Structure-information-based-mapping-method"><a href="#Structure-information-based-mapping-method" class="headerlink" title="Structure information based mapping method"></a>Structure information based mapping method</h3><p>anchor link prediction </p><ul><li>监督方法：需要知道一部分已经存在的 anchor links 作为训练集来训练模型。<ul><li>一些方法直接使用人工提取的特征，如度、聚类系数、三角形数和共同邻居等，这些方法没有利用网络的内部结构规律。</li><li>表示学习的方法</li><li>probability network</li></ul></li><li>无监督的方法：NP-hard 组合优化问题</li></ul><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p><img src="/2019/10/06/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AMapping-Users-across-Social-Media-Platforms-by-Integrating-Text-and-Structure-Information%E3%80%8B/overview.png" srcset="/img/loading.gif" alt="An overview of the research framework "></p><h3 id="Theoretical-Background"><a href="#Theoretical-Background" class="headerlink" title="Theoretical Background"></a>Theoretical Background</h3><ul><li>Subjective description：主要是用户的职业、兴趣等</li><li>Objective Information：真实姓名、地理位置信息等真实的信息</li><li>Social Relationship：通过模型的构建，将用户的社会关系和角色特征转化为结构特征。Graph algorithms 可以应用</li></ul><h3 id="Information-representation"><a href="#Information-representation" class="headerlink" title="Information representation"></a>Information representation</h3><ol><li><p>User description：用户描述是一小段对自己的描述，其中包括用户的爱好、职业等信息</p><p>应用 word2vec 模型将描述文本转为向量表示</p><p>通过去除stopwords和一些其他的自然语言预处理操作，获得一系列单词$(word<em>{1}, word</em>{2}, …, word<em>{k})$ 通过预训练的 n-dimension word2vec模型，可以得到每个单词的向量表示 $(wordvector</em>{1}, wordvector<em>{2}, …, wordvector</em>{k})$</p><p>因此在社交平台A上的用户N可以描述为：</p><script type="math/tex; mode=display">D_{N}^{A}=\left\{w_{1}, w_{2}, \ldots, w_{n}\right\}=\sum_{i=1}^{k} \frac{\text {wordvector}_{i}}{k}</script></li><li><p>Username：将用户名转换为 word list</p><p>社交平台A上用户N的用户名可以表示为 </p><script type="math/tex; mode=display">D_{N}^{A} = \left(word_{1}, word_{2},..., word_{j}\right)</script></li><li><p>Friend information</p><p>假定平台 A 上的用户 N 有 n 个朋友 $F^{A} = \left[f<em>{1}^{A}, f</em>{2}^{A}, \ldots, f<em>{n}^{A}\right]$, 平台B上用户 M 有 m 个朋友 $F^{B}=\left[f</em>{1}^{B}, f<em>{2}^{B}, \ldots, f</em>{m}^{B}\right]$ ，那么他们有 k 个重叠的朋友的话，表示为 $F^{o}=\left[f<em>{1}, f</em>{2}, \ldots, f_{k}\right]$</p></li><li><p>Location</p><p>将地理位置信息划分为不同的层次：$L<em>{N}^{A}=\left[C i t y</em>{N}, \text { State}<em>{N}, Nation</em>{N}\right]$</p></li></ol><h3 id="Similarity-Computation"><a href="#Similarity-Computation" class="headerlink" title="Similarity Computation"></a>Similarity Computation</h3><ol><li><p>User description - Cosine similarity</p><script type="math/tex; mode=display">\begin{aligned} \operatorname{sim}\left(D_{N}^{A}, D_{M}^{B}\right) &=\frac{D_{N}^{A} \cdot D_{M}^{B}}{\left\|D_{N}^{A}\right\| \| D_{M}^{B}} \\ &=\frac{\sum_{i=1}^{n} D_{N i}^{A} D_{M i}^{B}}{\sqrt{\sum_{i=1}^{n} D_{N i}^{A}} \sqrt{\sum_{i=1}^{n} D_{M i}^{B_{2}^{2}}}} \end{aligned}</script></li><li><p>Username and Friend - Jaccard index</p><p>用户名：</p><script type="math/tex; mode=display">J\left(U_{N}^{A}, U_{M}^{B}\right)=\frac{\left|U_{N}^{A} \cap U_{M}^{B}\right|}{\left|U_{N}^{A} \cup U_{M}^{B}\right|}</script><p>Friend：</p><script type="math/tex; mode=display">J\left(F^{A}, F^{B}\right)=\frac{\left|F^{A} \cap F^{B}\right|}{\left|F^{A} \cup F^{B}\right|}=\frac{\left|F^{O}\right|}{\left|F^{A}\right|+\left|F^{B}\right|-\left|F^{O}\right|}</script></li><li><p>Location - Matching</p><p>如果最低的非空区域划分等级中是一致的，则 $Sim(L<em>{N}^{A}, L</em>{M}^{B}) = 1$, 若不匹配，则 $Sim(L<em>{N}^{A}, L</em>{M}^{B}) = 0$</p></li></ol><h3 id="Information-Integration"><a href="#Information-Integration" class="headerlink" title="Information Integration"></a>Information Integration</h3><script type="math/tex; mode=display">S=\eta_{d} S_{d}+\eta_{u} S_{u}+\eta_{l} S_{l}+\eta_{f} S_{f}</script><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><blockquote><p>Sun S , Li Q , Yan P , et al. Mapping users across social media platforms by integrating text and structure information[C]// 2017 IEEE International Conference on Intelligence and Security Informatics (ISI). IEEE, 2017.</p></blockquote><p>数据集来自于文章《<a href="http://dx.doi.org/10.1109%2FICME.2013.6607510" target="_blank" rel="noopener">Friend transfer: Cold-start friend recommendation with cross-platform transfer learning of social knowledge</a>》目前还没找到数据。</p>]]></content>
    
    
    <categories>
      
      <category>科研论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Social Networks</tag>
      
      <tag>User Identity Linkage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 高级类特性</title>
    <link href="/2019/10/03/Java-%E9%AB%98%E7%BA%A7%E7%B1%BB%E7%89%B9%E6%80%A7/"/>
    <url>/2019/10/03/Java-%E9%AB%98%E7%BA%A7%E7%B1%BB%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-高级类特性"><a href="#Java-高级类特性" class="headerlink" title="Java 高级类特性"></a>Java 高级类特性</h2><h2 id="面向对象特征之二：继承"><a href="#面向对象特征之二：继承" class="headerlink" title="面向对象特征之二：继承"></a>面向对象特征之二：继承</h2><p><strong>为什么要有继承？</strong></p><p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。</p><p>此处的多个类称为子类，单独的这个类称为父类（基类或超类）</p><a id="more"></a><p><strong>继承的语法规则</strong></p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Subclass extends Superclass&#123;&#125;</code></pre><p><strong>作用</strong></p><p>继承的出现提高了代码的复用性</p><p>继承的出现让类与类之间产生了关系，提供了多态的前提</p><p>不要仅为了获取其他类中某个功能而去继承</p><p><strong>说明</strong></p><p>子类继承了父类，就继承了父类的方法和属性。</p><p>在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。</p><p>在 Java 中，继承的关键字用的是 <code>extends</code>, 即子类不是父类的子集，而是对父类的扩展</p><p>关于继承的规则：</p><ul><li>子类不能直接访问父类中私有的（private）成员变量和方法</li><li>Java 只支持单继承，不允许多重继承<ul><li>一个子类只能有一个父类</li><li>一个父类可以派生出多个子类</li></ul></li></ul><hr><h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p>在子类中可以根据需要对从父类中继承来的方法进行改造，也称方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。子类重写父类的方法，只是重新编写方法体的代码。</p><p>要求：</p><ul><li><p>重写方法必须和被重写方法具有相同的方法名称、参数列表和返回值类型</p></li><li><p>重写方法不能使用比被重写方法更严格的访问权限</p></li><li><p>重写方法和被重写的方法必须同时为 <code>static</code> 的，或者同时为 <code>非static</code> 的</p></li><li><p>子类方法抛出的异常不能大于父类被重写方法的异常</p></li></ul><hr><h2 id="四种访问权限修饰符"><a href="#四种访问权限修饰符" class="headerlink" title="四种访问权限修饰符"></a>四种访问权限修饰符</h2><p>如果子类和父类在<strong>同一个包</strong>下，那么对于父类的成员修饰符只要不是私有的 <code>private</code>，子类那就可以使用</p><p>如果子类和父类<strong>不在同一个包</strong>中，那么子类只能使用父类中 <code>protected</code> 和 <code>public</code> 的成员变量</p><hr><h2 id="关键字-super"><a href="#关键字-super" class="headerlink" title="关键字 super"></a>关键字 super</h2><p>在 Java 类中使用 <code>super</code> 来调用父类中指定的操作：</p><ul><li><p><code>super</code> 可用于访问父类中定义的属性</p></li><li><p><code>super</code> 可用于调用父类中定义的成员方法</p></li><li><p><code>super</code> 可用于在子类构造方法中调用父类的构造器</p></li></ul><p><strong>注意</strong></p><p>尤其是当子父类出现同名成员时，可以用 <code>super</code> 进行区分</p><p><code>super</code> 的追溯不仅限于直接父类，使用 <code>super</code>，子类可以调用子类之上的所有父类层级</p><p><code>super</code> 和 <code>this</code> 的用法相像，<code>this</code> 代表本类对象的引用， <code>super</code> 代表父类的内存空间的标识</p><p><strong>调用父类的构造器</strong></p><p>子类中所有的构造器<strong>默认</strong>都会访问父类中<strong>空参数</strong>的构造器</p><p>当父类中没有空参数的构造器时，子类的构造器必须通过 <code>this（参数列表）</code>或者 <code>super（参数列表）</code>语句指定调用本类或者父类中相应的构造器，且必须放在构造器的第一行</p><p>如果子类构造器中既有显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错</p><p><strong>this 和 super 的区别</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">区别点</th><th>this</th><th>super</th></tr></thead><tbody><tr><td style="text-align:center">访问属性</td><td>访问本类中的属性，如果本类没有此属性则从父类中继续查找</td><td>访问父类中的属性</td></tr><tr><td style="text-align:center">调用方法</td><td>访问本类中的方法</td><td>直接访问父类中的方法</td></tr><tr><td style="text-align:center">调用构造器</td><td>调用本类构造器，必须放在构造器的首行</td><td>调用父类构造器，必须放在子类构造器的首行</td></tr><tr><td style="text-align:center">特殊</td><td>表示当前对象</td><td>无此概念</td></tr></tbody></table></div><hr><h2 id="子类对象实例化过程"><a href="#子类对象实例化过程" class="headerlink" title="子类对象实例化过程"></a>子类对象实例化过程</h2><p><strong>简单类对象的实例化过程</strong></p><ol><li>在方法区加载 <code>Person.class</code></li><li>在栈中申请空间，声明变量 <code>p</code></li><li>在堆内存中开辟空间，分配地址，假设地址是 <code>BE2500</code></li><li>在对象空间中（堆内存），对对象中的属性进行默认初始化，若对成员变量有赋值，则对成员变量显式初始化</li><li>构造函数方法进栈，进行初始化（栈内存）</li><li>初始化完毕后，将堆内存中的地址值赋给引用变量 <code>p = BE2500</code>，构造方法出栈</li></ol><p><strong>子类对象的实例化过程</strong></p><ol><li>在方法区先加载 <code>Person.class</code>, 再加载 <code>Student.class</code></li><li>在栈中申请空间，声明变量 <code>stu</code></li><li>在堆内存中开辟空间，分配地址</li><li>并在对象空间中，对对象中的属性（包括父类的属性）进行默认初始化</li><li>子类构造方法进栈</li><li>显式初始化父类的属性（堆内存）</li><li>父类构造方法进栈，执行完毕出栈</li><li>显式初始化子类的属性（堆内存）</li><li>初始化完毕后，将堆内存中的地址值赋给引用变量 <code>stu</code>. 子类构造方法出栈</li></ol><hr><h2 id="面向对象特征之三：多态"><a href="#面向对象特征之三：多态" class="headerlink" title="面向对象特征之三：多态"></a>面向对象特征之三：多态</h2><p>多态性，是面向对象最重要的概念，在Java中有两种体现：</p><ol><li>方法的重载（overload）和重写（overwrite）</li><li><strong>对象的多态性</strong>——可以直接应用在抽象类和接口上</li></ol><p>Java 引用变量有两个类型：<strong>编译时类型</strong>和<strong>运行时类型</strong>。</p><p>编译时类型由声明该变量时使用的类型决定，</p><p>运行时类型由实际赋给该变量的对象决定。</p><p>若编译时类型和运行时类型不一致，就出现多态（Polymorphism）——对象的多态</p><p><strong>对象的多态</strong> —— 在Java中，子类的对象可以代替父类的对象使用</p><ul><li>一个变量只能有一种确定的数据类型</li><li>一个引用类型变量可能指向（引用）多种不同类型的对象</li></ul><p>子类可以看做是特殊的父类，所以父类类型的引用可以指向子类的对象：<strong>向上转型</strong></p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;&#125;Person p = <span class="hljs-keyword">new</span> Person();Person e = <span class="hljs-keyword">new</span> Student();  <span class="hljs-comment">// 子类的对象可以赋值给父类类型的变量引用</span></code></pre><p>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法。</p><pre><code class="hljs Java">Student m = <span class="hljs-keyword">new</span> Student();m.school = <span class="hljs-string">"pku"</span>; <span class="hljs-comment">// 合法， Student类中有school成员变量</span>Person e = <span class="hljs-keyword">new</span> Student();e.school = <span class="hljs-string">"pku"</span>; <span class="hljs-comment">// 非法，Person类没有school成员变量</span></code></pre><p>属性是在编译时确定的，编译时 <code>e</code> 为 <code>Person</code> 类型，没有 <code>school</code> 成员变量，因而编译出错。</p><p><strong>虚拟方法调用</strong></p><p>正常的方法调用：</p><pre><code class="hljs Java">Person p = <span class="hljs-keyword">new</span> Person();p.getInfo();Student s = <span class="hljs-keyword">new</span> Student();s.getInfo();</code></pre><p>虚拟方法调用（多态情况下）</p><pre><code class="hljs reasonml">Person e = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Student()</span>;e.get<span class="hljs-constructor">Info()</span>;  <span class="hljs-comment">// 调用 Student 类的 getInfo() 方法</span></code></pre><p>编译时类型和运行时类型：</p><p>编译时 <code>e</code>为 <code>Person</code> 类，而方法的调用是在运行时确定的，所以调用的是 <code>Student</code>类的 <code>getInfo()</code> 方法 —— 动态绑定</p><p><strong>多态小结：</strong></p><ul><li><p>前提</p><p>需要存在继承或者实现关系</p><p>要有覆盖操作</p></li><li><p>成员方法：</p><ul><li>编译时，要查看引用变量所属的类中是否有所调用的方法</li><li>运行时，要调用实际对象所属类中的重写方法</li></ul></li><li><p>成员变量</p><p>不具备多态性，只看引用变量所属的类</p></li></ul><h4 id="instance-of-操作符"><a href="#instance-of-操作符" class="headerlink" title="instance of 操作符"></a>instance of 操作符</h4><p><code>x instance of A</code>: 检验 <code>x</code> 是否是类 A 的对象，返回值为 <code>boolean</code> 型</p><p>要求 x 所属的类与类 A 必须是子类和父类的关系，否则编译出错</p><p>如果 x 属于类 A 的子类 B ，<code>x instance of A</code> 值也为 <code>true</code></p><hr><h2 id="Object类，包装类"><a href="#Object类，包装类" class="headerlink" title="Object类，包装类"></a>Object类，包装类</h2><h4 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h4><p>Object 类是所有Java类的根父类 —— 基类</p><p>object类中的主要方法：</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Object</span><span class="hljs-params">()</span>   <span class="hljs-comment">//构造方法</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span><span class="hljs-comment">//普通方法，对象比较(引用对象)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span><span class="hljs-comment">// 获取Hash码</span><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span>    <span class="hljs-comment">// 对象打印时调用</span></span></code></pre><h4 id="对象类型转换"><a href="#对象类型转换" class="headerlink" title="对象类型转换"></a>对象类型转换</h4><p>基本数据类型转换的 Casting</p><ul><li><p>自动类型转换：小的数据类型可以自动转换成大的数据类型</p><p><code>long g = 20;</code>       <code>double d = 12.0f</code></p></li><li><p>强制类型转换：可以把大的数据类型转换成小的数据类型</p><p><code>float f = (float)12.0;</code>       <code>int a = (int) 1200L</code></p></li></ul><p>对Java对象的强制类型转换称为<strong>造型</strong></p><ul><li>从子类到父类的类型转换可以自动进行</li><li>从父类到子类的类型转换必须通过造型（强制类型转换）实现</li><li>无继承关系的引用类型间的转换是非法的</li></ul><h4 id="操作符与-equals-方法"><a href="#操作符与-equals-方法" class="headerlink" title="== 操作符与 equals 方法"></a><code>==</code> 操作符与 <code>equals</code> 方法</h4><ul><li><p><code>==</code></p><ul><li><p>基本类型比较值：只要两个变量的值相等，即为 true</p><p><code>int a = 5;</code>  <code>if(a==6){...};</code></p></li><li><p>引用类型比较引用（是否指向同一个对象）：只有指向同一个对象时，<code>==</code> 才返回true</p><pre><code class="hljs Java">Person p1 = <span class="hljs-keyword">new</span> Person();Person p2 = <span class="hljs-keyword">new</span> Person();<span class="hljs-keyword">if</span>(p1 == p2)&#123;...&#125;</code></pre><p>用 <code>==</code> 进行比较时，符号两边的数据类型必须兼容（可自动转换的基本数据类型除外），否则编译出错</p></li></ul></li><li><p><code>equals</code> 所有类都继承了 Object，也就获得了 <code>equals()</code> 方法。还可以重写。</p><ul><li>只能比较引用类型，其作用与 <code>==</code> 相同，比较是否指向同一个对象。<ul><li>格式：<code>obj1.equals(obj2)</code></li></ul></li><li>特例：当用 <code>equals()</code> 方法进行比较时，对类 File、String、Date 及包装类（Wrapper）来说，是比较类型及内容而不考虑引用的是否是同一个对象<ul><li>原因：在职这些类中重写了 Object 类的  <code>equals()</code>  方法</li></ul></li></ul><p><strong>总结</strong></p><p>对于对象来说，特殊的类，如 String、File、Date使用 <code>==</code> 比较的是对象（对象的地址）， <code>equals</code> 比较的是内容</p><p>除了特殊类之外的其他其他普通对象， <code>==</code> 和 <code>equals</code> 比较的都是对象（对象的内存地址）</p></li></ul><h4 id="String-对象的创建"><a href="#String-对象的创建" class="headerlink" title="String 对象的创建"></a>String 对象的创建</h4><ul><li><p>字面量创建 String 对象</p><pre><code class="hljs Java">String s1 = <span class="hljs-string">"abc"</span>;<span class="hljs-comment">// 堆内存的常量池中添加“abc”对象，返回引用地址给s1对象</span>String s2 = <span class="hljs-string">"abc"</span>;<span class="hljs-comment">// 通过 equals() 方法判断常量池中是否存在值为“abc”的对象，返回相同的引用</span>System.out.println(s1==s2); <span class="hljs-comment">// true, s1==s2</span></code></pre></li><li><p>new 创建 String 对象</p><pre><code class="hljs Java">String s3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"def"</span>);  <span class="hljs-comment">// 在常量池中添加“def”对象，在堆中创建值为“def"的对象s3,返回指向堆中s3的引用</span>String s4 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"def"</span>);  <span class="hljs-comment">// 常量池中已有“def”对象，不做处理，在堆中创建值为“def”的对象s4，返回指向堆中s4的引用</span><span class="hljs-comment">// 因此 s3 和 s4 指向的不是一个对象</span></code></pre><p>字面量创建对象的时候，只在常量池创建一个对象。</p><p>使用 <code>new</code> 创建对象，常量池有对象，堆中也要有对象，字面量方法要比<code>new</code>方法省内存</p></li><li><p>字面量相加</p><pre><code class="hljs Java">String s5 = <span class="hljs-string">"x"</span>+<span class="hljs-string">"y"</span>;  <span class="hljs-comment">// 经过JVM的优化，直接在常量池中添加“xy”对象</span></code></pre></li><li><p>通过<code>new</code>的方式字符串叠加</p><pre><code class="hljs Java">String s6 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"1"</span>)+<span class="hljs-keyword">new</span> String(<span class="hljs-string">"1"</span>)+<span class="hljs-keyword">new</span> String(<span class="hljs-string">"2"</span>);  <span class="hljs-comment">// 通过StringBuilder实现，在常量池中添加“1”和“2”两个对象，在堆中创建值为“112”的对象，把引用地址给s6</span></code></pre></li></ul><h4 id="包装类（Wrapper）"><a href="#包装类（Wrapper）" class="headerlink" title="包装类（Wrapper）"></a>包装类（Wrapper）</h4><p>针对八种基本类型定义相应的引用类型——包装类（封装类）</p><div class="table-container"><table><thead><tr><th style="text-align:center">基本数据类型</th><th style="text-align:center">包装类</th></tr></thead><tbody><tr><td style="text-align:center">boolean</td><td style="text-align:center">Boolean</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">Byte</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">Short</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">Integer</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">Long</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">Character</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">Float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">Double</td></tr></tbody></table></div><ul><li><p>基本数据类型包装成包装类的实例——装箱</p><p>通过包装类的构造器实现：</p><pre><code class="hljs Java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">500</span>;Interger t = <span class="hljs-keyword">new</span> Integer(i);</code></pre><p>还可以通过字符串参数构造包装类对象：</p><pre><code class="hljs Java">Float f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>(<span class="hljs-string">"4.56"</span>);Long l = <span class="hljs-keyword">new</span> Long(<span class="hljs-string">"asdf"</span>);  <span class="hljs-comment">// NumberFormatException</span></code></pre></li><li><p>获得包装类对象中包装的基本数据类型变量——拆箱</p><p>调用包装类的<code>.xxxValue()</code> 方法：</p><p><code>boolean b = bObj.booleanValue();</code></p></li></ul><p>JDK1.5后支持自动装箱和拆箱：</p><pre><code class="hljs Java">Integer l1 = <span class="hljs-number">112</span>;  <span class="hljs-comment">// 自动装箱</span><span class="hljs-keyword">int</span> l2 = l1; <span class="hljs-comment">// 自动拆箱</span></code></pre><ul><li><p>字符串转换成基本数据类型</p><ul><li><p>通过包装类的构造器实现：</p><p><code>int i = new Integer(&quot;12&quot;);</code></p></li><li><p>通过包装类的<code>parseXxx(String s)</code> 静态方法：</p><p><code>Float f = Float.parseFloat(&quot;12.1&quot;);</code></p></li></ul></li><li><p>基本数据类型转换成字符串</p><ul><li><p>调用字符串重载的<code>valueOf()</code> 方法</p><p><code>String fstr = String.valueOf(2.34f);</code></p></li><li><p>更直接的方式</p><p><code>String intStr = 5 + &quot;&quot;</code></p></li></ul></li></ul><p><strong>包装类的作用</strong></p><p>基本数据类型的包装类实现了基本数据类型与字符串直接转化</p><p>包装类使得一个基本数据类型的数据变成了类。有了类的特点，可以调用类中的方法。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaBean</title>
    <link href="/2019/10/03/JavaBean/"/>
    <url>/2019/10/03/JavaBean/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h1><p>JavaBean 是一种 Java 语言写成的可重用组件。</p><p>所谓JavaBean，是指符合如下标准的Java类：</p><ul><li><p>类是公共的</p></li><li><p>有一个无参的公共构造器</p></li><li><p>有属性，属性一般是私有的，且有对应的get、set方法</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java this关键字</title>
    <link href="/2019/10/02/Java-this%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2019/10/02/Java-this%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-关键字——this"><a href="#Java-关键字——this" class="headerlink" title="Java 关键字——this"></a>Java 关键字——this</h1><p>this 在方法内部使用，即这个方法所属对象的引用</p><p>它在构造器内部使用，表示该构造器正在初始化的对象</p><p>this 表示当前对象，可以调用类的属性、方法和构造器</p><a id="more"></a><p><strong>什么时候使用？</strong></p><p>当在方法内先需要用到调用该方法的对象时，就用 this</p><p>使用this，调用属性、方法</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;  <span class="hljs-comment">// 创建Person类</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span></span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getInfo</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"姓名："</span> + <span class="hljs-keyword">this</span>.name);        <span class="hljs-keyword">this</span>.speak();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"年龄："</span> + <span class="hljs-keyword">this</span>.age);    &#125;&#125;</code></pre><p>使用this调用本类的构造器</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;  <span class="hljs-comment">// 创建Person类</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">// 无参构造方法</span>        System.out.println(<span class="hljs-string">"新对象实例化"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span></span>&#123;         <span class="hljs-keyword">this</span>();<span class="hljs-comment">// 调用本类中的无参构造方法</span>        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span></span>&#123;         <span class="hljs-keyword">this</span>(name);<span class="hljs-comment">// 调用本类只有一个参数的构造方法</span>        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"姓名："</span> + name + <span class="hljs-string">"年龄："</span> + age;     &#125;&#125;</code></pre><p><strong>注意：</strong></p><p>使用 this 必须放在构造器的首行</p><p>使用 this 调用本类中其他的构造器，保证至少有一个构造器是不用this的。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 构造器</title>
    <link href="/2019/10/02/Java-%E6%9E%84%E9%80%A0%E5%99%A8/"/>
    <url>/2019/10/02/Java-%E6%9E%84%E9%80%A0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-类的成员之三：构造器（构造方法）"><a href="#Java-类的成员之三：构造器（构造方法）" class="headerlink" title="Java 类的成员之三：构造器（构造方法）"></a>Java 类的成员之三：构造器（构造方法）</h1><h3 id="构造器的特征"><a href="#构造器的特征" class="headerlink" title="构造器的特征"></a>构造器的特征</h3><p>它具有与类相同的名称</p><p>它不声明返回值类型（与声明为void不同）</p><p>不能被 static、final、synchronized、abstract、native 修饰，不能 return 语句返回</p><a id="more"></a><p><strong>构造器的作用：创建对象；给对象进行初始化</strong></p><p><strong>语法格式</strong></p><pre><code class="hljs java">修饰符 类名(参数列表)&#123;初始化语句;&#125;举例：<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> legs;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span><span class="hljs-params">()</span></span>&#123;legs = <span class="hljs-number">4</span>;&#125;  <span class="hljs-comment">// 构造器</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLegs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;legs = i;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLegs</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> legs;&#125;&#125;</code></pre><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>根据参数不同，构造器可以分为如下两类：</p><ul><li>隐式无参构造器（系统默认提供）</li><li>显式定义一个或多个构造器（无参、有参）</li></ul><p><strong>注意：</strong></p><p>Java语言中，每个类都至少有一个构造器</p><p>默认构造器的修饰符与所属类的修饰符一致</p><p>一旦显式定义了构造器，则系统不再提供默认构造器</p><p>一个类可以创建多个重载的构造器</p><p>父类的构造器不可被子类继承</p><p><strong>new 对象，实际上就是调用类的构造方法</strong></p><h3 id="构造器重载"><a href="#构造器重载" class="headerlink" title="构造器重载"></a>构造器重载</h3><p>构造器一般用来在创建对象的同时初始化对象，如：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;String name;<span class="hljs-keyword">int</span> age;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String n, <span class="hljs-keyword">int</span> a)</span></span>&#123;name = n;age = a;&#125;&#125;</code></pre><p>构造器重载使得对象的创建更加灵活，方便创建各种不同的对象。</p><pre><code class="hljs java">构造器重载举例：<span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> age, Date d)</span></span>&#123;<span class="hljs-keyword">this</span>(name, age);...&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> age)</span></span>&#123;...&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name,Date d)</span></span>&#123;...&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;...&#125;&#125;</code></pre><p>构造器重载，参数列表必须不同</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 面向对象特征之一：封装和隐藏</title>
    <link href="/2019/10/01/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%B0%81%E8%A3%85%E5%92%8C%E9%9A%90%E8%97%8F/"/>
    <url>/2019/10/01/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%B0%81%E8%A3%85%E5%92%8C%E9%9A%90%E8%97%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-面向对象特征之一：封装和隐藏"><a href="#Java-面向对象特征之一：封装和隐藏" class="headerlink" title="Java 面向对象特征之一：封装和隐藏"></a>Java 面向对象特征之一：封装和隐藏</h1><h2 id="信息的封装和隐藏"><a href="#信息的封装和隐藏" class="headerlink" title="信息的封装和隐藏"></a>信息的封装和隐藏</h2><p>Java 中通过将数据声明为私有的（private），再提供公共的（public）方法：<code>getXxx()</code>和 <code>setXxx()</code> 实现对该属性的操作，以实现下述目的：</p><p>隐藏一个类中不需要对外提供的实现细节；</p><p>使用者只能通过事先定值好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；</p><p>便于修改，增强代码的可维护性。</p><a id="more"></a><hr><h2 id="四种访问权限修饰符"><a href="#四种访问权限修饰符" class="headerlink" title="四种访问权限修饰符"></a>四种访问权限修饰符</h2><p>Java 权限修饰符 public、protected、private 置于<strong>类的成员</strong>定义前，用来限定对象对该类成员的访问权限。</p><div class="table-container"><table><thead><tr><th>修饰符</th><th>类内部</th><th>同一个包</th><th>子类</th><th>任何地方</th></tr></thead><tbody><tr><td>private</td><td>Yes</td><td></td><td></td><td></td></tr><tr><td>（缺省）</td><td>Yes</td><td>Yes</td><td></td><td></td></tr><tr><td>protected</td><td>Yes</td><td>Yes</td><td>Yes</td><td></td></tr><tr><td>public</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr></tbody></table></div><p>对于 <code>class</code> 的权限修饰符只可以用 <code>public</code> 和 <code>default（缺省）</code>：</p><p>public 类可以在任意地方被访问。</p><p>default 类只可以被同一个包内部的内访问。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 包和引用</title>
    <link href="/2019/10/01/Java-%E5%8C%85%E5%92%8C%E5%BC%95%E7%94%A8/"/>
    <url>/2019/10/01/Java-%E5%8C%85%E5%92%8C%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-包-package-和引用-import"><a href="#Java-包-package-和引用-import" class="headerlink" title="Java 包 package 和引用 import"></a>Java 包 package 和引用 import</h1><h2 id="关键字——package"><a href="#关键字——package" class="headerlink" title="关键字——package"></a>关键字——package</h2><p>package 语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。</p><a id="more"></a><p>格式：</p><pre><code class="hljs Java"><span class="hljs-keyword">package</span> 顶层包名.子包名;举例：pack\Test.java<span class="hljs-keyword">package</span> p1; <span class="hljs-comment">// 指定类 Test 属于包 p1</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"in method display()"</span>);&#125;&#125;</code></pre><p>包对应于文件系统的目录，package语句中，用”.”来指明包（目录）的层次；</p><p>包通常用小写单词，类名首字母通常大写</p><h2 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h2><p>若引入的包为：<code>java.lang</code>，则编译器默认获取此包下的类，不需要再显示声明。</p><p><code>import</code> 语句出现在 <code>package</code> 语句之后、类定义之前</p><p>一个源文件中可包含多个<code>import</code>语句</p><p>可以使用 <code>import lee.*;</code>语句，表明导入<code>lee</code>包下的所有类。而<code>lee</code>包下<code>sub</code>子包内的类则不会被导入。<code>import lee.sub.*;</code></p><p><code>import</code> 语句不是必须的，可以坚持在类中使用类的全名。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读《Aligning Users Across Social Networks Using Network Embedding》</title>
    <link href="/2019/09/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AAligning-Users-Across-Social-Networks-Using-Network-Embedding%E3%80%8B/"/>
    <url>/2019/09/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AAligning-Users-Across-Social-Networks-Using-Network-Embedding%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Aligning-Users-Across-Social-Networks-Using-Network-Embedding"><a href="#Aligning-Users-Across-Social-Networks-Using-Network-Embedding" class="headerlink" title="Aligning Users Across Social Networks Using Network Embedding"></a>Aligning Users Across Social Networks Using Network Embedding</h1><blockquote><p>Liu L, Cheung W K, Li X, et al. Aligning users across social networks using network embedding[C]. international joint conference on artificial intelligence, 2016: 1774-1780</p></blockquote><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>这篇文章非常数学，嵌入方式应该是通过三个向量表示一个节点，然后通过各自的目标函数联合优化作为整体的目标函数。证明推理部分没有看，感觉很难。</p><p>太难了，我太难了。。。我就是不想看数学推导和数学证明，直接上代码啊~~</p><a id="more"></a><hr><h2 id="Research-Objective"><a href="#Research-Objective" class="headerlink" title="Research Objective"></a>Research Objective</h2><p>提出应用网络表示学习的方法来对齐社交网络。</p><p>Input-Output Network Embedding (IONE) </p><p>将多个社交网络映射到一个共同的嵌入空间中，提出的 IONE 方法使得更多的社交结构属性用于网络表征学习，最终目标是实现更准确的社交网络对齐。</p><hr><h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><p>结构对齐方法：</p><ul><li><p>监督的</p><p>通过分类的方法，预测 anchor links </p></li><li><p>无监督的</p><p>假定 anchor links 不存在，把该问题看做一般的 graph alignment 问题</p></li></ul><hr><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h3 id="1-Input-Output-Network-Embedding"><a href="#1-Input-Output-Network-Embedding" class="headerlink" title="1. Input-Output Network Embedding"></a>1. Input-Output Network Embedding</h3><p>将节点的父节点作为其输入上下文，同时将节点的子节点作为其输出上下文。</p><p>每一个节点 $v<em>{i}$ 有三个向量表示，节点向量 $\overrightarrow{u</em>{i}} \in \Re^{d}$ , 输入上下文向量  $\vec{u}<em>{i}^{\prime} \in \Re^{d}$ ，输出上下文向量 $\overrightarrow{u</em>{i}}^{\prime \prime} \in \Re^{d}$</p><p><img src="/2019/09/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AAligning-Users-Across-Social-Networks-Using-Network-Embedding%E3%80%8B/IONE.png" srcset="/img/loading.gif" alt="IONE"></p><p>定义节点$v<em>{i}$ 作为 $v</em>{j}$ 的输入上下文对其贡献概率</p><script type="math/tex; mode=display">p_{1}\left(v_{j} | v_{i}\right)=\frac{\exp \left(\overrightarrow{u_{j}}^{\prime T} \cdot \overrightarrow{u_{i}}\right)}{\sum_{k=1}^{|V|} \exp \left(\overrightarrow{u_{k}}^{\prime T} \cdot \overrightarrow{u_{i}}\right)}</script><p>其中 $|V|$ 是网络中用户数，同样可以定义节点 j 作为对节点 i 输出上下文向量的贡献概率</p><script type="math/tex; mode=display">p_{2}\left(v_{i} | v_{j}\right)=\frac{\exp \left(\overrightarrow{u_{i}}^{\prime \prime T} \cdot \overrightarrow{u_{j}}\right)}{\sum_{k=1}^{|V|} \exp (\overrightarrow{u_{k}^{\prime \prime}} \cdot \overrightarrow{u_{j}})}</script><script type="math/tex; mode=display">\widehat{p}_{1}(i, j)=w_{i j} / d_{i}^{out} ，  d_{i}^{out}=\sum_{k \in N_{\text {out}}\left(v_{i}\right)} w_{i k} , 节点 i 出度和\\\widehat{p}_{2}(i, j)=w_{i j} / d_{j}^{in}， d_{j}^{in}=\sum_{k \in N_{\text {in}}\left(v_{j}\right)} w_{kj} , 节点 j 入度和</script><h3 id="2-Aligning-Network-Embedding-of-Multiple-Networks"><a href="#2-Aligning-Network-Embedding-of-Multiple-Networks" class="headerlink" title="2. Aligning Network Embedding of Multiple Networks"></a>2. Aligning Network Embedding of Multiple Networks</h3><p>两个独立网络中节点的结构邻近性尽可能保留在其对应的嵌入中，并且锚节点的表示在嵌入式空间中重合，在嵌入空间中较近的锚节点可以看做 ‘用户对齐’ 较好的候选对象。</p><p>最小化 $p<em>{1}$ 和 $p</em>{2}$ 的 KL 散度</p><p>目标函数：</p><script type="math/tex; mode=display">\begin{aligned} O_{1}=&-\sum_{k \in\{X, Y\}} \sum_{v_{j} \in V^{k}} \lambda_{i}^{\text {out}} K L\left(\widehat{p}_{1}^{k}(i, j) \| p_{1}\left(v_{j}^{k} | v_{i}^{k}\right)\right) \\ &-\sum_{k \in\{X, Y\}} \sum_{v_{i} \in V^{k}} \lambda_{j}^{\text {in}} K L\left(\widehat{p}_{2}^{k}(i, j) \| p_{2}\left(v_{i}^{k} | v_{j}^{k}\right)\right) \end{aligned}  \\将 \lambda_{i}^{out} 定义为节点v_{i}的出度d_{i}^{out},\lambda_{j}^{in} 定义为节点v_{j}的入度d_{j}^{in} \\目标函数可以定义为：\\\begin{aligned} O_{1}=&-\sum_{k \in\{X, Y\}} \sum_{\left(v_{i}, v_{j}\right) \in E^{k}} w_{i j}^{k} \log p_{1}\left(v_{j}^{k} | v_{i}^{k}\right) \\ &-\sum_{k \in\{X, Y\}\left(v_{i}, v_{j}\right) \in E^{k}} w_{i j}^{k} \log p_{2}\left(v_{i}^{k} | v_{j}^{k}\right) \end{aligned}</script><p>保持两个网络中同一个节点嵌入向量一致的目标函数：</p><script type="math/tex; mode=display">\begin{aligned} O_{2}=&-\sum_{v_{k} \in Y} \sum_{\left(v_{i}, v_{j}\right) \in E^{X}} w_{i j}^{X} p_{a}\left(v_{i}^{X} | v_{k}^{Y}\right) \log p_{1}\left(v_{j}^{X} | v_{k}^{Y}\right) \\ &-\sum_{v_{k} \in Y} \sum_{\left(v_{i}, v_{j}\right) \in E^{X}} w_{i j}^{X} p_{a}\left(v_{j}^{X} | v_{k}^{Y}\right) \log p_{2}\left(v_{i}^{X} | v_{k}^{Y}\right) \\ &-\sum_{v_{k} \in X} \sum_{\left(v_{i}, v_{j}\right) \in E^{Y}} w_{i j}^{Y} p_{a}\left(v_{i}^{Y} | v_{k}^{X}\right) \log p_{1}\left(v_{j}^{Y} | v_{k}^{X}\right) \\ &-\sum_{v_{k} \in X} \sum_{\left(v_{i}, v_{j}\right) \in E^{Y}} w_{i j}^{Y} p_{a}\left(v_{j}^{Y} | v_{k}^{X}\right) \log p_{2}\left(v_{i}^{Y} | v_{k}^{X}\right) \end{aligned}</script><p>最终的目标函数 $O = O<em>{1} + O</em>{2}$</p><hr><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><script type="math/tex; mode=display">\text {Precision@} N=\frac{|\operatorname{Corr} U \operatorname{ser} @ N|^{X}+|\operatorname{Corr} U \operatorname{ser} @ N|^{Y}}{ | \text {UnMapped Anchors} | \times 2}  \\|\operatorname{Corr} U \operatorname{ser} @ N|:在嵌入空间的前n个邻居中发现的未映射anchor \ user及其对应用户的数量。 \\| \text {UnMapped Anchors} |是未映射用户的总数目</script><p>两个网络的度：</p><script type="math/tex; mode=display">\text {Interop}(X, Y)=\frac{ | \text {Correlations} | \times 2}{ | \text {Relations}^{X}|+| \text {Relations}^{Y} |} \\\text { Relations }^{X / Y} 是网络X/Y中直接连边的集合 \\ \text {Correlations} 是它们的交集</script><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>研究了跨网络映射用户的问题。提出了一种学习多网络嵌入以对齐网络的表示学习模型。该方法明确地将每个用户的follower-ship和followee-ship建模为输入和输出上下文。在这个模型中，给定的和潜在的锚链接都可以作为一个统一的学习框架中的硬约束和软约束来使用。采用随机梯度下降法和负抽样法对模型进行有效学习。</p>]]></content>
    
    
    <categories>
      
      <category>科研论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Social Networks</tag>
      
      <tag>User Identity Linkage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_Dynamic_Programming</title>
    <link href="/2019/09/30/leetcode-Dynamic-Programming/"/>
    <url>/2019/09/30/leetcode-Dynamic-Programming/</url>
    
    <content type="html"><![CDATA[<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><h2 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a>303. 区域和检索 - 数组不可变</h2><p><strong>题目描述：</strong></p><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p><a id="more"></a><p>示例：</p><blockquote><p>给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</p><p>sumRange(0, 2) -&gt; 1<br>sumRange(2, 5) -&gt; -1<br>sumRange(0, 5) -&gt; -3</p></blockquote><p>说明:<br>你可以假设数组不可变。<br>会多次调用 sumRange 方法。</p><p><strong>解答</strong><br>起初不太明白为什么这个题目是动态规划问。后来想到，如果每次求一个区间都要重新计算的话，复杂度比较高，可能存在很多重复计算。</p><p>如果求得 0-j 的和，每次计算只需要用 0-j 的和减去 0-i 的和，因为区间是闭区间，因此还要加上 i 的值。<br>先写了一个每次都重新计算的——超时了</p><p>考虑用空间替换时间，写一个数组保存 <code>0-每一个数</code> 的值</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""        :type nums: List[int]        """</span>        self.nums = nums        self.sum_array = []        tmp = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> self.nums:            tmp += num            self.sum_array.append(tmp)                <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(self, i, j)</span>:</span>        <span class="hljs-string">"""        :type i: int        :type j: int        :rtype: int        """</span>        <span class="hljs-keyword">return</span> self.sum_array[j]-self.sum_array[i]+self.nums[i]</code></pre><hr><h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a>392. 判断子序列</h2><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p><p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p><p>示例 1:<br>s = <code>&quot;abc&quot;</code>, t = <code>&quot;ahbgdc&quot;</code></p><p>返回 <code>true</code>.</p><p>示例 2:<br>s = <code>&quot;axc&quot;</code>, t = <code>&quot;ahbgdc&quot;</code></p><p>返回 <code>false</code>.</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(self, s, t)</span>:</span>        <span class="hljs-string">"""        :type s: str        :type t: str        :rtype: bool        """</span>        <span class="hljs-string">"""        遍历s中的每一个字符，若字符在t中出现，删除t中该字符前面的部分         """</span>        <span class="hljs-keyword">for</span> s_i <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> s_i <span class="hljs-keyword">in</span> t:                index = t.index(s_i)                t = t[index+<span class="hljs-number">1</span>:]  <span class="hljs-comment">## 删除前面那的字符串，只判断后面的</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre><hr><h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h2><p><strong>题目描述：</strong></p><p>数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>(索引从0开始)。</p><p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p><p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p><p>示例 1:</p><pre><code class="hljs angelscript">输入: cost = [<span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>]输出: <span class="hljs-number">15</span>解释: 最低花费是从cost[<span class="hljs-number">1</span>]开始，然后走两步即可到阶梯顶，一共花费<span class="hljs-number">15</span>。</code></pre><p>示例 2:</p><pre><code class="hljs angelscript">输入: cost = [<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1</span>]输出: <span class="hljs-number">6</span>解释: 最低花费方式是从cost[<span class="hljs-number">0</span>]开始，逐个经过那些<span class="hljs-number">1</span>，跳过cost[<span class="hljs-number">3</span>]，一共花费<span class="hljs-number">6</span>。</code></pre><p><strong>题解：</strong></p><p>刚开始没有太看懂这道题是什么意思，看了评论区大家的解释，<br>大体可以理解为你可以一次走一步或者两步楼梯，但是到了这个楼梯，在该楼梯上的花费必须要有。<br>求最小的爬楼梯花费，有点像之前的爬楼梯的题目。<br>因此对于当前台阶i，你可以从前一级过来，也可以从前一级的前一级过来，<br>由于你到达了该台阶，总花费需要加上当前第i台阶的花费</p><p><strong>代码：</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(self, cost)</span>:</span>        <span class="hljs-string">"""        :type cost: List[int]        :rtype: int        """</span>        n = len(cost)        <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> n==<span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> cost[<span class="hljs-number">0</span>]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,n):            cost[i] = min(cost[i<span class="hljs-number">-1</span>], cost[i<span class="hljs-number">-2</span>]) + cost[i]        <span class="hljs-keyword">return</span> min(cost[<span class="hljs-number">-1</span>],cost[<span class="hljs-number">-2</span>])</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读《Predict Anchor Links across Social Networks via an Embedding Approach》</title>
    <link href="/2019/09/28/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8APredict-Anchor-Links-across-Social-Networks-via-an-Embedding-Approach%E3%80%8B/"/>
    <url>/2019/09/28/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8APredict-Anchor-Links-across-Social-Networks-via-an-Embedding-Approach%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Predict-Anchor-Links-across-Social-Networks-via-an-Embedding-Approach"><a href="#Predict-Anchor-Links-across-Social-Networks-via-an-Embedding-Approach" class="headerlink" title="Predict Anchor Links across Social Networks via an Embedding Approach"></a>Predict Anchor Links across Social Networks via an Embedding Approach</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>这篇文章的思想很好理解，通过将源网络和目标网络嵌入到低维向量空间中，最后根据已观测到的 anchor link 监督信息，预测 hidden anchor link。</p><p>有一个问题是 “Cross Network Extension” 是否合理？？感觉他们的方法效果好的主要原因就是采取了两个 Cross Network Extension，嵌入的方法上使用 MLP 好像还可以进一步改进。</p><a id="more"></a><h2 id="Research-Objective"><a href="#Research-Objective" class="headerlink" title="Research Objective"></a>Research Objective</h2><p>如果没有关于社交用户的用户资料和 content 信息，如何利用网络结构解决 anchor link prediction 问题。</p><p>提出一种基于交叉网络嵌入的方法，将观察到的 Anchor Link 作为监督信息，进行Anchor Link预测。</p><h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><p>仅利用网络结构的方法包括：</p><ul><li><p>unsupervised：将该问题看做 network alignment 问题，通过寻找网络中节点之间的结构相似性来解决。</p></li><li><p>supervised：社交网络的结构特征，例如：度、聚类系数、共同邻居等</p><p>受网络结构的影响比较大，微小的网络结构扰动会产生比较大的影响</p></li></ul><p>充分利用 <strong>社交网络的结构规律</strong> 和 <strong>与所观察到的锚链接相关的信息</strong> 的方法</p><p><strong>Anchor link prediction</strong></p><p>Given two networks $G^{s} = {V^{s}, E^{s}}$ and $G^{t} = {V^{t}, E^{t}}$ and a set of observed anchor links $T={(v,u)|v \in V^{s}, u \in V{t}}$</p><p>Aim: identify hidden anchor links across $G^{s}$ and $G^{t}$</p><p>将源和目标网络嵌入到低维向量空间中，学习一个映射函数$Z^{s} \rightarrow Z^{t}$ </p><p>最优化目标：</p><script type="math/tex; mode=display">\min _{Z^{s}, Z^{t}, \phi}\left\{L_{e}\left(G^{s}, Z^{s}, G^{t}, Z^{t}, T\right)+L_{m}\left(\phi, Z^{s}, Z^{t}, T\right)\right\}</script><p>where $L<em>{e}\left(G^{s}, Z^{s}, G^{t}, Z^{t}, T\right)$ 是源网络和目标网络embedding到低维向量空间的loss，$L</em>{m}\left(\phi, Z^{s}, Z^{t}, T\right)$ 是 matching loss</p><hr><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>Predicting Anchor Links via Embedding</p><p><img src="/2019/09/28/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8APredict-Anchor-Links-across-Social-Networks-via-an-Embedding-Approach%E3%80%8B/PALE.png" srcset="/img/loading.gif" alt="PALE"></p><h3 id="1-Anchor-Link-aware-Network-Embedding"><a href="#1-Anchor-Link-aware-Network-Embedding" class="headerlink" title="1. Anchor-Link-aware Network Embedding"></a>1. Anchor-Link-aware Network Embedding</h3><h4 id="Cross-Network-Extension"><a href="#Cross-Network-Extension" class="headerlink" title="Cross Network Extension"></a>Cross Network Extension</h4><p><img src="/2019/09/28/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8APredict-Anchor-Links-across-Social-Networks-via-an-Embedding-Approach%E3%80%8B/extension.png" srcset="/img/loading.gif" alt="extension network"></p><p>利用观察到的anchor link扩展源网络和目标网络。源网络中没有的边，但是它们的counterpart在目标网络中存在边，将边加入到网络中去，对源网络进行扩充。目标网络的扩充也是如此。</p><h4 id="Network-Embedding"><a href="#Network-Embedding" class="headerlink" title="Network Embedding"></a>Network Embedding</h4><p>取log-likelihood并且进行负采样，得到目标函数：</p><script type="math/tex; mode=display">\log \sigma\left(z_{i}^{T} \cdot z_{j}\right)+\sum_{k=1}^{K} E_{v_{k} \propto P_{n}(v)}\left[\log \left(1-\sigma\left(z_{i}^{T} \cdot z_{k}\right)\right)\right]</script><h3 id="2-Supervised-Latent-Space-Matching"><a href="#2-Supervised-Latent-Space-Matching" class="headerlink" title="2. Supervised Latent Space Matching"></a>2. Supervised Latent Space Matching</h3><p>在观测到的 anchor links $\left(v<em>{l}^{s}, u</em>{n}^{t}\right) \in T$ 为监督信息的条件下，学习一个映射函数，将网络嵌入到潜在的空间内。</p><p>loss：</p><script type="math/tex; mode=display">L_{m}\left(\phi, Z^{s}, Z^{t}, T\right)=\sum_{\left(v_{l}^{s}, u_{n}^{t}\right) \in T}\left\|\phi\left(z_{l}^{s} ; \Theta\right)-z_{n}^{t}\right\|_{F}  \\\phi\left(z_{l}^{s} ; \Theta\right)=\Theta \times z_{l}^{s}, \quad v_{l}^{s} \in V^{s}</script><h3 id="3-Anchor-Link-Prediction"><a href="#3-Anchor-Link-Prediction" class="headerlink" title="3. Anchor Link Prediction"></a>3. Anchor Link Prediction</h3><p>为了预测源，对于源网络中任意给定节点 v 及其表示 z，可以根据映射函数将其映射到目标的潜在空间中。然后，通过识别与之对应的节点 u 最近的节点来预测 hidden anchor links.</p><script type="math/tex; mode=display">\min _{n}\left\|\phi\left(z_{l}^{s} ; \Theta\right)-z_{n}^{t}\right\|_{F}</script><h3 id="4-Experiments"><a href="#4-Experiments" class="headerlink" title="4. Experiments"></a>4. Experiments</h3><h4 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h4><blockquote><p><a href="http://socialnetworks.mpi-sws.org/data-wosn2009.html" target="_blank" rel="noopener">http://socialnetworks.mpi-sws.org/data-wosn2009.html</a> </p><p>微软学术圈会议的数据，按领域划分为数据挖掘和人工智能两个网络圈集合，进行这两个网络圈的用户对齐</p><p><a href="http://research.microsoft.com/en-us/projects/mag/" target="_blank" rel="noopener">http://research.microsoft.com/en-us/projects/mag/</a> </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>科研论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Social Networks</tag>
      
      <tag>User Identity Linkage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java_面向对象编程</title>
    <link href="/2019/09/27/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2019/09/27/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Java面向对象编程"><a href="#Java面向对象编程" class="headerlink" title="Java面向对象编程"></a>Java面向对象编程</h2><h3 id="1-面向对象（OOP）与面向过程（POP）"><a href="#1-面向对象（OOP）与面向过程（POP）" class="headerlink" title="1. 面向对象（OOP）与面向过程（POP）"></a>1. 面向对象（OOP）与面向过程（POP）</h3><p>二者都是一种思想，面向对象是相对于面向过程而言的。</p><p>面向过程，强调的是功能行为。</p><p>面向对象，将功能封装进对象，强调具备了功能的对象</p><a id="more"></a><p><strong>面向对象的三大特征</strong>：</p><p>封装、继承多态</p><h3 id="2-Java-类及类的成员"><a href="#2-Java-类及类的成员" class="headerlink" title="2. Java 类及类的成员"></a>2. Java 类及类的成员</h3><h4 id="属性：对应类中的成员变量"><a href="#属性：对应类中的成员变量" class="headerlink" title="属性：对应类中的成员变量"></a>属性：对应类中的成员变量</h4><p><strong>语法格式</strong></p><pre><code class="hljs java">修饰符 类型 属性名=初值;说明：修饰符 <span class="hljs-keyword">private</span> 表示该属性只能由该类的方法访问 修饰符 <span class="hljs-keyword">public</span> 表示该属性可以被该类以外的方法访问 类型：任何基本类型，如 <span class="hljs-keyword">int</span>，<span class="hljs-keyword">boolean</span> 或任何类例子：<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">//声明 private 变量 age</span><span class="hljs-keyword">public</span> String name=<span class="hljs-string">"Lisa"</span>; <span class="hljs-comment">// 声明 public 变量 name</span>&#125;</code></pre><p><strong>变量的分类</strong></p><ul><li>成员变量：类体内声明的变量<ul><li>实例变量（不以static修饰）：在类实例化成对象之后才能使用</li><li>类变量（以static修饰）：静态的，这样的变量不需要类实例化成对象就可以使用，可以通过<strong>类名.属性</strong>这样的方式直接调用</li></ul></li><li>局部变量：方法体内声明的变量<ul><li>形参（方法签名中定义的变量）</li><li>方法局部变量（在方法内定义）</li><li>代码块局部变量（在代码块定义）</li></ul></li><li>成员变量与局部变量的区别<ul><li>成员变量<ul><li>定义在类中，在整个类中都可以被访问</li><li>成员变量分为类成员变量和实例成员变量，实例变量存在与对象所在的堆内存中</li><li>成员变量的修饰符可以根据需要选择</li></ul></li><li>局部变量<ul><li>局部变量只定义在局部范围内，如：方法内、代码块内等</li><li>局部变量存在于栈内存中</li><li>作用的范围结束，变量空间会自动释放</li><li>局部变量没有默认初始化值，每次必须显式初始化</li><li>局部变量声明时不指定修饰符权限</li></ul></li></ul></li></ul><h4 id="行为：对应类中的成员方法"><a href="#行为：对应类中的成员方法" class="headerlink" title="行为：对应类中的成员方法"></a>行为：对应类中的成员方法</h4><p><strong>语法格式</strong></p><pre><code class="hljs java">修饰符 返回值类型 方法名(参数列表)&#123;方法体语句;&#125;说明：修饰符，<span class="hljs-keyword">public</span>，<span class="hljs-keyword">private</span>，<span class="hljs-keyword">protected</span>等 返回值类型：<span class="hljs-keyword">return</span>语句传递返回值，没有返回值，<span class="hljs-keyword">void</span>举例：<span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">// 声明方法getAge</span><span class="hljs-keyword">return</span> age;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123; <span class="hljs-comment">// 声明方法setAge</span>age = i;  <span class="hljs-comment">// 将参数的值赋值给类的成员变量age</span>&#125;&#125;</code></pre><p>方法只有被调用才会被执行</p><p><strong>注意</strong></p><p>没有具体返回值的情况，返回值类型用关键字void表示。</p><p>定义方法时，方法的结果应该返回给调用者，交由调用者处理。</p><p>方法中只能调用方法，不可以在方法内部定义方法。</p><p>面向对象程序设计的重点是<strong>类的设计</strong></p><p>定义类其实是定义类中的成员（成员变量和成员方法）</p><h3 id="3-类的语法格式"><a href="#3-类的语法格式" class="headerlink" title="3. 类的语法格式"></a>3. 类的语法格式</h3><pre><code class="hljs Java">修饰符 <span class="hljs-class"><span class="hljs-keyword">class</span> 类名</span>&#123;属性声明;方法声明;&#125;</code></pre><p>说明：public 修饰符，表示类可以被任意访问</p><p>​            类的正文要用 <code>{ }</code> 括起来</p><p>方法定义时，若有多个字母，采用驼峰命名法（首字母小写，其他单词首字母大写）</p><h3 id="4-创建-Java-自定义类"><a href="#4-创建-Java-自定义类" class="headerlink" title="4. 创建 Java 自定义类"></a>4. 创建 Java 自定义类</h3><p>步骤：</p><ol><li>定义类（考虑修饰符、类名）</li><li>编写类的属性（考虑修饰符、属性类型、属性名、初始化值）</li><li>编写类的方法（考虑修饰符、返回值类型、方法名、形参等）</li></ol><h3 id="5-对象的创建和使用"><a href="#5-对象的创建和使用" class="headerlink" title="5. 对象的创建和使用"></a>5. 对象的创建和使用</h3><p>java 类及类的成员</p><p>java 类的实例化，即创建类的对象</p><p>使用 <code>new</code> + 构造器 创建一个新的对象</p><p>使用 “对象名.对象成员” 的方式访问对象成员(包括属性和方法)</p><h3 id="6-关于对象"><a href="#6-关于对象" class="headerlink" title="6. 关于对象"></a>6. 关于对象</h3><h4 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h4><p>我们可以不定义对象的句柄，而直接调用这个对象的方法，这样的对象叫做匿名对象。例如：<code>new Person().show();</code></p><p>使用情况：</p><p>如果对一个对象只需要进行一次方法调用，那么就使用匿名对象</p><p>经常将匿名对象作为实参传递给一个方法调用</p><h3 id="7-方法的重载"><a href="#7-方法的重载" class="headerlink" title="7. 方法的重载"></a>7. 方法的重载</h3><p>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p><p><strong>重载的特点</strong></p><p>与返回值类型无关，只看<strong>参数列表</strong>，且参数列表必须不同（参数个数或参数类型），调用时，根据方法参数列表的不同来区别。</p><h3 id="8-方法的可变个数的参数"><a href="#8-方法的可变个数的参数" class="headerlink" title="8. 方法的可变个数的参数"></a>8. 方法的可变个数的参数</h3><p>不知道给一个方法传递的参数的个数</p><ul><li><p>数组形参</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, String[] books)</span></span>&#123;&#125;</code></pre></li><li><p>可变个数形参</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, String... books)</span></span>&#123;&#125;</code></pre></li></ul><p>说明：</p><p>​    可变参数：方法参数部分指定类型的参数个数是可变多个</p><p>​    声明方式：方法名 （参数类型名… 参数名）</p><p>​    可变参数方法的使用与方法参数部分使用数组是一致的</p><p>​    <strong>方法的参数部分有可变形参，需要放在形参声明的最后</strong></p><h3 id="9-方法的参数传递"><a href="#9-方法的参数传递" class="headerlink" title="9. 方法的参数传递"></a>9. 方法的参数传递</h3><p>方法必须有其所在类或对象调用才有意义。若方法含有参数：</p><ul><li>形参：声明方法时的参数</li><li>实参：方法调用时实际传给形参的参数值</li></ul><p>Java 方法参数的传递方式是<strong>值传递</strong>，即将实际参数值的副本传入方法内，而参数本身不受影响。</p><p><strong>JVM 的内存模型</strong></p><ul><li>栈 stack：基础数据类型、对象的引用（对象的地址）</li><li>堆 heap：所有的对象（包括自己定义的对象和字符串对象）</li><li>方法区 method：所有的 class 和 static 变量</li></ul><p>基本数据类型在参数的传递中，就是把实参的值复制到形参中。</p><p><strong>方法的参数传递之引用传递</strong></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ol><li>如果方法的形参是基本数据类型，那么实参（实际的数据）向形参传递参数时，就是直接传递值，把实参的值赋给形参。</li><li>如果方法的形参是对象，那么实参向形参传递参数时，这个值是实参在<strong>栈内存</strong>中的值，也就是引用对象在堆内存中的地址</li></ol><p>基本数据类型都是保存在栈内存中，引用对象在栈内存中保存的是引用对象在堆内存中的地址，那么方法的参数是传递值，实际上传递的是引用对象在堆内存中的地址。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java_数组</title>
    <link href="/2019/09/26/Java-%E6%95%B0%E7%BB%84/"/>
    <url>/2019/09/26/Java-%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><h4 id="一维数组声明"><a href="#一维数组声明" class="headerlink" title="一维数组声明"></a>一维数组声明</h4><p>type var[] 或 type[] var;</p><a id="more"></a><p>eg: </p><pre><code class="hljs java"><span class="hljs-keyword">int</span> a[];<span class="hljs-keyword">int</span>[] a1;<span class="hljs-keyword">double</span> b[];Mydata[] c; <span class="hljs-comment">//对象数组</span></code></pre><h4 id="一维数组初始化"><a href="#一维数组初始化" class="headerlink" title="一维数组初始化"></a>一维数组初始化</h4><ul><li><p>动态初始化：数组声明且<strong>为数组元素分配空间</strong>与<strong>赋值</strong>的操作分开</p><p>使用动态初始化的时候，数组的元素会有默认值，数字类型的默认值是0，对象类型的默认值是null</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> [] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];arr[<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>;arr[<span class="hljs-number">1</span>] = <span class="hljs-number">9</span>;arr[<span class="hljs-number">2</span>] = <span class="hljs-number">8</span>;</code></pre></li><li><p>静态初始化：在定义数组的同时就为数组元素分配空间并赋值</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>&#125;;<span class="hljs-keyword">int</span>[] a = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>&#125;;</code></pre></li></ul><h4 id="数组元素的引用"><a href="#数组元素的引用" class="headerlink" title="数组元素的引用"></a>数组元素的引用</h4><p>定义并用运算符 <code>new</code> 为之分配空间后，才可以引用数组中的每个元素</p><p>数组元素的引用方式：<code>数组名[数组元素下标]</code></p><p>每个数组都有一个属性 <code>length</code> 指明它的长度：数组一旦初始化，其长度是不可变的</p><hr><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>二维数组：一维数组中的元素是一维数组 数组中的数组</p><ul><li><p>动态初始化</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> arr[][] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>];<span class="hljs-comment">// 定义了名称为 arr 的二维数组</span><span class="hljs-comment">// 二维数组中有三个一维数组，每一个一维数组有两个元素</span></code></pre></li><li><p>动态初始化：只定义第一维的长度，第二维不定义</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> arr[][] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>][];<span class="hljs-comment">// 二维数组中有3个一维数组</span><span class="hljs-comment">// 每个一维数组都是默认初始化值 null</span><span class="hljs-comment">// 可以对这三个一维数组分别进行初始化</span><span class="hljs-comment">// arr[0] = new int[3]; arr[1] = new int[1]; arr[2] = new int[2];</span></code></pre></li><li><p>静态初始化</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> arr[][] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">7</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>&#125;&#125;</code></pre><p><strong>PS</strong> : <code>int []x, y[];</code> x 是一维数组，y是二维数组</p><p>一维数组：<code>int[] x</code> 或者 <code>int x[]</code></p><p>二维数组：<code>int [][] y</code>; 或者 <code>int[] y[];</code> 或者 <code>int y[][];</code></p></li></ul><hr><h3 id="数组中涉及的算法"><a href="#数组中涉及的算法" class="headerlink" title="数组中涉及的算法"></a>数组中涉及的算法</h3><p>最大值、最小值，总和，平均数</p><p>数组的复制和反转</p><p>排序：</p><pre><code>+ 冒泡排序：每完成一次循环，就将最大的元素排在最后（从小到大排序）</code></pre><h3 id="数组操作常见问题"><a href="#数组操作常见问题" class="headerlink" title="数组操作常见问题"></a>数组操作常见问题</h3><p>数组下标越界异常</p><p>空指针异常</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读《User Identity Linkage across Online Social Networks：A Review》</title>
    <link href="/2019/09/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AUser-Identity-Linkage-across-Online-Social-Networks%EF%BC%9AA-Review%E3%80%8B/"/>
    <url>/2019/09/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AUser-Identity-Linkage-across-Online-Social-Networks%EF%BC%9AA-Review%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="User-Identity-Linkage-across-Online-Social-Networks-A-Review"><a href="#User-Identity-Linkage-across-Online-Social-Networks-A-Review" class="headerlink" title="User Identity Linkage across Online Social Networks: A Review"></a>User Identity Linkage across Online Social Networks: A Review</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><blockquote><p>Shu K ,  Wang S ,  Tang J , et al. User Identity Linkage across Online<br>Social Networks: A Review[J]. ACM SIGKDD Explorations Newsletter, 2017,<br>18(2):5-17.</p></blockquote><p>这篇综述文章，总结了User Identity Linkage 问题的定义，现有的算法，数据集以及度量指标，并对该问题现存挑战和未来研究点进行了总结。</p><p>算法包括两个阶段：特征提取（Profile、Content、Network）、模型构建（监督、半监督、无监督）</p><a id="more"></a><p>数据集提供了两个可用的 public datasets:</p><ul><li><a href="https://www.aminer.cn/cosnet" target="_blank" rel="noopener">https://www.aminer.cn/cosnet</a></li><li><a href="http://www.mpi-sws.org/~ogoga/data.html" target="_blank" rel="noopener">http://www.mpi-sws.org/~ogoga/data.html</a></li><li><a href="http://www.ursino.unirc.it/pkdd-12.html" target="_blank" rel="noopener">http://www.ursino.unirc.it/pkdd-12.html</a> </li></ul><h2 id="Research-Objective"><a href="#Research-Objective" class="headerlink" title="Research Objective"></a>Research Objective</h2><ul><li>对 User Identity linkage problem 提出了一个正式的定义</li><li>提出了一个统一框架：特征提取、模型构建</li><li>数据集与评价指标总结</li><li>未来研究方向</li></ul><h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><p>目前，越来越多的人使用多个社交平台，每个社交平台的功能不同，因此通过不同平台搜集的用户信息实际上是刻画每一个用户不同方面的特征。单一社交平台并不能捕捉用户的个性和兴趣。如果我们能够将不同平台上的同一个用户身份识别出来，利用用户来自多个不同社交平台的信息，就能够更好得理解用户的兴趣，为其提供更好的推荐和服务。另外，利用用户多个社交网络的信息，能够整合其社交模式，帮助解决冷启动和数据稀疏性问题。</p><h4 id="Linking-User-Identity-定义："><a href="#Linking-User-Identity-定义：" class="headerlink" title="Linking User Identity 定义："></a>Linking User Identity 定义：</h4><ul><li><p><strong>Enhancing Friend Recommendation</strong></p><p>对于一个社交网络中的用户 A 和 B 有共同好友 C，因此会将用户 A 推荐给用户 B。若可以应用跨社交网络的补充信息，即使 A 和 B 在另一个社交网络中没有共同好友，将用户 A 推荐给 B 也是较好的 friend recommendation</p><p><img src="/2019/09/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AUser-Identity-Linkage-across-Online-Social-Networks%EF%BC%9AA-Review%E3%80%8B/application.png" srcset="/img/loading.gif" alt="application"></p></li><li><p><strong>Information diffusion</strong></p><p>目前信息传播的研究是基于单个社交网络的。实际上，信息和流言得传播极有可能是跨社交平台的，研究什么样的信息更容易在一个社交内的网络内传播，什么样的信息更容易跨社交网络传播都是极有意义的。</p></li><li><p><strong>Analyzing Network Dynamics</strong></p></li></ul><h4 id="Identity-Linkage-Challenge"><a href="#Identity-Linkage-Challenge" class="headerlink" title="Identity Linkage Challenge"></a>Identity Linkage Challenge</h4><p>task：linking user‘s account on multiple social sites</p><ol><li>用户社交网络上的身份信息可以与他在真实世界中的身份信息不相同</li><li>在线社交网络数据庞大，存在较多噪声数据、非结构化、不完整</li></ol><p>在线社交网络中 user identity data 的特点：</p><ul><li>Profile inconsistency：不同的用户资料关注点，故意信息造假</li><li>Content Heterogeneity：用户发布的内容反映了他的社会活动行为，在社交网络中产生的内容包括文字、图片、视频等，多源异构信息难以利用。数据孤岛。</li><li>Network Diversity：某用户在不同社交平台的社交网路结构是不同的</li></ul><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h3 id="Problem-Definition"><a href="#Problem-Definition" class="headerlink" title="Problem Definition"></a>Problem Definition</h3><p>对于一个现实世界中的自然人P：</p><ul><li>Profile：对该用户的描述，eg：用户名、位置、年龄、职业等</li><li>Context：表示用户活动的属性，包括时间、位置、文本、图片等</li><li>Network：描述该用户与其他用户的社会关系</li></ul><p><img src="/2019/09/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AUser-Identity-Linkage-across-Online-Social-Networks%EF%BC%9AA-Review%E3%80%8B/definition.png" srcset="/img/loading.gif" alt="definition"></p><hr><h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p><img src="/2019/09/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AUser-Identity-Linkage-across-Online-Social-Networks%EF%BC%9AA-Review%E3%80%8B/framework.png" srcset="/img/loading.gif" alt="framework"></p><h4 id="1-Feature-Extraction"><a href="#1-Feature-Extraction" class="headerlink" title="1. Feature Extraction"></a>1. Feature Extraction</h4><h4 id="1-1-Profile-Features"><a href="#1-1-Profile-Features" class="headerlink" title="1.1. Profile Features"></a>1.1. Profile Features</h4><p><strong>Public profile fileds</strong></p><p>​    username</p><p>​    screen name：账户名</p><p>​    Biography：text description</p><p>​    Education</p><p>​    Avatar</p><p><strong>根据用户资料识别用户身份的方法</strong></p><ul><li>Distance-based<ul><li>文本类型：Jaro-Winkler distance，Jaccard similarity, and Levenshtein (Edit) distance </li><li>图像：mean square error, peak signal-to-noise ratio, and Levenshtein distance </li></ul></li><li>Frequency-based<pre><code>+ 文本类型：bag-of-word model， TF-IDF model     + 其他：probabilistic model ：Markov-chain model</code></pre></li></ul><h4 id="1-2-Content-Features"><a href="#1-2-Content-Features" class="headerlink" title="1.2. Content Features"></a>1.2. Content Features</h4><p><strong>特征</strong></p><ul><li>Temporal：用户活动的时间戳</li><li>Spatial：有位置标签的，可以转成精确的经纬度；没有位置标签可以从用户发布的文字和图片中提取</li><li>Post：文字或图像</li></ul><p><strong>方法</strong></p><ul><li><p>Interest-based：long-term topic modeling — 提取用户的核心兴趣</p><blockquote><p>Liu et.al. Hydra: Large-scale social identity linkage via heterogeneous behavior modeling. In SIGMOD, 2014. </p></blockquote><p><a href="https://dl.acm.org/citation.cfm?id=2588559&amp;preflayout=flat" target="_blank" rel="noopener">https://dl.acm.org/citation.cfm?id=2588559&amp;preflayout=flat</a></p><blockquote><p>Yuanping Nie, Yan Jia, Shudong Li, Xiang Zhu, Aiping Li, and Bin Zhou. Identifying users across social networks based on dynamic core interests. Neurocomputing, 2016. </p></blockquote></li><li><p>Style-based：提取用户的写作风格。</p><ul><li>n-gram language model </li><li>term-frequency analysis</li></ul></li><li><p>Trajectory-based：具有时间戳的位置数据</p></li></ul><h4 id="1-3-Network-Features"><a href="#1-3-Network-Features" class="headerlink" title="1.3. Network Features"></a>1.3. Network Features</h4><p><strong>网络分类</strong></p><ul><li>local network：只考虑直接相连的邻居（following/followee/friend relationship)，是用户的ego-network</li><li>global network：所有用户都要考虑进去</li></ul><p><strong>方法</strong></p><ul><li>Neighborhood-based：邻居的数量，入度/出度，Dice coefficient ，common neighbors, Jaccard’s coefficient and Adamic/Adar score </li><li>Embedding-based：<ul><li>first-order proximity </li><li>second-order proximity </li></ul></li></ul><blockquote><p>local network中，只有 Neighborhood-based 方法可以用，而 global network 上述两种方法都可以使用</p></blockquote><h4 id="1-4-Discussion"><a href="#1-4-Discussion" class="headerlink" title="1.4. Discussion"></a>1.4. Discussion</h4><p>Profile features 最容易获得，但是也信息也是最容易被伪造的。由于不同社交平台会要求填写不同的用户资料，数据不一致性会更强。</p><p>Content features 会非常稀疏，因为用户可能并不活跃</p><p>Network features 噪声数据较多；一些特征必须是基于两个完全一致的网络提取的。</p><h4 id="2-Model-Construction"><a href="#2-Model-Construction" class="headerlink" title="2. Model Construction"></a>2. Model Construction</h4><h4 id="2-1-Supervised-Model"><a href="#2-1-Supervised-Model" class="headerlink" title="2.1 Supervised Model"></a>2.1 Supervised Model</h4><p>典型的二分类问题</p><ul><li><p><strong>Aggregating methods</strong></p><p>hybrid weighted form 混合加权的形式 combine 不同的相似性分数</p><p><img src="/2019/09/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AUser-Identity-Linkage-across-Online-Social-Networks%EF%BC%9AA-Review%E3%80%8B/f1.png" srcset="/img/loading.gif" alt="hybrid weighted form"></p></li><li><p><strong>Probabilistic methods</strong></p><p>预测类标签的概率分布</p><script type="math/tex; mode=display">\mathcal{F}(\vec{x})=\arg \max \operatorname{Pr}\left(y=1 | \vec{x},\left(\mathcal{M}^{\prime}, \mathcal{N}^{\prime}\right), M\right)</script><p>Maximum a posteriori (MAP) estimate 最大后验估计，可以通过贝叶斯理论求解</p></li><li><p><strong>Boosting methods</strong></p><p>通过多个弱假设学习一个强假设</p><script type="math/tex; mode=display">\mathcal{F}(\vec{x})=\operatorname{sign}\left(\sum_{i=1}^{T} \alpha_{i} h_{i}(\vec{x})\right)</script></li><li><p><strong>Projection methods</strong></p><p>学习一个映射函数：学习原始特征空间和在线社交网络中用户身份的潜在特征空间的映射关系</p><script type="math/tex; mode=display">\hat{u}^{t}=\underset{u^{t} \in \mathcal{U}^{t}}{\arg \min } \mathbb{D}\left(\Phi_{s}\left(u^{s}\right), \Phi_{t}\left(u^{t}\right)\right)</script><p>$\mathbb{D}$ 是衡量潜在特征空间中用户s和用户d之间距离的函数</p></li></ul><h4 id="2-2-Semi-Supervised-Model"><a href="#2-2-Semi-Supervised-Model" class="headerlink" title="2.2 Semi-Supervised Model"></a>2.2 Semi-Supervised Model</h4><ul><li><p><strong>Propagation methods</strong></p><p>seed matching user identity pairs </p><p>定义一个函数来计算用户身份的匹配程度，通过使用其已知的邻居信息以及其他特征</p><p>每一轮迭代过程中，匹配分数高的用户身份对被选择出来</p><p>两种<strong>propagation order</strong>：</p><pre><code>+ Exhaust comparison ：从未匹配对中找到，加入+ Local expansion 从现有匹配的用户对的邻居扩展候选匹配对扩充</code></pre></li><li><p><strong>Embedding methods</strong></p><p>在源网络和目标网络中，半监督嵌入方法通常共同学习用户身份的潜在特征。</p></li></ul><h4 id="2-3-Unsupervised-Model"><a href="#2-3-Unsupervised-Model" class="headerlink" title="2.3 Unsupervised Model"></a>2.3 Unsupervised Model</h4><ul><li><strong>Aligning Methods</strong><ul><li>对每一对候选 user identities 计算 affinity score</li><li>构建一个二分网络</li><li>根据得到的图G，形式化为一个优化问题，实现所有用户标识对的一对一匹配。</li></ul></li><li><strong>Progressive methods</strong><ul><li>利用具有较强识别力的特征来寻找局部 ground truth</li><li>所有提取的特征都可以用来对剩余的未标记用户标识执行分类</li></ul></li></ul><h4 id="2-4-Discussion"><a href="#2-4-Discussion" class="headerlink" title="2.4 Discussion"></a>2.4 Discussion</h4><ul><li>可扩展性</li><li>多样性</li></ul><h4 id="3-Summary-of-UIL-Algorithms"><a href="#3-Summary-of-UIL-Algorithms" class="headerlink" title="3. Summary of UIL Algorithms"></a>3. Summary of UIL Algorithms</h4><hr><h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h3><h4 id="1-Datasets"><a href="#1-Datasets" class="headerlink" title="1. Datasets"></a>1. Datasets</h4><h4 id="2-Evaluation-Metrics"><a href="#2-Evaluation-Metrics" class="headerlink" title="2. Evaluation Metrics"></a>2. Evaluation Metrics</h4><ul><li><p>Prediction metrics</p><ul><li>TP：预测为 true，真实为 true</li><li>TN：预测为 false，真实为 false</li><li>FN：预测为 false，真实为 true</li><li>FP：预测为 true，真实为 false</li></ul><script type="math/tex; mode=display">Precision=\frac{|T P|}{|T P|+|F P|}  \\Recall=\frac{|T P|}{|T P|+|F N|}  \\Accuracy=\frac{|T P|+|T N|}{|T P|+|T N|+|F P|+|F N|}</script><p>Identity-based Accuracy :</p><script type="math/tex; mode=display">I-Acc=\frac{\# \text { correctly identified user identities }}{\# \text { ground truth user identities }}</script></li><li><p>Ranking metrics</p><ul><li><p>ROC 曲线</p><ul><li><p>FPR（False Positive Rate）</p><script type="math/tex; mode=display">TPR=\frac{|T P|}{|T P|+|F N|}</script></li><li><p>TPR（True Positive Rate）</p><script type="math/tex; mode=display">FPR=\frac{|F P|}{|F P|+|T N|}</script></li></ul></li><li><p>Area Under ROC curve （AUC）</p><script type="math/tex; mode=display">A U C=\frac{n_{1}+1-r_{1}}{n_{1}}  \\\text {Hit-Pricision}=\frac{n_{1}+2-r_{1}}{n_{1}+1}</script></li></ul></li><li><p>Mean Reciprocal Rank (MRR)</p></li><li>Mean Average Precision (MAP)</li></ul><hr><h3 id="Related-Areas"><a href="#Related-Areas" class="headerlink" title="Related Areas"></a>Related Areas</h3><p><img src="/2019/09/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8AUser-Identity-Linkage-across-Online-Social-Networks%EF%BC%9AA-Review%E3%80%8B/research_aspects.png" srcset="/img/loading.gif" alt="research_aspects"></p><h3 id="Open-Issues-and-Future-Research-Directions"><a href="#Open-Issues-and-Future-Research-Directions" class="headerlink" title="Open Issues and Future Research Directions"></a>Open Issues and Future Research Directions</h3><ul><li>Data Challenge</li><li>Dynamic user identity linkage</li><li>Jointly user identity linkage and recommendation </li><li>Jointly user identity linkage and link prediction </li></ul>]]></content>
    
    
    <categories>
      
      <category>科研论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Social Networks</tag>
      
      <tag>User Identity Linkage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组会记录</title>
    <link href="/2019/09/18/%E7%BB%84%E4%BC%9A%E8%AE%B0%E5%BD%95/"/>
    <url>/2019/09/18/%E7%BB%84%E4%BC%9A%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h2><h3 id="经典网络结构"><a href="#经典网络结构" class="headerlink" title="经典网络结构"></a>经典网络结构</h3><p>RCNN 2014</p><p>Fast RCNN 2015</p><p><strong>Backbone Networks</strong></p><ul><li><p>VGG16/VGG19</p></li><li><p>ResNet, ResNext</p></li></ul><p><strong>RCNN: Region based CNN</strong></p><p><strong>Faster RCNN</strong></p><p><strong>Mask RCNN</strong></p><p><strong>YOLO</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 刷题</title>
    <link href="/2019/09/18/leetcode-%E5%88%B7%E9%A2%98/"/>
    <url>/2019/09/18/leetcode-%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-刷题记录"><a href="#Leetcode-刷题记录" class="headerlink" title="Leetcode 刷题记录"></a>Leetcode 刷题记录</h2><h3 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a>191. 位1的个数</h3><p>汉明重量：一串符号中非零符号的个数，在数据位符号串中，指1的个数</p><a id="more"></a><p><strong>方法1</strong></p><p>遍历一个数字的 32 位，如果某一位为 1，就将计数器加 1。</p><p>运行时间依赖于数字 n 的位数，此题中 n 是一个 32 位数，所以运行时间是 O(1) 的</p><p><strong>方法2</strong></p><p>位操作小技巧：在二进制表示中，将 n 和 n-1 做与运算总是能把 n 中最低位的 1 变成 0，并保持其他位不变</p><h3 id="193-有效的电话号码"><a href="#193-有效的电话号码" class="headerlink" title="193. 有效的电话号码"></a>193. 有效的电话号码</h3><p><code>grep</code>对文本或输出内容进行过滤</p><p><code>grep [OPTIONS] PATTERN [FILE ...]</code></p><p><code>grep</code>按行检索输入的每一行，如果输入行包含模式<code>PATTERN</code>，则输出这一行。这里的<code>PATTERN</code>是正则表达式。</p><p><code>-i</code> 使 grep 在匹配模式时忽略大小写</p><p><code>-o</code> 表示只输出匹配的字符，而不是整行</p><p><code>-c</code> 统计匹配的行数</p><p><code>-v</code> 表示取反匹配</p><p><code>-P</code> 表示使用 perl 的正则表达式进行匹配</p><h3 id="195-第十行"><a href="#195-第十行" class="headerlink" title="195. 第十行"></a>195. 第十行</h3><ul><li><p><code>sed</code> 命令</p><p><code>sed --help</code> 查看具体使用规则</p><p><code>sed -n &#39;xp&#39; filename</code> 显示文件X行命令   </p><p><code>sed -n &#39;x,yp&#39; filename</code> 显示文件X行到Y行的内容</p></li><li><p><code>head</code> 命令</p><p><code>head [参数]...[文件]...</code> head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。</p></li><li><p><code>tail</code> 命令</p><p><code>tail [必要参数] [选择参数] [文件]</code> tail 命令从指定点开始将文件写到标准输出.</p><p>使用 <code>tail</code> 命令的 <code>-f</code>选项可以方便的查阅正在改变的日志文件,<code>tail -f filename</code>会把<code>filename</code>里最尾部的内容显示在屏幕上, 并且不刷新, 使你看到最新的文件内容. </p></li><li><p><code>head</code> 命令和 <code>tail</code> 命令结合</p></li></ul><h3 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h3><p>判断一个数是否是质数的方法：</p><ul><li><p>暴力算法</p></li><li><p>优化暴力算法：当判断一个数是否是质数时，用 2-sqrt(n) 之间的整数去除</p></li><li><p><strong>厄拉多塞筛法</strong></p><p><img src="/2019/09/18/leetcode-%E5%88%B7%E9%A2%98/204.gif" srcset="/img/loading.gif" alt="img"></p></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读《TransLink: User Identity Linkage across Heterogeneous Social Networks via Translating Embeddings》</title>
    <link href="/2019/09/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ATransLink-User-Identity-Linkage-across-Heterogeneous-Social-Networks-via-Translating-Embeddings%E3%80%8B/"/>
    <url>/2019/09/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ATransLink-User-Identity-Linkage-across-Heterogeneous-Social-Networks-via-Translating-Embeddings%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="TransLink-User-Identity-Linkage-across-Heterogeneous-Social-Networks-via-Translating-Embeddings"><a href="#TransLink-User-Identity-Linkage-across-Heterogeneous-Social-Networks-via-Translating-Embeddings" class="headerlink" title="TransLink: User Identity Linkage across Heterogeneous Social Networks via Translating Embeddings"></a>TransLink: User Identity Linkage across Heterogeneous Social Networks via Translating Embeddings</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><h2 id="Research-Objective"><a href="#Research-Objective" class="headerlink" title="Research Objective"></a>Research Objective</h2><p>针对多个社交平台的账号判断是否是同一个人，</p><p>提出 translation-modeling approach: 对用户信息以及其交互行为一起进行嵌入</p><ol><li>网络模式和交互元数据提取</li><li>Translating embeddings </li><li>Iterative identity linkage </li></ol><a id="more"></a><h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><p>User Identity Linkage</p><p><strong>Challenges</strong></p><p>社交网络的异质性</p><p>用户信息的稀疏性和不完整性</p><p>缺少已知的 anchor link</p><h3 id="现有方法"><a href="#现有方法" class="headerlink" title="现有方法"></a>现有方法</h3><ul><li><p>Attribute-based approaches: username，location, avatar, etc.</p></li><li><p>User generated content (UGC) based approaches: interest, writing style, trajectory</p></li><li>Network-based approaches: <ul><li>neighborhood-based</li><li>network representation to learn follower-ship and followee-ship</li></ul></li></ul><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>TransLink</p><h3 id="1-Extractions-of-Network-Schemas-and-interaction-metapaths"><a href="#1-Extractions-of-Network-Schemas-and-interaction-metapaths" class="headerlink" title="1.  Extractions of Network Schemas and interaction metapaths"></a>1.  Extractions of Network Schemas and interaction metapaths</h3><p><strong>Network Schema</strong></p><p>a directed graph $\mathcal G=(V, E)$ $V$ 是 G 的顶点类型的集合，$G$是边的类型的集合。</p><p><strong>Interaction Metapath </strong></p><script type="math/tex; mode=display">p_{ab} = u_{a}\stackrel{r_{1}}{\rightarrow}v_{1}\stackrel{r_{2}}{\rightarrow}v_{2}\stackrel{r_{3}}{\rightarrow}...\stackrel{r_{k}}{\rightarrow}u_{b}</script><h3 id="2-Translating-Embeddings"><a href="#2-Translating-Embeddings" class="headerlink" title="2. Translating Embeddings"></a>2. Translating Embeddings</h3><p>由于边中会隐含一些语义信息，仅通过对网络中的节点进行 embedding 是有限的，与传统的 embedding 方式不同，translation-based techniques 可以同时对节点和边进行 embedding。</p><p>translation-based framework: 对于一个 triple $(h, e, t)$, $h + e \approx t$</p><h4 id="Intra-network-Embeddings"><a href="#Intra-network-Embeddings" class="headerlink" title="Intra-network Embeddings"></a>Intra-network Embeddings</h4><p>a triple $(u<em>{a}, p</em>{ab}, u_{b})$</p><p>定义 energy function $E(u<em>{a}, p</em>{ab}, u<em>{b}) =||u</em>{a} + p<em>{ab} - u</em>{b}||$ 表示经过metapath $p_{ab}$的能量转移</p><p>$u<em>{a}$ 到 $u</em>{b}$ 的能量转移函数定义为：</p><script type="math/tex; mode=display">E(u_{a}, p_{ab}, u_{b}) = \frac{1}{\Gamma}\sum_{p_{ab}\in P_{ab}} R(p_{ab}|u_{a},u_{b})E(u_{a}, p_{ab}, u_{b}) \\P_{ab}:从\ u_a\ 到\ u_b\ 的\ metapath\ 的集合 \\R(p_{ab}|u_{a},u_{b}):给定一个(u_a,u_b)，metapath-p_{ab}的置信度 \\\Gamma 是 \ normalization\  factor</script><p>定义margin-based score function</p><script type="math/tex; mode=display">S_{intra} = \sum_{T\in \lbrace T^{(i)}|i\in [1,m]\rbrace} \sum_{(u_a,r,u_b)\in T}(L(u_a,r,u_b) + \sum_{p_{ab}\in P_{ab}} R(p_{ab}|u_{a},u_{b})L(p_{ab},r)) \\L(u_a,r,u_b) = \sum_{u^{'}_a,r^{'},u^{'}_b}max \lbrace 0,\gamma +E(u_a,r,u_b)-E(u^{'}_a,r^{'},u^{'}_b)\rbrace  \\L(p_{ab},r) = \sum_{(u_a,r^{'},u_b)\in T^{-}}max \lbrace 0,\gamma +E(p_{ab},r)-E(p^{'}_{ab},r^{'})\rbrace  \\</script><h4 id="Inter-network-Embeddings"><a href="#Inter-network-Embeddings" class="headerlink" title="Inter-network Embeddings"></a>Inter-network Embeddings</h4><script type="math/tex; mode=display">E(u^{(i)}_{a},u^{(j)}_{x}) = \parallel u^{(i)}_{a} + r^{(ij)}_{ax}-u^{(j)}_{x}\parallel   \\S_{inter} = \sum_{r^{(ij)}_{ax} \in Z} \lambda E(u^{(i)}_{a},u^{(j)}_{x})</script><h4 id="Iterative-Identity-Linkage"><a href="#Iterative-Identity-Linkage" class="headerlink" title="Iterative Identity Linkage"></a>Iterative Identity Linkage</h4><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2>]]></content>
    
    
    <categories>
      
      <category>科研论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Social Networks</tag>
      
      <tag>User Identity Linkage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java - 基本语法</title>
    <link href="/2019/09/16/Java-%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2019/09/16/Java-%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-程序流程控制"><a href="#Java-程序流程控制" class="headerlink" title="Java 程序流程控制"></a>Java 程序流程控制</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><p>从上到下逐行执行，中间没有任何判断和跳转</p><a id="more"></a><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><p>根据条件，选择性地执行某段代码</p><p>有 if… else 和 switch 两种分支语句</p><p><strong>if…else结构</strong></p><p>if 语句的三种格式</p><pre><code class="hljs Java"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">true</span>)&#123;执行代码块;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">if</span>(条件表达式)&#123;执行代码块;&#125;<span class="hljs-keyword">else</span>&#123;执行代码块;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">if</span>(条件表达式)&#123;执行代码块;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件表达式)&#123;执行代码块;&#125;...<span class="hljs-keyword">else</span>&#123;执行代码块;&#125;</code></pre><p><strong>switch结构</strong></p><pre><code class="hljs angelscript"><span class="hljs-keyword">switch</span>(变量)&#123;<span class="hljs-keyword">case</span> 常量 <span class="hljs-number">1</span>:语句 <span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> 常量 <span class="hljs-number">2</span>:语句 <span class="hljs-number">2</span>;<span class="hljs-keyword">break</span>;... ...<span class="hljs-keyword">case</span> 常量 N:语句 N;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:语句;<span class="hljs-keyword">break</span>;&#125;</code></pre><p>switch 语句有关规则：</p><p>switch(表达式) 中表达式的<strong>返回值</strong>必须是：<strong>byte, short, char, int, 枚举, String </strong>中的一种</p><p>case 子句中的值必须是<strong>常量</strong>，且所有 case 子句中的值应是不同的</p><p>default 子句是可任选的，没有匹配case时，执行default</p><p>break 语句用来在执行完一个case分支后使程序跳出switch语句块; 如果没有break，程序会顺序执行到switch结尾</p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>根据循环条件，重复地执行某段代码</p><p>有 while, do…while, for 三种循环语句</p><p><strong>循环语句的四个组成部分：</strong></p><ul><li>初识化部分</li><li>循环条件部分</li><li>循环体部分</li><li>迭代部分</li></ul><p><strong>循环语句分类：</strong></p><ul><li><p>for 循环</p><pre><code class="hljs java"><span class="hljs-keyword">for</span>(初始化表达式; 布尔测试表达式; 更改表达式)&#123;语句或语句块&#125;</code></pre></li><li><p>while 循环</p><pre><code class="hljs java">[初始化语句;]<span class="hljs-keyword">while</span>(布尔测试表达式)&#123;语句或语句块;[更改语句;]&#125;</code></pre></li><li><p>do/while 循环</p><pre><code class="hljs abnf">[初始化语句<span class="hljs-comment">;]</span>do&#123;语句或语句块<span class="hljs-comment">;</span>[更改语句<span class="hljs-comment">;]</span>&#125;while(布尔值测试表达式)<span class="hljs-comment">;</span></code></pre></li></ul><p><strong>嵌套循环：</strong></p><p>将一个循环放在另一个循环体内，就形成了嵌套循环。</p><p>实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为 false 时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环。</p><p>设外层循环次数为 m，内层循环次数为 n，则内层循环体实际上要执行 m*n 次</p><blockquote><p>在写嵌套循环时，如果两种嵌套方式能够达到一样的效果，尽量保证外层循环的循环次数小于内层的循环次数</p></blockquote><h3 id="特殊流程控制语句"><a href="#特殊流程控制语句" class="headerlink" title="特殊流程控制语句"></a>特殊流程控制语句</h3><p><strong>break 语句</strong></p><p>用于终止某个语句块的执行</p><p>终止当前所在的循环</p><p><strong>continue 语句</strong></p><p>不再执行当前循环体中continue语句之后的代码，直接进行下一次循环</p><p><strong>return</strong></p><p>直接结束一个方法，不管这个return处于多少层循环之内</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读《DPLink: User Identity Linkage via Deep Neural Network From Heterogeneous Mobility Data》</title>
    <link href="/2019/09/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADPLink-User-Identity-Linkage-via-Deep-Neural-Network-From-Heterogeneous-Mobility-Data%E3%80%8B/"/>
    <url>/2019/09/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADPLink-User-Identity-Linkage-via-Deep-Neural-Network-From-Heterogeneous-Mobility-Data%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="DPLink-User-Identity-Linkage-via-Deep-Neural-Network-From-Heterogeneous-Mobility-Data"><a href="#DPLink-User-Identity-Linkage-via-Deep-Neural-Network-From-Heterogeneous-Mobility-Data" class="headerlink" title="DPLink: User Identity Linkage via Deep Neural Network From Heterogeneous Mobility Data"></a>DPLink: User Identity Linkage via Deep Neural Network From Heterogeneous Mobility Data</h2><blockquote><p>Jie Feng1, Mingyang Zhang1, Huandong Wang1, Zeyu Yang1, Chao Zhang2, Yong Li1, Depeng Jin1 . 2019. DPLink: User Identity Linkage via Deep Neural Network From Heterogeneous Mobility Data. In Proceedings of the 2019 World Wide Web Conference (WWW ’19), May 13–17, 2019, San Francisco, CA, USA. ACM, New York, NY, USA, 11 pages. <a href="https://doi.org/10.1145/3308558.3313424" target="_blank" rel="noopener">https://doi.org/10.1145/3308558.3313424</a> </p></blockquote><p>提出一个端到端的深度学习框架，从异构流动性数据中进行user identity linkage</p><p>feature extractor：location encoder and a trajectory encoder</p><p>comparator module</p><a id="more"></a><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>linking online indentities: user profile attributes and social graphs</p><p>提出基于用户活动的时空位置信息进行 user IDs linkage</p><p><strong>Challenges</strong></p><p>Heterogeneity nature of mobility data 移动数据的异质性</p><p>Poor quality of mobility data  移动数据的质量不高：</p><p>​    收集的数据只有<strong>时间</strong>和<strong>位置</strong>信息，并不能通过此发现挖掘其中的潜在语义关系</p><p>​    数据中包含大量的噪声数据</p><p><strong>Contributions</strong></p><p>extractor module: </p><ul><li>location encoder: 整合多维输入，提取孤立位置的底层特征</li><li>trajectory encoder: 捕获单个轨迹本身的过渡关系 (recurrent encoder)，并对两个不同轨迹之间的关联进行建模</li><li>selector: attention based</li></ul><p>comparator module: a multilayer feed-forward network </p><h2 id="2-Problem-Formulation"><a href="#2-Problem-Formulation" class="headerlink" title="2. Problem Formulation"></a>2. Problem Formulation</h2><p>给定一个用户的轨迹和候选用户，根据他们运动轨迹的相似性判断他们是否是同一个人</p><p><img src="/2019/09/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADPLink-User-Identity-Linkage-via-Deep-Neural-Network-From-Heterogeneous-Mobility-Data%E3%80%8B/difference.png" srcset="/img/loading.gif" alt="img"></p><h2 id="3-Model-and-Method"><a href="#3-Model-and-Method" class="headerlink" title="3. Model and Method"></a>3. Model and Method</h2><p><img src="/2019/09/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADPLink-User-Identity-Linkage-via-Deep-Neural-Network-From-Heterogeneous-Mobility-Data%E3%80%8B/architecture.png" srcset="/img/loading.gif" alt="img"></p><h3 id="3-1-Location-Encoder"><a href="#3-1-Location-Encoder" class="headerlink" title="3.1 Location Encoder"></a>3.1 Location Encoder</h3><p>a trajectory point $p_{i} = ( t<em>{i}, l</em>{i})$  —&gt; a single vector $x_{i}$</p><p><strong>embedding module</strong></p><script type="math/tex; mode=display">x_{i} = tanh(W_{p}p_{i} + b_{p}) = tanh([W_{t}t_{i} + b_{t};W_{l}l_{i} + b_{l};W_{e}e_{i} + b_{e}])</script><p>$W$ and $b$ denote the learnable parameters of embedding layers</p><p>$[;;]$ denotes the concatenate function</p><h3 id="3-2-Trajectory-encoder"><a href="#3-2-Trajectory-encoder" class="headerlink" title="3.2 Trajectory encoder"></a>3.2 Trajectory encoder</h3><p><strong>Reccurent Encoder</strong></p><p>输入 location encoder 产生的结果 ${x<em>{1}, x</em>{2}, …, x<em>{n}}$, 通过 LSTM 和 Max/Mean pooling 操作，产生encoded trajectory feature ${h</em>{1}, h<em>{2}, …, h</em>{n}}$</p><p><strong>Co-Attention based Selector</strong></p><ul><li>calculate the “correlation” between the query vector $q$ and all the candidate vectors  ${h<em>{1}, h</em>{2}, …, h_{n}}$</li><li>normalized “correlation” as weights ${α1, α2, …, αn}$, to calculate the weighted sum $y$<br>of candidate vectors </li></ul><p><img src="/2019/09/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADPLink-User-Identity-Linkage-via-Deep-Neural-Network-From-Heterogeneous-Mobility-Data%E3%80%8B/trajectory_encoder.png" srcset="/img/loading.gif" alt="img"></p><h3 id="3-3-Comparator-Network"><a href="#3-3-Comparator-Network" class="headerlink" title="3.3 Comparator Network"></a>3.3 Comparator Network</h3><p>a multilayer feed-forward network </p><h3 id="3-4-Training-strategy"><a href="#3-4-Training-strategy" class="headerlink" title="3.4 Training strategy"></a>3.4 Training strategy</h3><p>loss function</p><script type="math/tex; mode=display">Loss = -\sum^{n}_{i=1}y_{i}log x_{i}+(1-y_{i})log(1-x_{i})</script><p>Adam</p><p>dropout</p><p>L2 regularization</p><p>learning rate</p><p><img src="/2019/09/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADPLink-User-Identity-Linkage-via-Deep-Neural-Network-From-Heterogeneous-Mobility-Data%E3%80%8B/train_strategy.png" srcset="/img/loading.gif" alt="img"></p><h2 id="4-Performance-Evaluation"><a href="#4-Performance-Evaluation" class="headerlink" title="4. Performance Evaluation"></a>4. Performance Evaluation</h2><p><strong>Datasets：</strong></p><p>ISP-Weibo </p><p>Foursquare-Twitter </p><p><strong>Baselines：</strong></p><p>NFLX、  MSQ、HIST 、LRCF 、WYCI 、POIS </p><p><strong>Metrics and Parameter Settings：</strong></p><h2 id="5-Related-Work"><a href="#5-Related-Work" class="headerlink" title="5. Related Work"></a>5. Related Work</h2><p>Identity Linkage using Trajectory Data：基于轨迹数据</p><p>Representation Learning for Trajectories </p>]]></content>
    
    
    <categories>
      
      <category>科研论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Social Networks</tag>
      
      <tag>User Identity Linkage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读《DeepLink: A Deep Learning Approach for User Identity Linkage》</title>
    <link href="/2019/09/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADeepLink-A-Deep-Learning-Approach-for-User-Identity-Linkage%E3%80%8B/"/>
    <url>/2019/09/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADeepLink-A-Deep-Learning-Approach-for-User-Identity-Linkage%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="DeepLink-A-Deep-Learning-Approach-for-User-Identity-Linkage"><a href="#DeepLink-A-Deep-Learning-Approach-for-User-Identity-Linkage" class="headerlink" title="DeepLink: A Deep Learning Approach for User Identity Linkage"></a>DeepLink: A Deep Learning Approach for User Identity Linkage</h1><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p><strong>Feature-based approaches 基于特征的方法</strong></p><p>从用户资料和社交平台的活动中提取独立的特征：e.g., username, gender, writing style</p><p><strong>Network-based approaches 基于网络的方法</strong></p><p>COSNET </p><p>IONE </p><a id="more"></a><p><strong>Challenge</strong></p><p>mapping the behaviors of cross-site accounts to a particular user  </p><p>user representation：</p><ul><li>cross-platform behavior prediction </li><li>cross-platform account correlation</li></ul><p>lack of labeled data</p><p><strong>Contributions</strong></p><ul><li>应用深度学习学习用户活动和网络结构的潜在语义</li><li>semi-supervised graph regularization to predict the context (neighboring structures) of<br>nodes in the network </li><li>dual-learning process </li></ul><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><h4 id="Profile-based-methods"><a href="#Profile-based-methods" class="headerlink" title="Profile-based methods"></a>Profile-based methods</h4><p>使用用户的用户资料信息，将不同社交平台的账号链接到一起</p><p>user name</p><p>writing style identification：grammatical structure，frequency of letters </p><h4 id="Network-based-methods"><a href="#Network-based-methods" class="headerlink" title="Network-based methods"></a>Network-based methods</h4><p>BIG-ALIGN </p><p>Neighborhood-based features </p><p>CLF </p><p>将网络节点的结构进行嵌入</p><h2 id="3-Preliminary-Background"><a href="#3-Preliminary-Background" class="headerlink" title="3. Preliminary Background"></a>3. Preliminary Background</h2><h4 id="Problem-Definition"><a href="#Problem-Definition" class="headerlink" title="Problem Definition"></a>Problem Definition</h4><p>Social Network Graph</p><p>Network Embedding Model</p><p>User Identity Linkage</p><p>Graph Mapping Function</p><h2 id="4-DeepLink：The-Proposed-Model"><a href="#4-DeepLink：The-Proposed-Model" class="headerlink" title="4. DeepLink：The Proposed Model"></a>4. DeepLink：The Proposed Model</h2><p><img src="/2019/09/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADeepLink-A-Deep-Learning-Approach-for-User-Identity-Linkage%E3%80%8B/architecture.png" srcset="/img/loading.gif" alt="img"></p><h4 id="Network-Structure-Sampling"><a href="#Network-Structure-Sampling" class="headerlink" title="Network Structure Sampling"></a>Network Structure Sampling</h4><p>首先通过几轮随机游走生成每一个user的多个 social sequence （每一个 social sequence 代表了用户的社交关系）</p><p>从顶点(用户) ui 开始，在每一步中沿着随机选择的边前进，直到到达长度L</p><p>algorithms：LINE，GraRep， node2vec</p><h4 id="User-Latent-Space-Embedding"><a href="#User-Latent-Space-Embedding" class="headerlink" title="User Latent Space Embedding"></a>User Latent Space Embedding</h4><h4 id="Neural-Mapping-Learning"><a href="#Neural-Mapping-Learning" class="headerlink" title="Neural Mapping Learning"></a>Neural Mapping Learning</h4><p>two Multi-Layer Perceptrons</p><h4 id="Linkage-Dual-Learning"><a href="#Linkage-Dual-Learning" class="headerlink" title="Linkage Dual Learning"></a>Linkage Dual Learning</h4><p>Unsupervised UIL Pretraining ：先从一个graph映射到另一个graph再映射回来</p><p>Supervised UIL Learning </p><p><img src="/2019/09/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADeepLink-A-Deep-Learning-Approach-for-User-Identity-Linkage%E3%80%8B/algorithm1.png" srcset="/img/loading.gif" alt="img"></p><script type="math/tex; mode=display">r_{s,t}^{a} = \frac{1}{k}\sum^{k}_{i=1}log(cos(v(u_{i}),v^{'}(u_{a}))+1)    (6)  \\r_{t,s}^{a} = \frac{1}{k}\sum^{k}_{i=1}log(cos(\Phi^{-1}(v(u_{i})),v(u_{a}))+1)    (6)</script><h2 id="5-Experiments"><a href="#5-Experiments" class="headerlink" title="5. Experiments"></a>5. Experiments</h2><p><strong>Dataset</strong></p><p><strong>Baseline and settings</strong></p><p>比较方法：</p><ul><li>Input-Output Network Embedding (IONE) : node vector, input vector and output vector</li><li>ONE: node vector and output vector</li><li>MAH: Manifold Alignment on Hypergraph </li><li>MAG: Manifold Alignment on traditional Graphs </li><li>CRW: Collective Random Walk  </li></ul><p><strong>Evaluation Metrics</strong></p><p>Precision@k(P@k) </p><p>MAP</p><p>AUC</p><p>Hit-Precision</p><script type="math/tex; mode=display">MAP = \frac{\sum^{n}\frac{1}{ra}}{n} \\AUC = \frac{\sum^{n}\frac{m+1-ra}{m}}{n} \\Hit-Precision =  \frac{\sum^{n}\frac{m+2-ra}{m+1}}{n} \\ra\;is\; the\; rank\; of\; the\; positive\;matching\;identity \\m\;is\; the\; number\; of\;negative\;user\;identities</script>]]></content>
    
    
    <categories>
      
      <category>科研论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Social Networks</tag>
      
      <tag>User Identity Linkage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推荐系统学习</title>
    <link href="/2019/09/12/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    <url>/2019/09/12/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="推荐系统学习"><a href="#推荐系统学习" class="headerlink" title="推荐系统学习"></a>推荐系统学习</h2><p>个性化推荐系统一般由四部分组成：信息采集模块、数据存储模块、推荐模块、推荐结果展示模块</p><h3 id="1-信息采集模块"><a href="#1-信息采集模块" class="headerlink" title="1. 信息采集模块"></a>1. 信息采集模块</h3><ul><li>用户信息：性别、年龄 …….</li><li>物品信息：种类、产地 … …</li><li>用户对物品的行为信息：显式行为、隐式行为</li></ul><a id="more"></a><hr><h3 id="2-数据存储模块"><a href="#2-数据存储模块" class="headerlink" title="2. 数据存储模块"></a>2. 数据存储模块</h3><hr><h3 id="3-推荐模块"><a href="#3-推荐模块" class="headerlink" title="3. 推荐模块"></a>3. 推荐模块</h3><h4 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h4><h4 id="1-基于内容的推荐算法-CB"><a href="#1-基于内容的推荐算法-CB" class="headerlink" title="1. 基于内容的推荐算法 CB"></a>1. 基于内容的推荐算法 CB</h4><p>根据用户过去喜欢过的物品的内容来为其推荐具有相似内容的东西<br><strong>步骤:</strong></p><ol><li><p>物品内容特征表示：物品的属性获得</p><ul><li><p>结构化属性：可以直接量化的属性</p></li><li><p>非结构化属性：需要二次解析，比如评论、描述等</p><p>​    文本类的属性信息的特征表示方法：TF-IDF, Word2vec</p></li></ul></li><li><p>用户兴趣特征表示：用户的历史偏好记录</p></li><li><p>计算用户与物品的匹配度：一般使用余弦相似度来计算</p></li><li>将用户<strong>未接触过且匹配度较高</strong>的前N项物品推荐给目标用户</li></ol><p><strong>优点：</strong></p><p>保证用户的独立性，其他用户的作弊行为不会影响到算法对当前用户的推荐结果</p><p>可解释性高，推荐的物品和他兴趣相匹配的特征</p><p>推荐新物品，对于从未被用户评分的新物品也可以推荐给用户，并且新物品和老物品被推荐的概率相同</p><p><strong>缺点：</strong></p><p>物品特征抽取困难</p><p>推荐结果同质化严重，只会给用户推荐与他过去喜欢过的物品相似的物品，推荐结果缺乏新颖性</p><p>用户冷启动，新用户没有历史偏好记录，无法学习他的兴趣特征</p><h4 id="2-协同过滤推荐算法-CF"><a href="#2-协同过滤推荐算法-CF" class="headerlink" title="2. 协同过滤推荐算法 CF"></a>2. 协同过滤推荐算法 CF</h4><h5 id="2-1-基于邻域的协同过滤"><a href="#2-1-基于邻域的协同过滤" class="headerlink" title="2.1 基于邻域的协同过滤"></a>2.1 基于邻域的协同过滤</h5><p>通过用户-物品评分矩阵分析用户（或物品）之间的相似度，利用相似度较大的邻居用户（或邻居物品）预测目标用户对候选物品的评分，并将评分较高的物品推荐给用户。根据相似度计算的主体，基于邻域的推荐算法又可以分为 <strong>基于用户的协同过滤</strong> 和 <strong>基于物品的协同过滤</strong></p><ul><li><p>基于用户的协同过滤：</p><p>找到与目标用户口味相近的用户(邻居用户)，然后对目标用户未接触过的物品，利用邻居用户评分信息和用户相似度预测目标用户的评分，将预测值排名前 N 项物品推荐给目标用户</p></li><li><p>基于物品的协同过滤</p><p>利用物品之间的相似度(根据用户行为计算而不考虑物品的内容)找到与目标用户过去喜欢的物品最相似的一些物品（邻居物品），利用目标用户已有的评分信息和物品相似度预测目标用户对候选物品的评分，将预测值排名前 N 项物品推荐给目标用户</p></li></ul><p><strong>基于邻域的推荐过程</strong></p><ol><li><p>构建用户-物品评分矩阵</p><p>矩阵中的每一项代表用户对物品的评分值</p><p>用户行为数据：</p><p>​    显式行为：打分、收藏</p><p>​    隐式行为：点击、浏览</p></li><li><p>计算相似度：</p><p>用户相似度：Pearson 相关系数</p><p>物品相似度：改进的余弦相似度</p></li><li><p>确定邻居集合</p><p>K 近邻和阈值过滤</p></li><li><p>预测评分生成推荐列表</p><p><strong>缺点</strong>：用户冷启动；物品冷启动；数据稀疏性问题；可扩展性问题</p></li></ol><p><strong>基于模型的协同过滤</strong><br>​用户-物品评分矩阵来训练一个预测模型，然后用该模型来计算评分矩阵中的缺失项<br>​模型：</p><ul><li><p>聚类模型</p></li><li><p>贝叶斯网络</p></li><li><p>图模型：将用户行为抽象为一个二部图，该图包含用户和物品两类节点，且只有用户节点和物品节点之间存在边，同种类型的节点间不存在边。用户节点和物品节点之间的边代表用户对物品的行为。</p><p>核心思想：计算和目标用户顶点没有直接连边的物品节点（即候选物品）与目标用户节点在图上的相关性。</p></li><li><p>矩阵分解模型：将用户和物品映射到同一维度的隐空间，通过隐空间的<strong>用户隐特征矩阵</strong>和<strong>物品隐特征矩阵</strong>之间的联系预测用户对物品的偏好值</p><pre><code>混合推荐算法</code></pre><p>推荐结果展示模块<br>在用户评分数据充足的情况下才能有较好的推荐效果</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>推荐系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>How to tackle with overfitting?</title>
    <link href="/2019/09/09/How-to-tackle-with-overfitting/"/>
    <url>/2019/09/09/How-to-tackle-with-overfitting/</url>
    
    <content type="html"><![CDATA[<h2 id="如何解决过拟合问题？"><a href="#如何解决过拟合问题？" class="headerlink" title="如何解决过拟合问题？"></a>如何解决过拟合问题？</h2><p>对于模型：</p><ul><li>Dropout: regularizing the network by randomly discarding nodes and connections during training 在训练得时候随机得使一些网络节点失活</li><li>Batch Normalization</li><li>Weight Decay</li></ul><p>对于模型的输入：</p><ul><li>数据增强<ul><li>data corruption</li></ul></li></ul><p>对于模型的输出：<br>penalizing theo ver-confident outputs </p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读《Deep Learning in bioinformatics: introduction, application and perspective in big data era》</title>
    <link href="/2019/09/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADeep-Learning-in-bioinformatics-introduction-application-and-perspective-in-big-data-era%E3%80%8B/"/>
    <url>/2019/09/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADeep-Learning-in-bioinformatics-introduction-application-and-perspective-in-big-data-era%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h4 id="Computer-Vision"><a href="#Computer-Vision" class="headerlink" title="Computer Vision"></a>Computer Vision</h4><ul><li>image recognition 图像识别</li><li>object detection 目标检测</li><li>image inpainting 图像修复</li><li>super-resolution  超分辨率</li></ul><a id="more"></a><h4 id="Natural-Language-Processing"><a href="#Natural-Language-Processing" class="headerlink" title="Natural Language Processing"></a>Natural Language Processing</h4><ul><li>text classification 文本分类</li><li>speech recognition 语音识别</li><li>machine translation 机器翻译</li></ul><h4 id="Bioinformatics"><a href="#Bioinformatics" class="headerlink" title="Bioinformatics"></a>Bioinformatics</h4><ol><li><p>sequence analysis 序列分析</p><ul><li>predict the effect of noncoding sequence variants  预测非编码序列变异的影响</li><li><strong>model the transcription factor binding affinity landscape 对转录因子结合亲和性的建模</strong> （PS：有一篇文章可以看）</li><li>improve DNA sequencing and peptide sequencing </li><li>analyze DNA sequence modification  分析DNA序列的变异</li><li>model various post-transcription regulation events  模拟各种转录后调控事件</li></ul></li><li><p>structure prediction and reconstruction 结构预测和重建</p><ul><li>protein secondary structure 蛋白质的二级结构</li><li>model the protein structure when it interacts with other molecules  </li><li>predict protein contact maps and the structure of membrane proteins 预测蛋白质的接触图和膜蛋白的结构</li><li>accelerates the fluorescence microscopy super-resolution</li></ul></li><li><p>biomolecular property and function prediction  生物分子性质和功能预测</p><ul><li>predicts enzyme detailed function by predicting the Enzyme Commission number 通过预测酶的EC number 预测酶的详细功能</li><li>predict the protein Gene Ontology (GO) </li><li>predicts the protein subcellular location 预测蛋白质亚细胞位置</li></ul></li><li><p>biomedical image processing and diagnosis 生物图像处理和诊断</p><ul><li>classifying skin cancer </li><li>predict fluorescent labels from transmitted-light images of unlabeled biological samples </li><li>analyze the cell imagining data </li></ul></li><li><p>biomolecule interaction prediction and system biology 生物相互作用预测与统生物学</p><ul><li>model the hierarchical structure and the function of the whole cell 对整个细胞的层次结构和功能进行建模</li><li>predict novel drug-target interaction 预测新的药物靶点相互作用</li><li>model polypharmacy sides effects - multi-modal graph convolutional networks </li></ul></li></ol><p><img src="/2019/09/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADeep-Learning-in-bioinformatics-introduction-application-and-perspective-in-big-data-era%E3%80%8B/data.png" srcset="/img/loading.gif" alt="img"></p><hr><h2 id="Deep-Learning-Methods"><a href="#Deep-Learning-Methods" class="headerlink" title="Deep Learning Methods"></a>Deep Learning Methods</h2><p>通过训练一个神经网络（具有非线性函数）来表达特征和标签之间的隐含关系。</p><p>需要训练参数 W, 让模型 fit data，实现这一目的的算法是前向-反向传播（<code>forward-backward propagation</code>)，通过最小化前向输出和标签之间的差异（loss or error）直到模型收敛</p><p>常用的 activation function：</p><p>​    hidden layer — ReLU </p><p>​    output layer — softmax</p><p>常用的 loss function：</p><p>​    classification — cross-entropy</p><p>​    regression — mean squared error</p><p>optimizer：</p><p>​    stochastic gradient descent （SGD）</p><p>​    Momentum with learning rate decay — understanding the problem</p><p>​    Adam  — not familiar with the problem</p><p>​    RMSprop</p><h3 id="CNN-Deep-Learning-Architecture"><a href="#CNN-Deep-Learning-Architecture" class="headerlink" title="CNN Deep Learning Architecture"></a>CNN Deep Learning Architecture</h3><p>local connectivity 局部连接 </p><p>weight sharing  权重共享</p><p>模型架构：</p><p>​    AlexNet、VGG、GoogleNet、ResNet、SENet、DenseNet、DPN</p><h3 id="RNN-Deep-Learning-Architecture"><a href="#RNN-Deep-Learning-Architecture" class="headerlink" title="RNN Deep Learning Architecture"></a>RNN Deep Learning Architecture</h3><p>模型架构：</p><p>​    LSTM、Bi-RNN、GRU</p><h3 id="Graph-Nerual-Networks"><a href="#Graph-Nerual-Networks" class="headerlink" title="Graph Nerual Networks"></a>Graph Nerual Networks</h3><p><strong>Primary task</strong>：</p><p>extract and encode the topological and connectivity information from the network  提取并编码网络的拓扑和连接信息</p><p>为了保证网络中节点的信息（邻居信息），构建一棵邻居树</p><p><img src="/2019/09/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADeep-Learning-in-bioinformatics-introduction-application-and-perspective-in-big-data-era%E3%80%8B/GCN.png" srcset="/img/loading.gif" alt="img"></p><h3 id="Generative-models-GAN-and-VAE-—-unsupervised-learning"><a href="#Generative-models-GAN-and-VAE-—-unsupervised-learning" class="headerlink" title="Generative models: GAN and VAE — unsupervised learning"></a>Generative models: GAN and VAE — unsupervised learning</h3><p>学习数据分布并且生成带有一些变化的新数据点</p><p><strong>GAN</strong></p><p><img src="/2019/09/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADeep-Learning-in-bioinformatics-introduction-application-and-perspective-in-big-data-era%E3%80%8B/GAN.png" srcset="/img/loading.gif" alt="img"></p><p><strong>Variational Autoencoder</strong></p><p>Autoencoder 并不能产生新的数据</p><p><img src="/2019/09/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADeep-Learning-in-bioinformatics-introduction-application-and-perspective-in-big-data-era%E3%80%8B/autoencoder.png" srcset="/img/loading.gif" alt="img"></p><p>Variational antoencoder </p><p><img src="/2019/09/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%8ADeep-Learning-in-bioinformatics-introduction-application-and-perspective-in-big-data-era%E3%80%8B/vae.png" srcset="/img/loading.gif" alt="img"></p><hr><h2 id="Applications-of-deep-learning-in-bioinformatics"><a href="#Applications-of-deep-learning-in-bioinformatics" class="headerlink" title="Applications of deep learning in bioinformatics"></a>Applications of deep learning in bioinformatics</h2><h3 id="1-Identifying-enzymes-using-multi-layer-neural-networks"><a href="#1-Identifying-enzymes-using-multi-layer-neural-networks" class="headerlink" title="1. Identifying enzymes using multi-layer neural networks"></a>1. Identifying enzymes using multi-layer neural networks</h3><p>identify enzyme sequences based on sequence information using deep learning based methods 用深度学习的方法基于序列信息预测酶的序列</p><p>encoder the protein sequences into numbers → Forward Nerual Network</p><h3 id="2-Gene-expression-regression"><a href="#2-Gene-expression-regression" class="headerlink" title="2. Gene expression regression"></a>2. Gene expression regression</h3><p>different genes’ expression can be highly correlated </p><p>profiling around 1000 carefully selected landmark genes and predicting the expression of the other target genes based on computational methods and landmark gene expression </p><h3 id="3-RNA-protein-binding-sites-prediction-with-CNN"><a href="#3-RNA-protein-binding-sites-prediction-with-CNN" class="headerlink" title="3. RNA-protein binding sites prediction with CNN"></a>3. RNA-protein binding sites prediction with CNN</h3><p>RNA-binding proteins (RBP)  RNA 结合蛋白</p><p>将RNN序列编码为 2D tensors</p><h3 id="4-DNA-sequence-function-prediction-with-CNN-and-RNN"><a href="#4-DNA-sequence-function-prediction-with-CNN-and-RNN" class="headerlink" title="4. DNA sequence function prediction with CNN and RNN"></a>4. DNA sequence function prediction with CNN and RNN</h3><p>predict the functionality of non-coding DNA sequences 预测DNA序列的非编码区的功能</p><h3 id="5-Biomedical-image-classification-using-transfer-learning-and-ResNet"><a href="#5-Biomedical-image-classification-using-transfer-learning-and-ResNet" class="headerlink" title="5. Biomedical image classification using transfer learning and ResNet"></a>5. Biomedical image classification using transfer learning and ResNet</h3><h3 id="6-Graph-embedding-for-novel-protein-interaction-prediction-using-GCN"><a href="#6-Graph-embedding-for-novel-protein-interaction-prediction-using-GCN" class="headerlink" title="6. Graph embedding for novel protein interaction prediction using GCN"></a>6. Graph embedding for novel protein interaction prediction using GCN</h3><p>graph embedding — PPI networks</p><p>使用 GCN 学得节点（蛋白质）的嵌入表示，然后 apply the interaction operation (inner product) to each pair of nodes </p><h3 id="7-Biology-image-super-resolution-using-GAN"><a href="#7-Biology-image-super-resolution-using-GAN" class="headerlink" title="7. Biology image super-resolution using GAN"></a>7. Biology image super-resolution using GAN</h3><h3 id="8-High-dimensional-biological-data-embedding-and-generation-with-VAE"><a href="#8-High-dimensional-biological-data-embedding-and-generation-with-VAE" class="headerlink" title="8. High dimensional biological data embedding and generation with VAE"></a>8. High dimensional biological data embedding and generation with VAE</h3><hr><h2 id="Perspectives-limitations-and-suggestions"><a href="#Perspectives-limitations-and-suggestions" class="headerlink" title="Perspectives: limitations and suggestions"></a>Perspectives: limitations and suggestions</h2><h4 id="1-Lack-of-data"><a href="#1-Lack-of-data" class="headerlink" title="1. Lack of data"></a>1. Lack of data</h4><p>transfer learning</p><p>use a well trained model from another similar task and fine tune the last one or two layers using the limited real data  </p><p>data augmentation</p><p>simulated data </p><h4 id="2-Overfitting"><a href="#2-Overfitting" class="headerlink" title="2. Overfitting"></a>2. Overfitting</h4><p>acts on the model parameters and the model architecture :</p><ul><li>dropout</li><li>batch normalization</li><li>weight decay</li></ul><h4 id="3-Imbalanced-data"><a href="#3-Imbalanced-data" class="headerlink" title="3. Imbalanced data"></a>3. Imbalanced data</h4><ul><li>use the right criteria to evaluate the prediction result and the loss  使用恰当的评价标准衡量模型的预测结果</li><li>upsample smaller classes</li><li>downsample larger classes</li></ul><h4 id="4-Interpretability"><a href="#4-Interpretability" class="headerlink" title="4. Interpretability"></a>4. Interpretability</h4><p>查看输入的每一部分的重要性分数</p><p>Perturbation-based approaches </p><p>Backpropagation-based methods </p><h4 id="5-Uncertainty-scaling"><a href="#5-Uncertainty-scaling" class="headerlink" title="5. Uncertainty scaling"></a>5. Uncertainty scaling</h4><p>legendary Platt scaling </p><p>histogram binning </p><p>isotonic regression 保序回归</p><p>Bayssian Binning into Quantiles </p><p>temperature scaling  </p><h4 id="6-Catastrophic-forgetting"><a href="#6-Catastrophic-forgetting" class="headerlink" title="6. Catastrophic forgetting"></a>6. Catastrophic forgetting</h4><ul><li>regularizations：EWC</li><li>dynamic nerual network</li><li>rehearsal training methods：iCaRL </li></ul><h4 id="7-Reducing-computational-requirement-and-model-compression-减少计算需求并进行模型压缩"><a href="#7-Reducing-computational-requirement-and-model-compression-减少计算需求并进行模型压缩" class="headerlink" title="7. Reducing computational requirement and model compression  减少计算需求并进行模型压缩"></a>7. Reducing computational requirement and model compression  减少计算需求并进行模型压缩</h4><ul><li>parameter pruning ：reduces the redundant parameters </li><li>knowledge distillation </li><li>use compact convolutional filters to save parameters </li><li>low rank factorization </li></ul>]]></content>
    
    
    <categories>
      
      <category>科研论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生物信息学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地配置两段跳的服务器</title>
    <link href="/2019/09/07/%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE%E4%B8%A4%E6%AE%B5%E8%B7%B3%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2019/09/07/%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE%E4%B8%A4%E6%AE%B5%E8%B7%B3%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>实验室的服务器为了保证访问的安全性，设置了跳板机，平时使用服务器的时候会比较麻烦。</p><p>尝试本地配置对服务器的连接，可以使用本地的 Pycharm 和 Jupyter Notebook</p><a id="more"></a><p>在本地使用命令</p><pre><code class="hljs angelscript">ssh -f -N -L <span class="hljs-number">3000</span>:<span class="hljs-number">172.20</span><span class="hljs-number">.0</span><span class="hljs-number">.6</span>:<span class="hljs-number">22</span> <span class="hljs-symbol">user@</span>jump_server_ip -p <span class="hljs-number">3000</span></code></pre><p>其中 第一个<code>3000</code>是本机端口，省略了<code>127.0.0.1</code>；</p><p>服务器 ip：<code>172.20.0.6</code>，端口号是 22 </p><p><code>user@jump_server_ip</code>:  跳板机的用户名+ip 端口是 <code>3000</code></p><h3 id="本地配置可连接服务器的-jupyter-notebook"><a href="#本地配置可连接服务器的-jupyter-notebook" class="headerlink" title="本地配置可连接服务器的 jupyter notebook"></a>本地配置可连接服务器的 jupyter notebook</h3>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Re-learn</title>
    <link href="/2019/09/07/Java-Re-learn/"/>
    <url>/2019/09/07/Java-Re-learn/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Java-基础"><a href="#1-Java-基础" class="headerlink" title="1. Java 基础"></a>1. Java 基础</h2><h4 id="常见Dos命令"><a href="#常见Dos命令" class="headerlink" title="常见Dos命令"></a>常见Dos命令</h4><p>dir：列出当前目录下的文件以及文件夹<br>md: 创建目录<br>rd：删除目录<br>cd：进入指定目录<br>cd..：退回到上一级目录<br>cd\：退回到根目录<br>del：删除文件<br>exit：退出dos命令行  </p><a id="more"></a><h4 id="Java-语言概述"><a href="#Java-语言概述" class="headerlink" title="Java 语言概述"></a>Java 语言概述</h4><p><strong>特性</strong>：强面向对象，分布式，健壮（强类型机制、异常处理、垃圾的自动回收机制）、安全的、体系结构中立的、解释型的（先编译后运行）、支持多线程的</p><p><strong>Java技术体系平台</strong>：</p><p>Java SE：标准版</p><p>Java EE：企业版</p><p>Java ME</p><p>Java Card</p><h4 id="Java-语言运行机制及运行过程"><a href="#Java-语言运行机制及运行过程" class="headerlink" title="Java 语言运行机制及运行过程"></a>Java 语言运行机制及运行过程</h4><p><strong>Java 语言的特点</strong>：面向对象（封装、继承、多态）、健壮完善、跨平台 JVM（Java虚拟机）</p><p><strong>Java两种核心机制</strong>：</p><p>​    JVM（Java 虚拟机）：虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存和寄存器。</p><p>​    GC （垃圾收集机制）：</p><blockquote><p>同时使用多个JDK的话，使用压缩版的JDK</p></blockquote><p><strong>什么是 JDK、JRE</strong></p><p>JDK：Java 开发工具包</p><p>JRE：Java 运行环境</p><p>JDK &gt; JRE &gt; JVM</p><p><strong>Java 程序</strong></p><p>java 源文件以 <code>.java</code> 作为扩展名</p><p><strong>注释</strong></p><p>单行注释 //</p><p>多行注释 /<em> </em>/</p><p>文档注释 /<strong>  </strong>/</p><hr><h2 id="2-Java基本语法"><a href="#2-Java基本语法" class="headerlink" title="2.  Java基本语法"></a>2.  Java基本语法</h2><h4 id="Java-关键词和保留字"><a href="#Java-关键词和保留字" class="headerlink" title="Java 关键词和保留字"></a>Java 关键词和保留字</h4><p><strong>标识符</strong>：对各种变量、方法和类等要素命名时使用的字符序列称为标识符</p><p>​    凡是自己可以起名字的地方</p><p><strong>命名规范</strong>：</p><p>​    包名：多单词组成时所有字母小写 xxyyzz</p><p>​    类名，接口名：多单词组成时，所有单词的首字母大写 XxxYyyZzz</p><p>​    变量名、方法名：多单词组成时，第一个单词的首字母小写，第二个单词开始，每个单词的首字母大写 xxxYyyZzz</p><p>​    常量名：所有字母都大写，多单词时每个单词之间用下划线连接 XXX_YYY_ZZZ</p><h4 id="Java中的变量"><a href="#Java中的变量" class="headerlink" title="Java中的变量"></a>Java中的变量</h4><p>定义：<strong>数据类型 变量名 = 变量的值</strong> <code>eg：int i = 1;</code></p><p>概念：内存中的一个存储区域</p><p>​            该区域有自己的名称（变量名）和类型（数据类型）</p><p>​            Java 中每个变量必须先声明，后使用</p><p>​            该区域的数据可以在同一类型范围内不断变化</p><p>注意：变量的作用域，一对{}之间有效； 初始化值</p><p>变量是通过使用变量名来访问这块区域的</p><p><strong>变量的分类</strong>：按数据类型</p><p><img src="/2019/09/07/Java-Re-learn/数据类型.png" srcset="/img/loading.gif" alt="img"></p><p><strong>基本数据类型转换</strong>：</p><ul><li><p>自动类型转换：容量小的类型自动转换为容量大的类型</p><p><img src="/2019/09/07/Java-Re-learn/排序.png" srcset="/img/loading.gif" alt="img"></p><ul><li>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的数据类型，然后再进行计算</li><li>char 类型在进行数学运算时，转换为相应的ASCII值，进行计算</li><li>当把任何基本类型的值和字符串进行连接运算时（+），基本类型的值将自动转换为字符串类型<ul><li>当有一系列的 <code>+</code> 运算时，如果某个部分其中含有字符串，那么这个字符串前边挨着的 <code>+</code> 开始一直往后都是要按照字符串拼接去看</li></ul></li></ul></li></ul><ul><li><p>强制类型转换</p><ul><li><p>加强制转换符，但可能造成精度降低或溢出</p></li><li><p>通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换为基本类型：</p><p>String a = ‘43’; int i = Integer.parseInt(a);</p></li><li><p>boolean 无法转换成其他类型</p></li></ul><p><strong>运算符</strong>：特殊符号，用以表示数据的运算、赋值和比较</p></li><li><p>算术运算符</p><p>|   运算符   |                          运算                          |             范例             |           结果           |<br>| :————: | :——————————————————————————: | :—————————————: | :———————————: |<br>|     +      |                          正号                          |              +3              |            3             |<br>|     -      |                          负号                          |           b=4; -b            |            -4            |<br>|     +      |                           加                           |             5+5              |            10            |<br>|     -      |                           减                           |             6-4              |            2             |<br>|     <em>      |                           乘                           |             3</em>4              |            12            |<br>|     /      |                           除                           |             5/5              |            1             |<br>|     %      |                          取模                          |             7%5              |            2             |<br>| ++<br>++ | 自增（前），先运算后取值<br>自增（后），先取值后运算 | a=2; b=++a;<br>a=2; b=a++; | a=3; b=3;<br>a=3; b=2; |<br>| —<br>— | 自减（前），先运算后取值<br>自减（后），先取值后运算 | a=2; b=—a;<br>a=2; b=a—; | a=1; b=1;<br>a=1; b=2; |<br>|     +      |                       字符串连接                       |          “He”+”llo”          |         “Hello”          |</p><p>PS: </p><ul><li><p>如果对负数取模，可以把模数负号忽略不记，如：5%-2=1. 但被模数是负数则不可以忽略。此外，取模运算的结果不一定总是整数</p></li><li><p>对于除号 “/“ ,它的整数除和小数除是有区别的</p></li><li><p>“+” 除了字符串相加功能外，还能把非字符串转换成字符串</p><p>例如：`System.out.println(“5+5=”+5+5); // 打印结果是 5+5=55</p></li></ul><ul><li>char类型数据是可以做数学运算的，在做数学运算的时候把字符转为ASCII码进行</li></ul></li><li><p>赋值运算符</p><ul><li>符号： =  可以进行连续赋值</li><li>+=、-=、*=、/=、%=</li><li>变量参与运算时，Java程序不知道具体的这个变量在做完运算后会不会查重当前变量的范围，所有会先把变量转换为一个更大长度</li><li>在使用扩展运算符时，变量参与运算时会把结果自动强制转换为当前变量的类型</li></ul></li><li><p>比较运算符（关系运算符）</p><p>| 运算符 |   运算   | 范例 | 结果  |<br>| :——: | :———: | :—: | :—-: |<br>|   ==   |  相等于  | 4==3 | False |<br>|   !=   |  不等于  | 4!=3 | True  |<br>|   &lt;    |   小于   | 4<3 | false>    |   大于   | 4&gt;3  | True  |<br>|   &lt;=   | 小于等于 | 4&lt;=3 | False |<br>|   &gt;=   | 大于等于 | 4&gt;=3 | True  |</3></p></li><li><p>逻辑运算符</p><p>|      操作      | 选择  | 选择  | 选择  | 选择  |<br>| :——————: | :—-: | :—-: | :—-: | :—-: |<br>|       a        | true  | true  | false | false |<br>|       b        | true  | false | true  | true  |<br>|      a&amp;b       | true  | false | false | false |<br>|      a|b      | true  | true  | true  | false |<br>|       !a       | false | false | true  | true  |<br>|      a^b       | false | true  | true  | false |<br>|  a&amp;&amp;b 短路与   | true  | false | false | false |<br>| a||b  短路或 | true  | true  | true  | false |</p><p><strong>“&amp;” 和 “&amp;&amp;”的区别：</strong></p><p>单 &amp; 时，左边无论真假，右边都进行运算</p><p>双 &amp;&amp; 时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算</p><p><strong>“|” 和 “||”的区别</strong></p><p>|| 表示，当左边为真，右边不参与运算</p></li><li><p>位运算符：位运算都是针对二进制进行运算</p><p>| 运算符 |    运算    |                       范例                       |                             总结                             |<br>| :——: | :————: | :———————————————————————: | :—————————————————————————————: |<br>|   &lt;&lt;   |    左移    | 3&lt;<2 12 = -> 3 <em> 2 </em> 2 = 12<br>m&lt;<n -> m <em> 2^n |             空位补0，被移除的高位丢弃，空缺位补0             |<br>|   &gt;&gt;   |    右移    |    3&gt;&gt;1 = 1 -&gt; 3/2 = 1<br>m&gt;&gt;n -&gt; m </em> 2^-n     | 被移除的二进制最高位是0，右移后，空位补0；<br>最高位是1，空缺位补1 |<br>|  &gt;&gt;&gt;   | 无符号右移 |               3&gt;&gt;&gt;1 = 1 -&gt; 3/2 = 1               |       被移除二进制无论最高位是0或者是1，空缺位都用0补        |<br>|   &amp;    |   与运算   |            6&amp;3 = 2  -&gt; 110&amp;011 = 010             |          二进制位进行&amp;运算，只有1&amp;1结果是1，否则是0          |<br>|   |   |   或运算   |            6|3 = 7 -&gt; 110|011 = 111            |         二进制位进行|运算，只有0|0结果是0，否则是1         |<br>|   ^    |  异或运算  |            6^3 = 5 -&gt; 110 ^011 = 101             |         相同二进制位进行^运算结果是0，不相同结果是1          |<br>|   ~    |    反码    |                     ~6 = -7                      | 正数取反，各二进制码按补码各位取反；<br>负数取反，各二进制码按补码各位取反 |</n></2></p><p>PS ：有符号的右移是看右移之后的首位是0还是1，是0前面空位，是1就补1</p></li><li><p>三元运算符</p><p>（条件表达式）？表达式1 ：表达式2</p><p>条件表达式为 true，运算后的结果为表达式 1</p><p>条件表达式为 false，运算后的结果为表达式 2</p></li></ul><p><strong>运算符的优先级</strong></p><p><img src="/2019/09/07/Java-Re-learn/运算符优先级.jpg" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ELMO -- Deep contextualized word representations</title>
    <link href="/2019/08/18/ELMO-Deep-contextualized-word-representations/"/>
    <url>/2019/08/18/ELMO-Deep-contextualized-word-representations/</url>
    
    <content type="html"><![CDATA[<p>从经典的语言模型开始<br>ELMO — Embedding form Language Model<br><a id="more"></a><br><strong>1-of-N Encoding</strong>：<br>每一个word，只有一维是0，其他位置都是1. 缺点：无法得知词汇之间的关系。<br><strong>Word Class</strong>：<br>对词汇进行分类<br><strong>Word Embedding</strong>：<br>Soft Word Class 每一个词汇用一个向量表示，其中词向量的每一维可能表示这个词汇的某种意思。语义相近的词汇，词向量比较接近。<br><strong>Contextualized Word Embedding</strong>:<br>每一个 word token 都有自己的 embedding<br>ELMO：RNN-based language model</p><p><img src="/2019/08/18/ELMO-Deep-contextualized-word-representations/elmo" srcset="/img/loading.gif" alt="hexo img"></p><p>正向 RNN 得到的 Embdeding 和反向 RNN 的 Embedding 拼接起来。由于 RNN 是考虑当前词汇前面整个句子的信息的，因此可以说这样得到的 embedding 向量是上下文有关的。</p><p>当时用多层 RNN 的时候，每一层的RNN都会给出一个该词汇的 embedding ，对于不同层得到的 embedding 进行加权求和，得到最终的 embedding 用于下游任务。其中每一层 embedding 的权重是根据下游任务类型自己学到的。</p><p><img src="/2019/08/18/ELMO-Deep-contextualized-word-representations/elmo2" srcset="/img/loading.gif" alt="img"></p><h4 id="ElMO-详解"><a href="#ElMO-详解" class="headerlink" title="ElMO 详解"></a>ElMO 详解</h4><p><strong>Bidirectional language models</strong>：<br>在给定 $(t<em>{1}, …, t</em>{k-1})$ 情况下，求 token $t_{k}$ 的概率</p><script type="math/tex; mode=display">p(t_{1},t_{2},...,t_{N}) = \prod_{k=1}^{N}p(t_{k}|t_{1},t_{2},...,t_{k-1})</script><p>后向的计算方法与前向相似</p><script type="math/tex; mode=display">p(t_{1},t_{2},...,t_{N}) = \prod_{k=1}^{N}p(t_{k}|t_{k+1},t_{k+2},...,t_{N})</script><p>biLM 最大化前向和反向网络的log likelihood</p><script type="math/tex; mode=display">\sum_{k=1}^N(log p(t_{k}|t_{1},...,t_{k-1};\Theta_{x},\vec\Theta_{LSTM},\Theta_{s})) \\+ log p(t_{k}|t_{k+1},...,t_{N};\Theta_{x},\overleftarrow\Theta_{LSTM},\Theta_{s}))</script><p>ELMo 对于每个token $t_{k}$ ,通过 L 层的BiLM 计算得到 2L+1个表示</p><p><img src="https://www.zhihu.com/equation?tex=R_k+%3D+%5C%7Bx_k%5E%7BLM%7D%2C+%5Coverrightarrow%7Bh%7D_%7Bk%2Cj%7D%5E%7BLM%7D%2C+%5Coverleftarrow%7Bh%7D_%7Bk%2C+j%7D%5E%7BLM%7D+%5Cvert+j%3D1%2C+...%2C+L%5C%7D+%3D+%5C%7Bh_%7Bk%2Cj%7D%5E%7BLM%7D+%5Cvert+j%3D0%2C...%2C+L%5C%7D" srcset="/img/loading.gif" alt="[公式]"><br>所有 biLM输出层的向量组合成一个向量，最简单的是只选择最上层的输出向量，本文采用加权求和的方式，每一项的权值是通过 softmax 来计算的，任务不同权值可以通过学习得到。<br><img src="https://www.zhihu.com/equation?tex=E+L+M+o_%7Bk%7D%5E%7Bt+a+s+k%7D%3DE%5Cleft%28R_%7Bk%7D+%3B+%5CTheta%5E%7Bt+a+s+k%7D%5Cright%29%3D%5Cgamma%5E%7Bt+a+s+k%7D+%5Csum_%7Bj%3D0%7D%5E%7BL%7D+s_%7Bj%7D%5E%7Bt+a+s+k%7D+h_%7Bk%2C+j%7D%5E%7BL+M%7D" srcset="/img/loading.gif" alt="[公式]"></p><blockquote><p>ELMO 的本质思想是：事先用语言模型学好一个单词的 Word Embedding，此时多义词无法区分，不过这没关系。在实际使用 Word Embedding 的时候，单词已经具备了特定的上下文了，这个时候可以根据上下文单词的语义去调整单词的 Word Embedding 表示，这样经过调整后的 Word Embedding 更能表达在这个上下文中的具体含义，自然也就解决了多义词的问题了。所以 <strong>ELMO 本身是个根据当前上下文对 Word Embedding 动态调整的思路</strong>。</p></blockquote><p><img src="/2019/08/18/ELMO-Deep-contextualized-word-representations/elmo3" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NLP Basic</title>
    <link href="/2019/08/17/NLP-Basic/"/>
    <url>/2019/08/17/NLP-Basic/</url>
    
    <content type="html"><![CDATA[<h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>(Workshop on Machine Translation) - 机器翻译研讨会</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><h3 id="度量标准"><a href="#度量标准" class="headerlink" title="度量标准"></a>度量标准</h3><p>BLEU score：Bilingual Evaluation Understudy（双语评估替换）比较候选文本翻译与其他一个或多个参考翻译的评价分数。是一种对生成语句进行评估的指标。</p><blockquote><p>BLEU编程实现的主要任务是对候选翻译和参考翻译的 n 元组进行比较，并计算相匹配的个数。匹配个数与单词的位置无关。匹配个数越多，表明候选翻译的质量就越好。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Seq2Seq-Learning-with-Nerual-Network-code</title>
    <link href="/2019/08/17/Seq2Seq-Learning-with-Nerual-Network-code/"/>
    <url>/2019/08/17/Seq2Seq-Learning-with-Nerual-Network-code/</url>
    
    <content type="html"><![CDATA[<h3 id="论文阅读-《Sequence-to-Sequence-Learning-with-Neural-Networks》"><a href="#论文阅读-《Sequence-to-Sequence-Learning-with-Neural-Networks》" class="headerlink" title="论文阅读 《Sequence to Sequence Learning with Neural Networks》"></a>论文阅读 《Sequence to Sequence Learning with Neural Networks》</h3><p>“Our method uses a multilayered Long Short-Term Memory (LSTM) to map the input sequence<br>to a vector of a fixed dimensionality, and then another deep LSTM to decode the target sequence from the vector. ”<br>首先用一个多层的 LSTM 将输入的序列编码为一个固定维度的向量（将输入进行翻转，以引入更多的 short dependencies）<br>然后用一个 LSTM 进行解码为输出序列</p><a id="more"></a><p><img src="/2019/08/17/Seq2Seq-Learning-with-Nerual-Network-code/seq2seq.png" srcset="/img/loading.gif" alt="seq2seq"></p><p>字符 -&gt; word2vec词向量(或对词向量进行随机初始化，让网络模型自己学习)</p>]]></content>
    
    
    <categories>
      
      <category>科研论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Attention is All you Need</title>
    <link href="/2019/08/17/Attention-is-All-you-Need/"/>
    <url>/2019/08/17/Attention-is-All-you-Need/</url>
    
    <content type="html"><![CDATA[<p>简单来说，Attention 可以理解为表示重要性的权重向量</p><p>为了预测或推断一个元素，使用<strong>注意力权重</strong>来估计其它元素与其相关的强度，并由<strong>注意力权重加权的值的总和</strong>作为计算最终目标的特征。</p><ul><li>step 1：计算其它元素与待预测元素的相关性权重</li><li>step 2：根据相关性权重对其他元素进行加权求和</li></ul><h4 id="Attention-机制"><a href="#Attention-机制" class="headerlink" title="Attention 机制"></a>Attention 机制</h4><p>对Encoder层状态的加权</p><p><img src="/2019/08/17/Attention-is-All-you-Need/Attention.jpg" srcset="/img/loading.gif" alt="img"></p><h4 id="Seq2Seq"><a href="#Seq2Seq" class="headerlink" title="Seq2Seq"></a>Seq2Seq</h4><p>对于一个输入序列，我们需要将其转化为一个新的输出序列，其中输入、输出序列的长度可以是任意的长度</p><ul><li>机器翻译</li><li>问答系统</li><li>语音识别</li></ul><p>使用 Encoder-Decoder 框架 </p><p>Sutskever  et al., Sequence to sequence learning with neural networks. 2014</p><p>Bahdanau et al.,  (2014). Neural machine translation by jointly learning to align and translate</p><h4 id="Self-Attention"><a href="#Self-Attention" class="headerlink" title="Self Attention"></a>Self Attention</h4><p>一个序列之间自己做 attention ，每一个词的 embedding 产生一个q vector，k vector，v vector,  用 q 去匹配每一个 k（计算dot-product)，通过一个 softmax 映射为权重，再与 v 相乘，求和（这一步可以看做加权求和，就是 attention 的思想），得到最终的表示 z 。</p><p><img src="/2019/08/17/Attention-is-All-you-Need/self-attention.png" srcset="/img/loading.gif" alt="img"></p><h4 id="Multi-head-Attention"><a href="#Multi-head-Attention" class="headerlink" title="Multi-head Attention"></a>Multi-head Attention</h4><p>生成多组 （Q，K，V）分别进行 self-attention 计算，将最后得到的多个 z 进行拼接。好处是多个 head 可以捕获不同的特征</p><p><img src="/2019/08/17/Attention-is-All-you-Need/transformer_multi-headed_self-attention-recap.png" srcset="/img/loading.gif" alt="img"></p><h4 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h4><p><img src="/2019/08/17/Attention-is-All-you-Need/transformer_resideual_layer_norm_3.png" srcset="/img/loading.gif" alt="img"></p><p><strong>PS</strong>：<br>Transformer 重点是如何做self-attention，其中 Q, K, V的计算比较重要，解释这篇论文比较好的博客有：</p><p><a href="http://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener" title="The Illustrated Transformer">The Illustrated Transformer</a><br><a href="https://zhuanlan.zhihu.com/p/39034683" target="_blank" rel="noopener" title="Transformer模型笔记">Transformer模型笔记</a></p><p>论文来自:</p><p><a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener" title="Attention Is All You Need">Attention Is All You Need</a></p>]]></content>
    
    
    <categories>
      
      <category>科研论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Attention</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛顿求根法</title>
    <link href="/2019/08/16/%E7%89%9B%E9%A1%BF%E6%B1%82%E6%A0%B9%E6%B3%95/"/>
    <url>/2019/08/16/%E7%89%9B%E9%A1%BF%E6%B1%82%E6%A0%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>牛顿求根法</p><script type="math/tex; mode=display">x_{n+1} = x_{n} - \frac{f(x_{n})}{f^{'}{(x_{n})}}</script><p><img src="/2019/08/16/%E7%89%9B%E9%A1%BF%E6%B1%82%E6%A0%B9%E6%B3%95/MyHexo\source\_posts\牛顿求根法\dfig" srcset="/img/loading.gif" alt="image.png"></p><p>应用牛顿法求解平方根，可令 </p><script type="math/tex; mode=display">f(x)=x^2-a \\f(x)\approx f(x_{0}) + (x-x_{0})f^{'}(x_{0}) \\ 令f(x)=0 \rightarrow  x = x_{0} - \frac{f(x_{0})}{f^{'}(x_{0})} = \frac{1}{2}(x_{0} + \frac{a}{x_{0}})</script>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linear Algebra 01 -- LHY</title>
    <link href="/2019/08/13/Linear-Algebra-01-LHY/"/>
    <url>/2019/08/13/Linear-Algebra-01-LHY/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Linear-System"><a href="#Linear-System" class="headerlink" title="Linear System"></a>Linear System</h4><ul><li><ol><li>Persevering Multiplication<script type="math/tex; mode=display"> x \rightarrow y \\ kx \rightarrow ky \\</script></li></ol></li><li><ol><li>Persevering Addition<script type="math/tex; mode=display">x_{1} \rightarrow (x_{1} )^2 \\x_{2} \rightarrow (x_{2})^2 \\x_{1} + x_{2} \rightarrow (x_{1} + x_{2})^2</script></li></ol></li></ul><h4 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h4><p>Transform</p><p>PageRank</p><p>Computer Graphics</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dynamic Programming 动态规划</title>
    <link href="/2019/08/12/Dynamic-Programming-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2019/08/12/Dynamic-Programming-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>动态规划算法<br><a id="more"></a><br>将问题分解为最优的子问题<br>递归的定义解通过子问题的最优解<br><strong>optimal structure 最优子结构</strong><br>一个问题可以分解为多个子问题，子问题有最优解，这个问题就可以通过子问题的最优解组合得出。<br><strong>Overlapping subproblems 重叠子问题</strong></p><p><strong>边界</strong></p><p>子问题可解</p><p><strong>子问题独立</strong></p><p>可以使用递归算法来解决。</p><p>在动态规划算法中使用数组来保存子问题的解，这样子问题多次求解的时候可以直接查表不用调用函数递归。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p><strong>Tabulation  — bottom-up（自底向上）</strong></p><p><strong>Memoization — top-down（自上而下）</strong></p><p>使用递归</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learn NLP using Pytorch</title>
    <link href="/2019/08/11/Learn-NLP-using-Pytorch/"/>
    <url>/2019/08/11/Learn-NLP-using-Pytorch/</url>
    
    <content type="html"><![CDATA[<p>学习使用 Pytorch 进行 NLP 项目实践<br><a id="more"></a></p><h4 id="1-基本数据模块-张量（Tensor）"><a href="#1-基本数据模块-张量（Tensor）" class="headerlink" title="1. 基本数据模块  张量（Tensor）"></a>1. 基本数据模块  张量（Tensor）</h4><p>N维矩阵</p><p>python的数据类型转为tensor</p><pre><code class="hljs python">torch.tensor()</code></pre><p>一维 tensor, 通过索引取到值</p><p>二维 tensor，通过索引取到向量</p><p>三维 tensor，通过索引取到矩阵</p><p><strong>张量的拼接</strong></p><pre><code class="hljs python">torch.cat([])  <span class="hljs-comment">## 默认按照第一个维度进行拼接，可以用axis指定维度，默认axis=0</span></code></pre><p><strong>Tensor变形</strong></p><pre><code class="hljs python">x.view() <span class="hljs-comment">## 改变tensor的形状</span></code></pre><h4 id="2-计算图以及自动微分"><a href="#2-计算图以及自动微分" class="headerlink" title="2. 计算图以及自动微分"></a>2. 计算图以及自动微分</h4><p>Pytorch 1.0 中只需要在构建 tensor 时加入 <code>required_grad = True</code>, 这个tensor上的操作都会构造一个计算图，从而实现自动求导。</p><pre><code class="hljs python">eg: x = torch.tensor(required_grad = <span class="hljs-literal">True</span>)x.grad    <span class="hljs-comment">## tensor 是x关于某个标量值的梯度</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Overview of Sematic Similarity</title>
    <link href="/2019/08/11/Overview-of-Sematic-Similarity/"/>
    <url>/2019/08/11/Overview-of-Sematic-Similarity/</url>
    
    <content type="html"><![CDATA[<p>句子相似性检测方法总结<br><a id="more"></a></p><h3 id="1-Siamese-network"><a href="#1-Siamese-network" class="headerlink" title="1.  Siamese network"></a>1.  Siamese network</h3><h3 id="2-Matching-aggregation"><a href="#2-Matching-aggregation" class="headerlink" title="2. Matching-aggregation"></a>2. Matching-aggregation</h3><h4 id="ESIM"><a href="#ESIM" class="headerlink" title="ESIM"></a>ESIM</h4><h4 id="BiMPM"><a href="#BiMPM" class="headerlink" title="BiMPM"></a>BiMPM</h4><h3 id="3-Bert-Fine-tuning"><a href="#3-Bert-Fine-tuning" class="headerlink" title="3. Bert Fine-tuning"></a>3. Bert Fine-tuning</h3>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
